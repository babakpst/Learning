namespace std {
    typedef unsigned long size_t;
    typedef long ptrdiff_t;
    typedef decltype(nullptr) nullptr_t;
}
namespace std {
    inline namespace __cxx11 {
    }
}
namespace __gnu_cxx {
    inline namespace __cxx11 {
    }
}
namespace std {
    template <typename _Tp, _Tp __v> struct integral_constant {
        static constexpr _Tp value = __v;
        typedef _Tp value_type;
        typedef integral_constant<_Tp, __v> type;
        constexpr operator value_type() const noexcept         {
            return value;
        }
        constexpr std::integral_constant::value_type operator()() const noexcept         {
            return value;
        }
    };
template<> struct integral_constant<bool, true> {
        static constexpr bool value = true;
        typedef bool value_type;
        typedef integral_constant<bool, true> type;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<bool, true>::value_type operator()() const noexcept;
    };
template<> struct integral_constant<bool, false> {
        static constexpr bool value = false;
        typedef bool value_type;
        typedef integral_constant<bool, false> type;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<bool, false>::value_type operator()() const noexcept;
    };
template<> struct integral_constant<unsigned long, 0> {
        static constexpr unsigned long value = 0UL;
        typedef unsigned long value_type;
        typedef integral_constant<unsigned long, 0UL> type;
        constexpr operator value_type() const noexcept;
        constexpr std::integral_constant<unsigned long, 0>::value_type operator()() const noexcept;
    };
    constexpr _Tp value;
    typedef integral_constant<bool, true> true_type;
    typedef integral_constant<bool, false> false_type;
    template <bool __v> using __bool_constant = integral_constant<bool, __v>;
    template <bool, typename, typename> struct conditional
template<> struct conditional<true, std::__is_nt_default_constructible_impl<std::allocator<char>, false>, std::is_default_constructible<std::allocator<char> >> {
        typedef std::__is_nt_default_constructible_impl<std::allocator<char>, false> type;
    }
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_istream<std::basic_istream<char> &>, std::__is_extractable<std::basic_istream<char> &, char &, void> >, std::__not_<std::is_lvalue_reference<std::basic_istream<char> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_istream<char> &> > type;
    }
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_istream<std::basic_istream<char> &>, std::__is_extractable<std::basic_istream<char> &, unsigned char &, void> >, std::__not_<std::is_lvalue_reference<std::basic_istream<char> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_istream<char> &> > type;
    }
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_istream<std::basic_istream<char> &>, std::__is_extractable<std::basic_istream<char> &, signed char &, void> >, std::__not_<std::is_lvalue_reference<std::basic_istream<char> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_istream<char> &> > type;
    }
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_istream<std::basic_istream<wchar_t> &>, std::__is_extractable<std::basic_istream<wchar_t> &, wchar_t &, void> >, std::__not_<std::is_lvalue_reference<std::basic_istream<wchar_t> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_istream<wchar_t> &> > type;
    }
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[13], void> >, std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> > type;
    }
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[11], void> >, std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> > type;
    }
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[12], void> >, std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> > type;
    }
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[16], void> >, std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> > type;
    }
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[18], void> >, std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> > type;
    }
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, const int &, void> >, std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> > type;
    }
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[3], void> >, std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> > type;
    }
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[8], void> >, std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> > type;
    }
template<> struct conditional<false, std::is_void<std::random_access_iterator_tag>, std::__or_<std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag> >> {
        typedef std::__or_<std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag> > type;
    }
template<> struct conditional<false, std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag>> {
        typedef std::is_array<std::input_iterator_tag> type;
    }
template<> struct conditional<false, std::__undefined, char> {
        typedef char type;
    }
template<> struct conditional<false, std::__undefined, const char> {
        typedef const char type;
    }
template<> struct conditional<false, std::__undefined, wchar_t> {
        typedef wchar_t type;
    }
template<> struct conditional<false, std::__undefined, const wchar_t> {
        typedef const wchar_t type;
    }
template<> struct conditional<false, std::__undefined, char16_t> {
        typedef char16_t type;
    }
template<> struct conditional<false, std::__undefined, const char16_t> {
        typedef const char16_t type;
    }
template<> struct conditional<false, std::__undefined, char32_t> {
        typedef char32_t type;
    }
template<> struct conditional<false, std::__undefined, const char32_t> {
        typedef const char32_t type;
    };
    template <typename ...> struct __or_
template<> struct __or_<<std::is_void<std::random_access_iterator_tag>, std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag>>> : public conditional<is_void<random_access_iterator_tag>::value, is_void<random_access_iterator_tag>, __or_<is_function<input_iterator_tag>, is_array<input_iterator_tag> > >::type {
    }
template<> struct __or_<<std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag>>> : public conditional<is_function<input_iterator_tag>::value, is_function<input_iterator_tag>, is_array<input_iterator_tag> >::type {
    };
    template<> struct __or_<> : public std::false_type {
    };
    template <typename _B1> struct __or_<_B1> : public _B1 {
    };
    template <typename _B1, typename _B2> struct __or_<_B1, _B2> : public conditional<_B1::value, _B1, _B2>::type {
    };
    template <typename _B1, typename _B2, typename _B3, typename ..._Bn> struct __or_<_B1, _B2, _B3, _Bn...> : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...> >::type {
    };
    template <typename ...> struct __and_
template<> struct __and_<<std::is_default_constructible<std::allocator<char> >, std::__is_nt_default_constructible_impl<std::allocator<char>, false>>> : public conditional<is_default_constructible<allocator<char> >::value, __is_nt_default_constructible_impl<allocator<char>, false>, is_default_constructible<allocator<char> > >::type {
    }
template<> struct __and_<<std::__not_<std::is_lvalue_reference<std::basic_istream<char> &> >, std::__is_convertible_to_basic_istream<std::basic_istream<char> &>, std::__is_extractable<std::basic_istream<char> &, char &, void>>> : public conditional<__not_<is_lvalue_reference<basic_istream<char> &> >::value, __and_<__is_convertible_to_basic_istream<basic_istream<char> &>, __is_extractable<basic_istream<char> &, char &, void> >, __not_<is_lvalue_reference<basic_istream<char> &> > >::type {
    }
template<> struct __and_<<std::__not_<std::is_lvalue_reference<std::basic_istream<char> &> >, std::__is_convertible_to_basic_istream<std::basic_istream<char> &>, std::__is_extractable<std::basic_istream<char> &, unsigned char &, void>>> : public conditional<__not_<is_lvalue_reference<basic_istream<char> &> >::value, __and_<__is_convertible_to_basic_istream<basic_istream<char> &>, __is_extractable<basic_istream<char> &, unsigned char &, void> >, __not_<is_lvalue_reference<basic_istream<char> &> > >::type {
    }
template<> struct __and_<<std::__not_<std::is_lvalue_reference<std::basic_istream<char> &> >, std::__is_convertible_to_basic_istream<std::basic_istream<char> &>, std::__is_extractable<std::basic_istream<char> &, signed char &, void>>> : public conditional<__not_<is_lvalue_reference<basic_istream<char> &> >::value, __and_<__is_convertible_to_basic_istream<basic_istream<char> &>, __is_extractable<basic_istream<char> &, signed char &, void> >, __not_<is_lvalue_reference<basic_istream<char> &> > >::type {
    }
template<> struct __and_<<std::__not_<std::is_lvalue_reference<std::basic_istream<wchar_t> &> >, std::__is_convertible_to_basic_istream<std::basic_istream<wchar_t> &>, std::__is_extractable<std::basic_istream<wchar_t> &, wchar_t &, void>>> : public conditional<__not_<is_lvalue_reference<basic_istream<wchar_t> &> >::value, __and_<__is_convertible_to_basic_istream<basic_istream<wchar_t> &>, __is_extractable<basic_istream<wchar_t> &, wchar_t &, void> >, __not_<is_lvalue_reference<basic_istream<wchar_t> &> > >::type {
    }
template<> struct __and_<<std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >, std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[13], void>>> : public conditional<__not_<is_lvalue_reference<basic_ostream<char> &> >::value, __and_<__is_convertible_to_basic_ostream<basic_ostream<char> &>, __is_insertable<basic_ostream<char> &, char const (&)[13], void> >, __not_<is_lvalue_reference<basic_ostream<char> &> > >::type {
    }
template<> struct __and_<<std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >, std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[11], void>>> : public conditional<__not_<is_lvalue_reference<basic_ostream<char> &> >::value, __and_<__is_convertible_to_basic_ostream<basic_ostream<char> &>, __is_insertable<basic_ostream<char> &, char const (&)[11], void> >, __not_<is_lvalue_reference<basic_ostream<char> &> > >::type {
    }
template<> struct __and_<<std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >, std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[12], void>>> : public conditional<__not_<is_lvalue_reference<basic_ostream<char> &> >::value, __and_<__is_convertible_to_basic_ostream<basic_ostream<char> &>, __is_insertable<basic_ostream<char> &, char const (&)[12], void> >, __not_<is_lvalue_reference<basic_ostream<char> &> > >::type {
    }
template<> struct __and_<<std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >, std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[16], void>>> : public conditional<__not_<is_lvalue_reference<basic_ostream<char> &> >::value, __and_<__is_convertible_to_basic_ostream<basic_ostream<char> &>, __is_insertable<basic_ostream<char> &, char const (&)[16], void> >, __not_<is_lvalue_reference<basic_ostream<char> &> > >::type {
    }
template<> struct __and_<<std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >, std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[18], void>>> : public conditional<__not_<is_lvalue_reference<basic_ostream<char> &> >::value, __and_<__is_convertible_to_basic_ostream<basic_ostream<char> &>, __is_insertable<basic_ostream<char> &, char const (&)[18], void> >, __not_<is_lvalue_reference<basic_ostream<char> &> > >::type {
    }
template<> struct __and_<<std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >, std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, const int &, void>>> : public conditional<__not_<is_lvalue_reference<basic_ostream<char> &> >::value, __and_<__is_convertible_to_basic_ostream<basic_ostream<char> &>, __is_insertable<basic_ostream<char> &, const int &, void> >, __not_<is_lvalue_reference<basic_ostream<char> &> > >::type {
    }
template<> struct __and_<<std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >, std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[3], void>>> : public conditional<__not_<is_lvalue_reference<basic_ostream<char> &> >::value, __and_<__is_convertible_to_basic_ostream<basic_ostream<char> &>, __is_insertable<basic_ostream<char> &, char const (&)[3], void> >, __not_<is_lvalue_reference<basic_ostream<char> &> > >::type {
    }
template<> struct __and_<<std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >, std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[8], void>>> : public conditional<__not_<is_lvalue_reference<basic_ostream<char> &> >::value, __and_<__is_convertible_to_basic_ostream<basic_ostream<char> &>, __is_insertable<basic_ostream<char> &, char const (&)[8], void> >, __not_<is_lvalue_reference<basic_ostream<char> &> > >::type {
    };
    template<> struct __and_<> : public std::true_type {
    };
    template <typename _B1> struct __and_<_B1> : public _B1 {
    };
    template <typename _B1, typename _B2> struct __and_<_B1, _B2> : public conditional<_B1::value, _B2, _B1>::type {
    };
    template <typename _B1, typename _B2, typename _B3, typename ..._Bn> struct __and_<_B1, _B2, _B3, _Bn...> : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type {
    };
    template <typename _Pp> struct __not_ : public __bool_constant<!bool(_Pp::value)> {
    };
template<> struct __not_<std::is_lvalue_reference<std::basic_istream<char> &>> : public __bool_constant<!bool(is_lvalue_reference<basic_istream<char> &>::value)> {
    };
template<> struct __not_<std::is_void<std::basic_istream<char> &>> : public __bool_constant<!bool(is_void<basic_istream<char> &>::value)> {
    };
template<> struct __not_<std::is_lvalue_reference<std::basic_istream<wchar_t> &>> : public __bool_constant<!bool(is_lvalue_reference<basic_istream<wchar_t> &>::value)> {
    };
template<> struct __not_<std::is_void<std::basic_istream<wchar_t> &>> : public __bool_constant<!bool(is_void<basic_istream<wchar_t> &>::value)> {
    };
template<> struct __not_<std::is_lvalue_reference<std::basic_ostream<char> &>> : public __bool_constant<!bool(is_lvalue_reference<basic_ostream<char> &>::value)> {
    };
template<> struct __not_<std::is_void<std::basic_ostream<char> &>> : public __bool_constant<!bool(is_void<basic_ostream<char> &>::value)> {
    };
    template <typename _Tp> struct __success_type {
        typedef _Tp type;
    };
    struct __failure_type {
    };
    template <typename> struct remove_cv
template<> struct remove_cv<wchar_t> {
        typedef typename remove_const<typename remove_volatile<wchar_t>::type>::type type;
    }
template<> struct remove_cv<unsigned int> {
        typedef typename remove_const<typename remove_volatile<unsigned int>::type>::type type;
    }
template<> struct remove_cv<char16_t> {
        typedef typename remove_const<typename remove_volatile<char16_t>::type>::type type;
    }
template<> struct remove_cv<unsigned short> {
        typedef typename remove_const<typename remove_volatile<unsigned short>::type>::type type;
    }
template<> struct remove_cv<char32_t> {
        typedef typename remove_const<typename remove_volatile<char32_t>::type>::type type;
    }
template<> struct remove_cv<void> {
        typedef typename remove_const<typename remove_volatile<void>::type>::type type;
    }
template<> struct remove_cv<std::basic_istream<char> &> {
        typedef typename remove_const<typename remove_volatile<basic_istream<char> &>::type>::type type;
    }
template<> struct remove_cv<std::basic_istream<wchar_t> &> {
        typedef typename remove_const<typename remove_volatile<basic_istream<wchar_t> &>::type>::type type;
    }
template<> struct remove_cv<std::basic_ostream<char> &> {
        typedef typename remove_const<typename remove_volatile<basic_ostream<char> &>::type>::type type;
    }
template<> struct remove_cv<double> {
        typedef typename remove_const<typename remove_volatile<double>::type>::type type;
    }
template<> struct remove_cv<int> {
        typedef typename remove_const<typename remove_volatile<int>::type>::type type;
    }
template<> struct remove_cv<float> {
        typedef typename remove_const<typename remove_volatile<float>::type>::type type;
    }
template<> struct remove_cv<std::random_access_iterator_tag> {
        typedef typename remove_const<typename remove_volatile<random_access_iterator_tag>::type>::type type;
    }
template<> struct remove_cv<char> {
        typedef typename remove_const<typename remove_volatile<char>::type>::type type;
    }
template<> struct remove_cv<const char> {
        typedef typename remove_const<typename remove_volatile<const char>::type>::type type;
    }
template<> struct remove_cv<const wchar_t> {
        typedef typename remove_const<typename remove_volatile<const wchar_t>::type>::type type;
    }
template<> struct remove_cv<const char16_t> {
        typedef typename remove_const<typename remove_volatile<const char16_t>::type>::type type;
    }
template<> struct remove_cv<const char32_t> {
        typedef typename remove_const<typename remove_volatile<const char32_t>::type>::type type;
    };
    template <typename> struct __is_void_helper : public std::false_type {
    };
template<> struct __is_void_helper<std::basic_istream<char> &> : public std::false_type {
    };
template<> struct __is_void_helper<std::basic_istream<wchar_t> &> : public std::false_type {
    };
template<> struct __is_void_helper<std::basic_ostream<char> &> : public std::false_type {
    };
template<> struct __is_void_helper<std::random_access_iterator_tag> : public std::false_type {
    };
template<> struct __is_void_helper<char> : public std::false_type {
    };
template<> struct __is_void_helper<wchar_t> : public std::false_type {
    };
template<> struct __is_void_helper<char16_t> : public std::false_type {
    };
template<> struct __is_void_helper<char32_t> : public std::false_type {
    };
    template<> struct __is_void_helper<void> : public std::true_type {
    };
    template <typename _Tp> struct is_void : public __is_void_helper<typename remove_cv<_Tp>::type>::type {
    };
template<> struct is_void<void> : public __is_void_helper<typename remove_cv<void>::type>::type {
    };
template<> struct is_void<std::basic_istream<char> &> : public __is_void_helper<typename remove_cv<basic_istream<char> &>::type>::type {
    };
template<> struct is_void<std::basic_istream<wchar_t> &> : public __is_void_helper<typename remove_cv<basic_istream<wchar_t> &>::type>::type {
    };
template<> struct is_void<std::basic_ostream<char> &> : public __is_void_helper<typename remove_cv<basic_ostream<char> &>::type>::type {
    };
template<> struct is_void<std::random_access_iterator_tag> : public __is_void_helper<typename remove_cv<random_access_iterator_tag>::type>::type {
    };
template<> struct is_void<char> : public __is_void_helper<typename remove_cv<char>::type>::type {
    };
template<> struct is_void<const char> : public __is_void_helper<typename remove_cv<const char>::type>::type {
    };
template<> struct is_void<wchar_t> : public __is_void_helper<typename remove_cv<wchar_t>::type>::type {
    };
template<> struct is_void<const wchar_t> : public __is_void_helper<typename remove_cv<const wchar_t>::type>::type {
    };
template<> struct is_void<char16_t> : public __is_void_helper<typename remove_cv<char16_t>::type>::type {
    };
template<> struct is_void<const char16_t> : public __is_void_helper<typename remove_cv<const char16_t>::type>::type {
    };
template<> struct is_void<char32_t> : public __is_void_helper<typename remove_cv<char32_t>::type>::type {
    };
template<> struct is_void<const char32_t> : public __is_void_helper<typename remove_cv<const char32_t>::type>::type {
    };
    template <typename> struct __is_integral_helper : public std::false_type {
    };
template<> struct __is_integral_helper<double> : public std::false_type {
    };
template<> struct __is_integral_helper<float> : public std::false_type {
    };
    template<> struct __is_integral_helper<bool> : public std::true_type {
    };
    template<> struct __is_integral_helper<char> : public std::true_type {
    };
    template<> struct __is_integral_helper<signed char> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned char> : public std::true_type {
    };
    template<> struct __is_integral_helper<wchar_t> : public std::true_type {
    };
    template<> struct __is_integral_helper<char16_t> : public std::true_type {
    };
    template<> struct __is_integral_helper<char32_t> : public std::true_type {
    };
    template<> struct __is_integral_helper<short> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned short> : public std::true_type {
    };
    template<> struct __is_integral_helper<int> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned int> : public std::true_type {
    };
    template<> struct __is_integral_helper<long> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned long> : public std::true_type {
    };
    template<> struct __is_integral_helper<long long> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned long long> : public std::true_type {
    };
    template<> struct __is_integral_helper<__int128> : public std::true_type {
    };
    template<> struct __is_integral_helper<unsigned __int128> : public std::true_type {
    };
    template <typename _Tp> struct is_integral : public __is_integral_helper<typename remove_cv<_Tp>::type>::type {
    };
template<> struct is_integral<wchar_t> : public __is_integral_helper<typename remove_cv<wchar_t>::type>::type {
    };
template<> struct is_integral<unsigned int> : public __is_integral_helper<typename remove_cv<unsigned int>::type>::type {
    };
template<> struct is_integral<char16_t> : public __is_integral_helper<typename remove_cv<char16_t>::type>::type {
    };
template<> struct is_integral<unsigned short> : public __is_integral_helper<typename remove_cv<unsigned short>::type>::type {
    };
template<> struct is_integral<char32_t> : public __is_integral_helper<typename remove_cv<char32_t>::type>::type {
    };
template<> struct is_integral<double> : public __is_integral_helper<typename remove_cv<double>::type>::type {
    };
template<> struct is_integral<int> : public __is_integral_helper<typename remove_cv<int>::type>::type {
    };
template<> struct is_integral<float> : public __is_integral_helper<typename remove_cv<float>::type>::type {
    };
    template <typename> struct __is_floating_point_helper : public std::false_type {
    };
template<> struct __is_floating_point_helper<int> : public std::false_type {
    };
    template<> struct __is_floating_point_helper<float> : public std::true_type {
    };
    template<> struct __is_floating_point_helper<double> : public std::true_type {
    };
    template<> struct __is_floating_point_helper<long double> : public std::true_type {
    };
    template<> struct __is_floating_point_helper<__float128> : public std::true_type {
    };
    template <typename _Tp> struct is_floating_point : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type {
    };
template<> struct is_floating_point<double> : public __is_floating_point_helper<typename remove_cv<double>::type>::type {
    };
template<> struct is_floating_point<int> : public __is_floating_point_helper<typename remove_cv<int>::type>::type {
    };
template<> struct is_floating_point<float> : public __is_floating_point_helper<typename remove_cv<float>::type>::type {
    };
    template <typename> struct is_array : public std::false_type {
    };
template<> struct is_array<std::allocator<char>> : public std::false_type {
    };
template<> struct is_array<std::input_iterator_tag> : public std::false_type {
    };
    template <typename _Tp, std::size_t _Size> struct is_array<_Tp [_Size]> : public std::true_type {
    };
    template <typename _Tp> struct is_array<_Tp []> : public std::true_type {
    };
    template <typename> struct __is_pointer_helper : public std::false_type {
    };
    template <typename _Tp> struct __is_pointer_helper<_Tp *> : public std::true_type {
    };
    template <typename _Tp> struct is_pointer : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type {
    };
    template <typename> struct is_lvalue_reference : public std::false_type {
    };
template<> struct is_lvalue_reference<std::basic_istream<char> &> : public std::true_type {
    };
template<> struct is_lvalue_reference<std::basic_istream<wchar_t> &> : public std::true_type {
    };
template<> struct is_lvalue_reference<std::basic_ostream<char> &> : public std::true_type {
    };
    template <typename _Tp> struct is_lvalue_reference<_Tp &> : public std::true_type {
    };
    template <typename> struct is_rvalue_reference : public std::false_type {
    };
    template <typename _Tp> struct is_rvalue_reference<_Tp &&> : public std::true_type {
    };
    template <typename> struct is_function
template<> struct is_function<std::input_iterator_tag> : public std::false_type {
    };
    template <typename> struct __is_member_object_pointer_helper : public std::false_type {
    };
    template <typename _Tp, typename _Cp> struct __is_member_object_pointer_helper<_Tp _Cp::*> : public __not_<is_function<_Tp> >::type {
    };
    template <typename _Tp> struct is_member_object_pointer : public __is_member_object_pointer_helper<typename remove_cv<_Tp>::type>::type {
    };
    template <typename> struct __is_member_function_pointer_helper : public std::false_type {
    };
    template <typename _Tp, typename _Cp> struct __is_member_function_pointer_helper<_Tp _Cp::*> : public is_function<_Tp>::type {
    };
    template <typename _Tp> struct is_member_function_pointer : public __is_member_function_pointer_helper<typename remove_cv<_Tp>::type>::type {
    };
    template <typename _Tp> struct is_enum : public integral_constant<bool, __is_enum(_Tp)> {
    };
template<> struct is_enum<wchar_t> : public integral_constant<bool, __is_enum(wchar_t)> {
    };
template<> struct is_enum<unsigned int> : public integral_constant<bool, __is_enum(unsigned int)> {
    };
template<> struct is_enum<char16_t> : public integral_constant<bool, __is_enum(char16_t)> {
    };
template<> struct is_enum<unsigned short> : public integral_constant<bool, __is_enum(unsigned short)> {
    };
template<> struct is_enum<char32_t> : public integral_constant<bool, __is_enum(char32_t)> {
    };
    template <typename _Tp> struct is_union : public integral_constant<bool, __is_union(_Tp)> {
    };
    template <typename _Tp> struct is_class : public integral_constant<bool, __is_class(_Tp)> {
    };
    template <typename> struct is_function : public std::false_type {
    };
template<> struct is_function<std::input_iterator_tag> : public std::false_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes...)> : public std::true_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes...) &> : public std::true_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes...) &&> : public std::true_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes..., ...)> : public std::true_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes..., ...) &> : public std::true_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes..., ...) &&> : public std::true_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes...) const> : public std::true_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes...) const &> : public std::true_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes...) const &&> : public std::true_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes..., ...) const> : public std::true_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes..., ...) const &> : public std::true_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes..., ...) const &&> : public std::true_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes...) volatile> : public std::true_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes...) volatile &> : public std::true_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes...) volatile &&> : public std::true_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes..., ...) volatile> : public std::true_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes..., ...) volatile &> : public std::true_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes..., ...) volatile &&> : public std::true_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes...) const volatile> : public std::true_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes...) const volatile &> : public std::true_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes...) const volatile &&> : public std::true_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes..., ...) const volatile> : public std::true_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes..., ...) const volatile &> : public std::true_type {
    };
    template <typename _Res, typename ..._ArgTypes> struct is_function<_Res (_ArgTypes..., ...) const volatile &&> : public std::true_type {
    };
    template <typename> struct __is_null_pointer_helper : public std::false_type {
    };
    template<> struct __is_null_pointer_helper<std::nullptr_t> : public std::true_type {
    };
    template <typename _Tp> struct is_null_pointer : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type {
    };
    template <typename _Tp> struct __is_nullptr_t : public is_null_pointer<_Tp> {
    };
    template <typename _Tp> struct is_reference : public __or_<is_lvalue_reference<_Tp>, is_rvalue_reference<_Tp> >::type {
    };
    template <typename _Tp> struct is_arithmetic : public __or_<is_integral<_Tp>, is_floating_point<_Tp> >::type {
    };
    template <typename _Tp> struct is_fundamental : public __or_<is_arithmetic<_Tp>, is_void<_Tp>, is_null_pointer<_Tp> >::type {
    };
    template <typename _Tp> struct is_object : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>, is_void<_Tp> > >::type {
    };
    template <typename> struct is_member_pointer;
    template <typename _Tp> struct is_scalar : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>, is_member_pointer<_Tp>, is_null_pointer<_Tp> >::type {
    };
    template <typename _Tp> struct is_compound : public __not_<is_fundamental<_Tp> >::type {
    };
    template <typename _Tp> struct __is_member_pointer_helper : public std::false_type {
    };
    template <typename _Tp, typename _Cp> struct __is_member_pointer_helper<_Tp _Cp::*> : public std::true_type {
    };
    template <typename _Tp> struct is_member_pointer : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type {
    };
    template <typename _Tp> struct __is_referenceable : public __or_<is_object<_Tp>, is_reference<_Tp> >::type {
    };
    template <typename _Res, typename ..._Args> struct __is_referenceable<_Res (_Args...)> : public std::true_type {
    };
    template <typename _Res, typename ..._Args> struct __is_referenceable<_Res (_Args..., ...)> : public std::true_type {
    };
    template <typename> struct is_const : public std::false_type {
    };
template<> struct is_const<wchar_t> : public std::false_type {
    };
template<> struct is_const<char16_t> : public std::false_type {
    };
template<> struct is_const<char32_t> : public std::false_type {
    };
template<> struct is_const<unsigned int> : public std::false_type {
    };
template<> struct is_const<unsigned short> : public std::false_type {
    };
    template <typename _Tp> struct is_const<const _Tp> : public std::true_type {
    };
    template <typename> struct is_volatile : public std::false_type {
    };
template<> struct is_volatile<wchar_t> : public std::false_type {
    };
template<> struct is_volatile<char16_t> : public std::false_type {
    };
template<> struct is_volatile<char32_t> : public std::false_type {
    };
template<> struct is_volatile<unsigned int> : public std::false_type {
    };
template<> struct is_volatile<unsigned short> : public std::false_type {
    };
    template <typename _Tp> struct is_volatile<volatile _Tp> : public std::true_type {
    };
    template <typename _Tp> struct is_trivial : public integral_constant<bool, __is_trivial(_Tp)> {
    };
    template <typename _Tp> struct is_trivially_copyable : public integral_constant<bool, __is_trivially_copyable(_Tp)> {
    };
    template <typename _Tp> struct is_standard_layout : public integral_constant<bool, __is_standard_layout(_Tp)> {
    };
    template <typename _Tp> struct is_pod : public integral_constant<bool, __is_pod(_Tp)> {
    };
    template <typename _Tp> struct is_literal_type : public integral_constant<bool, __is_literal(_Tp)> {
    };
    template <typename _Tp> struct is_empty : public integral_constant<bool, __is_empty(_Tp)> {
    };
    template <typename _Tp> struct is_polymorphic : public integral_constant<bool, __is_polymorphic(_Tp)> {
    };
    template <typename _Tp> struct is_final : public integral_constant<bool, __is_final(_Tp)> {
    };
    template <typename _Tp> struct is_abstract : public integral_constant<bool, __is_abstract(_Tp)> {
    };
    template <typename _Tp, bool = is_arithmetic<_Tp>::value> struct __is_signed_helper : public std::false_type {
    };
    template <typename _Tp> struct __is_signed_helper<_Tp, true> : public integral_constant<bool, _Tp(-1) < _Tp(0)> {
    };
    template <typename _Tp> struct is_signed : public __is_signed_helper<_Tp>::type {
    };
    template <typename _Tp> struct is_unsigned : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp> > > {
    };
    template <typename _Tp, typename _Up = _Tp &&> _Up __declval(int);
    template<> std::basic_istream<char> *&&__declval<std::basic_istream<char> *, std::basic_istream<char> *&&>(int);
    template<> std::basic_istream<wchar_t> *&&__declval<std::basic_istream<wchar_t> *, std::basic_istream<wchar_t> *&&>(int);
    template<> std::basic_ostream<char> *&&__declval<std::basic_ostream<char> *, std::basic_ostream<char> *&&>(int);
    template<> std::random_access_iterator_tag &&__declval<std::random_access_iterator_tag, std::random_access_iterator_tag &&>(int);
    template <typename _Tp> _Tp __declval(long);
    template<> std::basic_istream<char> *__declval<std::basic_istream<char> *>(long);
    template<> std::basic_istream<wchar_t> *__declval<std::basic_istream<wchar_t> *>(long);
    template<> std::basic_ostream<char> *__declval<std::basic_ostream<char> *>(long);
    template<> std::random_access_iterator_tag __declval<std::random_access_iterator_tag>(long);
    template <typename _Tp> auto declval() noexcept -> decltype(__declval<_Tp>(0));
    template <typename, unsigned int = 0> struct extent;
    template <typename> struct remove_all_extents;
    template <typename _Tp> struct __is_array_known_bounds : public integral_constant<bool, (extent<_Tp>::value > 0)> {
    };
    template <typename _Tp> struct __is_array_unknown_bounds : public __and_<is_array<_Tp>, __not_<extent<_Tp> > > {
    };
    struct __do_is_destructible_impl {
        template <typename _Tp, typename = decltype(declval<_Tp &>().~_Tp())> static std::true_type __test(int);
        template <typename> static std::false_type __test(...);
    };
    template <typename _Tp> struct __is_destructible_impl : public std::__do_is_destructible_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp, bool = __or_<is_void<_Tp>, __is_array_unknown_bounds<_Tp>, is_function<_Tp> >::value, bool = __or_<is_reference<_Tp>, is_scalar<_Tp> >::value> struct __is_destructible_safe;
    template <typename _Tp> struct __is_destructible_safe<_Tp, false, false> : public __is_destructible_impl<typename remove_all_extents<_Tp>::type>::type {
    };
    template <typename _Tp> struct __is_destructible_safe<_Tp, true, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_destructible_safe<_Tp, false, true> : public std::true_type {
    };
    template <typename _Tp> struct is_destructible : public __is_destructible_safe<_Tp>::type {
    };
    struct __do_is_nt_destructible_impl {
        template <typename _Tp> static __bool_constant<noexcept(declval<_Tp &>().~_Tp())> __test(int);
        template <typename> static std::false_type __test(...);
    };
    template <typename _Tp> struct __is_nt_destructible_impl : public std::__do_is_nt_destructible_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp, bool = __or_<is_void<_Tp>, __is_array_unknown_bounds<_Tp>, is_function<_Tp> >::value, bool = __or_<is_reference<_Tp>, is_scalar<_Tp> >::value> struct __is_nt_destructible_safe;
    template <typename _Tp> struct __is_nt_destructible_safe<_Tp, false, false> : public __is_nt_destructible_impl<typename remove_all_extents<_Tp>::type>::type {
    };
    template <typename _Tp> struct __is_nt_destructible_safe<_Tp, true, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nt_destructible_safe<_Tp, false, true> : public std::true_type {
    };
    template <typename _Tp> struct is_nothrow_destructible : public __is_nt_destructible_safe<_Tp>::type {
    };
    template <typename _Tp, typename ..._Args> struct is_constructible : public __bool_constant<__is_constructible(_Tp, _Args...)> {
    };
template<> struct is_constructible<std::allocator<char>, <>> : public __bool_constant<__is_constructible(std::allocator<char>)> {
    };
    template <typename _Tp> struct is_default_constructible : public is_constructible<_Tp>::type {
    };
template<> struct is_default_constructible<std::allocator<char>> : public is_constructible<allocator<char> >::type {
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_copy_constructible_impl;
    template <typename _Tp> struct __is_copy_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_copy_constructible_impl<_Tp, true> : public is_constructible<_Tp, const _Tp &> {
    };
    template <typename _Tp> struct is_copy_constructible : public __is_copy_constructible_impl<_Tp> {
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_move_constructible_impl;
    template <typename _Tp> struct __is_move_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_move_constructible_impl<_Tp, true> : public is_constructible<_Tp, _Tp &&> {
    };
    template <typename _Tp> struct is_move_constructible : public __is_move_constructible_impl<_Tp> {
    };
    template <typename _Tp> struct __is_nt_default_constructible_atom : public integral_constant<bool, noexcept(_Tp())> {
    };
template<> struct __is_nt_default_constructible_atom<std::allocator<char>> : public integral_constant<bool, noexcept(std::allocator<char>())> {
    };
    template <typename _Tp, bool = is_array<_Tp>::value> struct __is_nt_default_constructible_impl
template<> struct __is_nt_default_constructible_impl<std::allocator<char>, false> : public __is_nt_default_constructible_atom<std::allocator<char> > {
    };
    template <typename _Tp> struct __is_nt_default_constructible_impl<_Tp, true> : public __and_<__is_array_known_bounds<_Tp>, __is_nt_default_constructible_atom<typename remove_all_extents<_Tp>::type> > {
    };
    template <typename _Tp> struct __is_nt_default_constructible_impl<_Tp, false> : public __is_nt_default_constructible_atom<_Tp> {
    };
    template <typename _Tp> struct is_nothrow_default_constructible : public __and_<is_default_constructible<_Tp>, __is_nt_default_constructible_impl<_Tp> > {
    };
template<> struct is_nothrow_default_constructible<std::allocator<char>> : public __and_<is_default_constructible<std::allocator<char> >, __is_nt_default_constructible_impl<std::allocator<char> > > {
    };
    template <typename _Tp, typename ..._Args> struct __is_nt_constructible_impl : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))> {
    };
    template <typename _Tp, typename _Arg> struct __is_nt_constructible_impl<_Tp, _Arg> : public integral_constant<bool, noexcept(static_cast<_Tp>(declval<_Arg>()))> {
    };
    template <typename _Tp> struct __is_nt_constructible_impl<_Tp> : public is_nothrow_default_constructible<_Tp> {
    };
    template <typename _Tp, typename ..._Args> struct is_nothrow_constructible : public __and_<is_constructible<_Tp, _Args...>, __is_nt_constructible_impl<_Tp, _Args...> > {
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_nothrow_copy_constructible_impl;
    template <typename _Tp> struct __is_nothrow_copy_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nothrow_copy_constructible_impl<_Tp, true> : public is_nothrow_constructible<_Tp, const _Tp &> {
    };
    template <typename _Tp> struct is_nothrow_copy_constructible : public __is_nothrow_copy_constructible_impl<_Tp> {
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_nothrow_move_constructible_impl;
    template <typename _Tp> struct __is_nothrow_move_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nothrow_move_constructible_impl<_Tp, true> : public is_nothrow_constructible<_Tp, _Tp &&> {
    };
    template <typename _Tp> struct is_nothrow_move_constructible : public __is_nothrow_move_constructible_impl<_Tp> {
    };
    template <typename _Tp, typename _Up> struct is_assignable : public __bool_constant<__is_assignable(_Tp, _Up)> {
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_copy_assignable_impl;
    template <typename _Tp> struct __is_copy_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_copy_assignable_impl<_Tp, true> : public is_assignable<_Tp &, const _Tp &> {
    };
    template <typename _Tp> struct is_copy_assignable : public __is_copy_assignable_impl<_Tp> {
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_move_assignable_impl;
    template <typename _Tp> struct __is_move_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_move_assignable_impl<_Tp, true> : public is_assignable<_Tp &, _Tp &&> {
    };
    template <typename _Tp> struct is_move_assignable : public __is_move_assignable_impl<_Tp> {
    };
    template <typename _Tp, typename _Up> struct __is_nt_assignable_impl : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())> {
    };
    template <typename _Tp, typename _Up> struct is_nothrow_assignable : public __and_<is_assignable<_Tp, _Up>, __is_nt_assignable_impl<_Tp, _Up> > {
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_nt_copy_assignable_impl;
    template <typename _Tp> struct __is_nt_copy_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nt_copy_assignable_impl<_Tp, true> : public is_nothrow_assignable<_Tp &, const _Tp &> {
    };
    template <typename _Tp> struct is_nothrow_copy_assignable : public __is_nt_copy_assignable_impl<_Tp> {
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_nt_move_assignable_impl;
    template <typename _Tp> struct __is_nt_move_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_nt_move_assignable_impl<_Tp, true> : public is_nothrow_assignable<_Tp &, _Tp &&> {
    };
    template <typename _Tp> struct is_nothrow_move_assignable : public __is_nt_move_assignable_impl<_Tp> {
    };
    template <typename _Tp, typename ..._Args> struct is_trivially_constructible : public __bool_constant<__is_trivially_constructible(_Tp, _Args...)> {
    };
    template <typename _Tp> struct is_trivially_default_constructible : public is_trivially_constructible<_Tp>::type {
    };
    struct __do_is_implicitly_default_constructible_impl {
        template <typename _Tp> static void __helper(const _Tp &);
        template <typename _Tp> static std::true_type __test(const _Tp &, decltype(__helper<const _Tp &>({})) * = 0);
        static std::false_type __test(...);
    };
    template <typename _Tp> struct __is_implicitly_default_constructible_impl : public std::__do_is_implicitly_default_constructible_impl {
        typedef decltype(__test(declval<_Tp>())) type;
    };
    template <typename _Tp> struct __is_implicitly_default_constructible_safe : public __is_implicitly_default_constructible_impl<_Tp>::type {
    };
    template <typename _Tp> struct __is_implicitly_default_constructible : public __and_<is_default_constructible<_Tp>, __is_implicitly_default_constructible_safe<_Tp> > {
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_trivially_copy_constructible_impl;
    template <typename _Tp> struct __is_trivially_copy_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_trivially_copy_constructible_impl<_Tp, true> : public __and_<is_copy_constructible<_Tp>, integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp &)> > {
    };
    template <typename _Tp> struct is_trivially_copy_constructible : public __is_trivially_copy_constructible_impl<_Tp> {
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_trivially_move_constructible_impl;
    template <typename _Tp> struct __is_trivially_move_constructible_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_trivially_move_constructible_impl<_Tp, true> : public __and_<is_move_constructible<_Tp>, integral_constant<bool, __is_trivially_constructible(_Tp, _Tp &&)> > {
    };
    template <typename _Tp> struct is_trivially_move_constructible : public __is_trivially_move_constructible_impl<_Tp> {
    };
    template <typename _Tp, typename _Up> struct is_trivially_assignable : public __bool_constant<__is_trivially_assignable(_Tp, _Up)> {
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_trivially_copy_assignable_impl;
    template <typename _Tp> struct __is_trivially_copy_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_trivially_copy_assignable_impl<_Tp, true> : public __bool_constant<__is_trivially_assignable(_Tp &, const _Tp &)> {
    };
    template <typename _Tp> struct is_trivially_copy_assignable : public __is_trivially_copy_assignable_impl<_Tp> {
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __is_trivially_move_assignable_impl;
    template <typename _Tp> struct __is_trivially_move_assignable_impl<_Tp, false> : public std::false_type {
    };
    template <typename _Tp> struct __is_trivially_move_assignable_impl<_Tp, true> : public __bool_constant<__is_trivially_assignable(_Tp &, _Tp &&)> {
    };
    template <typename _Tp> struct is_trivially_move_assignable : public __is_trivially_move_assignable_impl<_Tp> {
    };
    template <typename _Tp> struct is_trivially_destructible : public __and_<is_destructible<_Tp>, __bool_constant<__has_trivial_destructor(_Tp)> > {
    };
    template <typename _Tp> struct has_virtual_destructor : public integral_constant<bool, __has_virtual_destructor(_Tp)> {
    };
    template <typename _Tp> struct alignment_of : public integral_constant<std::size_t, alignof(_Tp)> {
    };
    template <typename> struct rank : public integral_constant<std::size_t, 0> {
    };
    template <typename _Tp, std::size_t _Size> struct rank<_Tp [_Size]> : public integral_constant<std::size_t, 1 + rank<_Tp>::value> {
    };
    template <typename _Tp> struct rank<_Tp []> : public integral_constant<std::size_t, 1 + rank<_Tp>::value> {
    };
    template <typename, unsigned int _Uint = 0> struct extent : public integral_constant<std::size_t, 0> {
    };
    template <typename _Tp, unsigned int _Uint, std::size_t _Size> struct extent<_Tp [_Size], _Uint> : public integral_constant<std::size_t, _Uint == 0 ? _Size : extent<_Tp, _Uint - 1>::value> {
    };
    template <typename _Tp, unsigned int _Uint> struct extent<_Tp [], _Uint> : public integral_constant<std::size_t, _Uint == 0 ? 0 : extent<_Tp, _Uint - 1>::value> {
    };
    template <typename, typename> struct is_same : public std::false_type {
    };
template<> struct is_same<int, int> : public std::true_type {
    };
template<> struct is_same<long, int> : public std::false_type {
    };
template<> struct is_same<unsigned long, int> : public std::false_type {
    };
template<> struct is_same<long long, int> : public std::false_type {
    };
template<> struct is_same<unsigned long long, int> : public std::false_type {
    };
template<> struct is_same<float, int> : public std::false_type {
    };
template<> struct is_same<double, int> : public std::false_type {
    };
template<> struct is_same<long double, int> : public std::false_type {
    };
    template <typename _Tp> struct is_same<_Tp, _Tp> : public std::true_type {
    };
    template <typename _Base, typename _Derived> struct is_base_of : public integral_constant<bool, __is_base_of(_Base, _Derived)> {
    };
    template <typename _From, typename _To, bool = __or_<is_void<_From>, is_function<_To>, is_array<_To> >::value> struct __is_convertible_helper {
        typedef typename is_void<_To>::type type;
    };
template<> class __is_convertible_helper<std::random_access_iterator_tag, std::input_iterator_tag, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template<> static void __test_aux<std::input_iterator_tag>(std::input_iterator_tag) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template<> static std::true_type __test<std::random_access_iterator_tag, std::input_iterator_tag, void>(int);
        template <typename, typename> static std::false_type __test(...);
        template<> static std::false_type __test<std::random_access_iterator_tag, std::input_iterator_tag>(...);
    public:
        typedef decltype(__test<std::random_access_iterator_tag, std::input_iterator_tag>(0)) type;
    };
    template <typename _From, typename _To> class __is_convertible_helper<_From, _To, false> {
        template <typename _To1> static void __test_aux(_To1) noexcept;
        template <typename _From1, typename _To1, typename = decltype(__test_aux<_To1>(std::declval<_From1>()))> static std::true_type __test(int);
        template <typename, typename> static std::false_type __test(...);
    public:
        typedef decltype(__test<_From, _To>(0)) type;
    };
    template <typename _From, typename _To> struct is_convertible : public __is_convertible_helper<_From, _To>::type {
    };
template<> struct is_convertible<std::random_access_iterator_tag, std::input_iterator_tag> : public __is_convertible_helper<random_access_iterator_tag, input_iterator_tag>::type {
    };
    template <typename _Tp> struct remove_const {
        typedef _Tp type;
    };
template<> struct remove_const<wchar_t> {
        typedef wchar_t type;
    };
template<> struct remove_const<unsigned int> {
        typedef unsigned int type;
    };
template<> struct remove_const<char16_t> {
        typedef char16_t type;
    };
template<> struct remove_const<unsigned short> {
        typedef unsigned short type;
    };
template<> struct remove_const<char32_t> {
        typedef char32_t type;
    };
template<> struct remove_const<void> {
        typedef void type;
    };
template<> struct remove_const<std::basic_istream<char> &> {
        typedef std::basic_istream<char> &type;
    };
template<> struct remove_const<std::basic_istream<wchar_t> &> {
        typedef std::basic_istream<wchar_t> &type;
    };
template<> struct remove_const<std::basic_ostream<char> &> {
        typedef std::basic_ostream<char> &type;
    };
template<> struct remove_const<double> {
        typedef double type;
    };
template<> struct remove_const<int> {
        typedef int type;
    };
template<> struct remove_const<float> {
        typedef float type;
    };
template<> struct remove_const<std::random_access_iterator_tag> {
        typedef std::random_access_iterator_tag type;
    };
template<> struct remove_const<char> {
        typedef char type;
    };
template<> struct remove_const<const char> {
        typedef char type;
    };
template<> struct remove_const<const wchar_t> {
        typedef wchar_t type;
    };
template<> struct remove_const<const char16_t> {
        typedef char16_t type;
    };
template<> struct remove_const<const char32_t> {
        typedef char32_t type;
    };
    template <typename _Tp> struct remove_const<const _Tp> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_volatile {
        typedef _Tp type;
    };
template<> struct remove_volatile<wchar_t> {
        typedef wchar_t type;
    };
template<> struct remove_volatile<unsigned int> {
        typedef unsigned int type;
    };
template<> struct remove_volatile<char16_t> {
        typedef char16_t type;
    };
template<> struct remove_volatile<unsigned short> {
        typedef unsigned short type;
    };
template<> struct remove_volatile<char32_t> {
        typedef char32_t type;
    };
template<> struct remove_volatile<void> {
        typedef void type;
    };
template<> struct remove_volatile<std::basic_istream<char> &> {
        typedef std::basic_istream<char> &type;
    };
template<> struct remove_volatile<std::basic_istream<wchar_t> &> {
        typedef std::basic_istream<wchar_t> &type;
    };
template<> struct remove_volatile<std::basic_ostream<char> &> {
        typedef std::basic_ostream<char> &type;
    };
template<> struct remove_volatile<double> {
        typedef double type;
    };
template<> struct remove_volatile<int> {
        typedef int type;
    };
template<> struct remove_volatile<float> {
        typedef float type;
    };
template<> struct remove_volatile<std::random_access_iterator_tag> {
        typedef std::random_access_iterator_tag type;
    };
template<> struct remove_volatile<char> {
        typedef char type;
    };
template<> struct remove_volatile<const char> {
        typedef const char type;
    };
template<> struct remove_volatile<const wchar_t> {
        typedef const wchar_t type;
    };
template<> struct remove_volatile<const char16_t> {
        typedef const char16_t type;
    };
template<> struct remove_volatile<const char32_t> {
        typedef const char32_t type;
    };
    template <typename _Tp> struct remove_volatile<volatile _Tp> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_cv {
        typedef typename remove_const<typename remove_volatile<_Tp>::type>::type type;
    };
template<> struct remove_cv<wchar_t> {
        typedef typename remove_const<typename remove_volatile<wchar_t>::type>::type type;
    };
template<> struct remove_cv<unsigned int> {
        typedef typename remove_const<typename remove_volatile<unsigned int>::type>::type type;
    };
template<> struct remove_cv<char16_t> {
        typedef typename remove_const<typename remove_volatile<char16_t>::type>::type type;
    };
template<> struct remove_cv<unsigned short> {
        typedef typename remove_const<typename remove_volatile<unsigned short>::type>::type type;
    };
template<> struct remove_cv<char32_t> {
        typedef typename remove_const<typename remove_volatile<char32_t>::type>::type type;
    };
template<> struct remove_cv<void> {
        typedef typename remove_const<typename remove_volatile<void>::type>::type type;
    };
template<> struct remove_cv<std::basic_istream<char> &> {
        typedef typename remove_const<typename remove_volatile<basic_istream<char> &>::type>::type type;
    };
template<> struct remove_cv<std::basic_istream<wchar_t> &> {
        typedef typename remove_const<typename remove_volatile<basic_istream<wchar_t> &>::type>::type type;
    };
template<> struct remove_cv<std::basic_ostream<char> &> {
        typedef typename remove_const<typename remove_volatile<basic_ostream<char> &>::type>::type type;
    };
template<> struct remove_cv<double> {
        typedef typename remove_const<typename remove_volatile<double>::type>::type type;
    };
template<> struct remove_cv<int> {
        typedef typename remove_const<typename remove_volatile<int>::type>::type type;
    };
template<> struct remove_cv<float> {
        typedef typename remove_const<typename remove_volatile<float>::type>::type type;
    };
template<> struct remove_cv<std::random_access_iterator_tag> {
        typedef typename remove_const<typename remove_volatile<random_access_iterator_tag>::type>::type type;
    };
template<> struct remove_cv<char> {
        typedef typename remove_const<typename remove_volatile<char>::type>::type type;
    };
template<> struct remove_cv<const char> {
        typedef typename remove_const<typename remove_volatile<const char>::type>::type type;
    };
template<> struct remove_cv<const wchar_t> {
        typedef typename remove_const<typename remove_volatile<const wchar_t>::type>::type type;
    };
template<> struct remove_cv<const char16_t> {
        typedef typename remove_const<typename remove_volatile<const char16_t>::type>::type type;
    };
template<> struct remove_cv<const char32_t> {
        typedef typename remove_const<typename remove_volatile<const char32_t>::type>::type type;
    };
    template <typename _Tp> struct add_const {
        typedef const _Tp type;
    };
    template <typename _Tp> struct add_volatile {
        typedef volatile _Tp type;
    };
    template <typename _Tp> struct add_cv {
        typedef typename add_const<typename add_volatile<_Tp>::type>::type type;
    };
    template <typename _Tp> using remove_const_t = typename remove_const<_Tp>::type;
    template <typename _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;
    template <typename _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;
    template <typename _Tp> using add_const_t = typename add_const<_Tp>::type;
    template <typename _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;
    template <typename _Tp> using add_cv_t = typename add_cv<_Tp>::type;
    template <typename _Tp> struct remove_reference {
        typedef _Tp type;
    };
template<> struct remove_reference<std::basic_istream<char> &> {
        typedef std::basic_istream<char> type;
    };
template<> struct remove_reference<std::basic_istream<wchar_t> &> {
        typedef std::basic_istream<wchar_t> type;
    };
template<> struct remove_reference<std::basic_ostream<char> &> {
        typedef std::basic_ostream<char> type;
    };
template<> struct remove_reference<std::allocator<char> &> {
        typedef std::allocator<char> type;
    };
template<> struct remove_reference<std::allocator<wchar_t> &> {
        typedef std::allocator<wchar_t> type;
    };
template<> struct remove_reference<std::allocator<char16_t> &> {
        typedef std::allocator<char16_t> type;
    };
template<> struct remove_reference<std::allocator<char32_t> &> {
        typedef std::allocator<char32_t> type;
    };
template<> struct remove_reference<std::__cxx11::basic_string<char> &> {
        typedef std::__cxx11::basic_string<char> type;
    };
    template <typename _Tp> struct remove_reference<_Tp &> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_reference<_Tp &&> {
        typedef _Tp type;
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __add_lvalue_reference_helper {
        typedef _Tp type;
    };
    template <typename _Tp> struct __add_lvalue_reference_helper<_Tp, true> {
        typedef _Tp &type;
    };
    template <typename _Tp> struct add_lvalue_reference : public __add_lvalue_reference_helper<_Tp> {
    };
    template <typename _Tp, bool = __is_referenceable<_Tp>::value> struct __add_rvalue_reference_helper {
        typedef _Tp type;
    };
    template <typename _Tp> struct __add_rvalue_reference_helper<_Tp, true> {
        typedef _Tp &&type;
    };
    template <typename _Tp> struct add_rvalue_reference : public __add_rvalue_reference_helper<_Tp> {
    };
    template <typename _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;
    template <typename _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;
    template <typename _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;
    template <typename _Unqualified, bool _IsConst, bool _IsVol> struct __cv_selector
template<> struct __cv_selector<unsigned int, false, false> {
        typedef unsigned int __type;
    }
template<> struct __cv_selector<unsigned short, false, false> {
        typedef unsigned short __type;
    }
template<> struct __cv_selector<int, false, false> {
        typedef int __type;
    }
template<> struct __cv_selector<short, false, false> {
        typedef short __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, false, false> {
        typedef _Unqualified __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, false, true> {
        typedef volatile _Unqualified __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, true, false> {
        typedef const _Unqualified __type;
    };
    template <typename _Unqualified> struct __cv_selector<_Unqualified, true, true> {
        typedef const volatile _Unqualified __type;
    };
    template <typename _Qualified, typename _Unqualified, bool _IsConst = is_const<_Qualified>::value, bool _IsVol = is_volatile<_Qualified>::value> class __match_cv_qualifiers {
        typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<wchar_t, unsigned int, false, false> {
        typedef __cv_selector<unsigned int, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<char16_t, unsigned short, false, false> {
        typedef __cv_selector<unsigned short, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<char32_t, unsigned int, false, false> {
        typedef __cv_selector<unsigned int, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<unsigned int, int, false, false> {
        typedef __cv_selector<int, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
template<> class __match_cv_qualifiers<unsigned short, short, false, false> {
        typedef __cv_selector<short, false, false> __match;
    public:
        typedef typename __match::__type __type;
    };
    template <typename _Tp> struct __make_unsigned {
        typedef _Tp __type;
    };
    template<> struct __make_unsigned<char> {
        typedef unsigned char __type;
    };
    template<> struct __make_unsigned<signed char> {
        typedef unsigned char __type;
    };
    template<> struct __make_unsigned<short> {
        typedef unsigned short __type;
    };
    template<> struct __make_unsigned<int> {
        typedef unsigned int __type;
    };
    template<> struct __make_unsigned<long> {
        typedef unsigned long __type;
    };
    template<> struct __make_unsigned<long long> {
        typedef unsigned long long __type;
    };
    template<> struct __make_unsigned<__int128> {
        typedef unsigned __int128 __type;
    };
    template <typename _Tp, bool _IsInt = is_integral<_Tp>::value, bool _IsEnum = is_enum<_Tp>::value> class __make_unsigned_selector
template<> class __make_unsigned_selector<wchar_t, false, true> : std::__make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(wchar_t), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<wchar_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<char16_t, false, true> : std::__make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(char16_t), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char16_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<char32_t, false, true> : std::__make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(char32_t), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char32_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<wchar_t, true, false> {
        using __unsigned_type = typename __make_unsigned<typename remove_cv<wchar_t>::type>::__type;
    public:
        using __type = typename __match_cv_qualifiers<wchar_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<char16_t, true, false> {
        using __unsigned_type = typename __make_unsigned<typename remove_cv<char16_t>::type>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char16_t, __unsigned_type>::__type;
    }
template<> class __make_unsigned_selector<char32_t, true, false> {
        using __unsigned_type = typename __make_unsigned<typename remove_cv<char32_t>::type>::__type;
    public:
        using __type = typename __match_cv_qualifiers<char32_t, __unsigned_type>::__type;
    };
    template <typename _Tp> class __make_unsigned_selector<_Tp, true, false> {
        using __unsigned_type = typename __make_unsigned<typename remove_cv<_Tp>::type>::__type;
    public:
        using __type = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };
    class __make_unsigned_selector_base {
    protected:
        template <typename ...> struct _List {
        };
template<> struct _List<<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>> : _List<unsigned short, unsigned int, unsigned long, unsigned long long> {
            static constexpr std::size_t __size = sizeof(unsigned char);
        };
template<> struct _List<<unsigned short, unsigned int, unsigned long, unsigned long long>> : _List<unsigned int, unsigned long, unsigned long long> {
            static constexpr std::size_t __size = sizeof(unsigned short);
        };
template<> struct _List<<unsigned int, unsigned long, unsigned long long>> : _List<unsigned long, unsigned long long> {
            static constexpr std::size_t __size = sizeof(unsigned int);
        };
template<> struct _List<<unsigned long, unsigned long long>> : _List<unsigned long long> {
            static constexpr std::size_t __size = sizeof(unsigned long);
        };
template<> struct _List<<unsigned long long>> : _List<> {
            static constexpr std::size_t __size = sizeof(unsigned long long);
        };
template<> struct _List<<>> {
        };
        template <typename _Tp, typename ..._Up> struct _List<_Tp, _Up...> : _List<_Up...> {
            static constexpr std::size_t __size = sizeof(_Tp);
        };
        template <std::size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)> struct __select
template<> struct __select<4, std::__make_unsigned_selector_base::_List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false> : __select<4UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long> > {
        }
template<> struct __select<4, std::__make_unsigned_selector_base::_List<unsigned short, unsigned int, unsigned long, unsigned long long>, false> : __select<4UL, _List<unsigned int, unsigned long, unsigned long long> > {
        }
template<> struct __select<4, std::__make_unsigned_selector_base::_List<unsigned int, unsigned long, unsigned long long>, true> {
            using __type = unsigned int;
        }
template<> struct __select<2, std::__make_unsigned_selector_base::_List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>, false> : __select<2UL, _List<unsigned short, unsigned int, unsigned long, unsigned long long> > {
        }
template<> struct __select<2, std::__make_unsigned_selector_base::_List<unsigned short, unsigned int, unsigned long, unsigned long long>, true> {
            using __type = unsigned short;
        };
        template <std::size_t _Sz, typename _Uint, typename ..._UInts> struct __select<_Sz, _List<_Uint, _UInts...>, true> {
            using __type = _Uint;
        };
        template <std::size_t _Sz, typename _Uint, typename ..._UInts> struct __select<_Sz, _List<_Uint, _UInts...>, false> : __select<_Sz, _List<_UInts...> > {
        };
    };
    template <typename _Tp> class __make_unsigned_selector<_Tp, false, true> : std::__make_unsigned_selector_base {
        using _UInts = _List<unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;
        using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;
    public:
        using __type = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };
    template<> struct __make_unsigned<wchar_t> {
        using __type = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };
    constexpr bool value;
    template<> struct __make_unsigned<char16_t> {
        using __type = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };
    template<> struct __make_unsigned<char32_t> {
        using __type = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };
    template <typename _Tp> struct make_unsigned {
        typedef typename __make_unsigned_selector<_Tp>::__type type;
    };
    template<> struct make_unsigned<bool>;
    template <typename _Tp> struct __make_signed {
        typedef _Tp __type;
    };
    template<> struct __make_signed<char> {
        typedef signed char __type;
    };
    template<> struct __make_signed<unsigned char> {
        typedef signed char __type;
    };
    template<> struct __make_signed<unsigned short> {
        typedef short __type;
    };
    template<> struct __make_signed<unsigned int> {
        typedef int __type;
    };
    template<> struct __make_signed<unsigned long> {
        typedef long __type;
    };
    template<> struct __make_signed<unsigned long long> {
        typedef long long __type;
    };
    template<> struct __make_signed<unsigned __int128> {
        typedef __int128 __type;
    };
    template <typename _Tp, bool _IsInt = is_integral<_Tp>::value, bool _IsEnum = is_enum<_Tp>::value> class __make_signed_selector
template<> class __make_signed_selector<wchar_t, false, true> {
        typedef typename __make_unsigned_selector<wchar_t>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    }
template<> class __make_signed_selector<unsigned int, true, false> {
        using __signed_type = typename __make_signed<typename remove_cv<unsigned int>::type>::__type;
    public:
        using __type = typename __match_cv_qualifiers<unsigned int, __signed_type>::__type;
    }
template<> class __make_signed_selector<char16_t, false, true> {
        typedef typename __make_unsigned_selector<char16_t>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    }
template<> class __make_signed_selector<unsigned short, true, false> {
        using __signed_type = typename __make_signed<typename remove_cv<unsigned short>::type>::__type;
    public:
        using __type = typename __match_cv_qualifiers<unsigned short, __signed_type>::__type;
    }
template<> class __make_signed_selector<char32_t, false, true> {
        typedef typename __make_unsigned_selector<char32_t>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };
    template <typename _Tp> class __make_signed_selector<_Tp, true, false> {
        using __signed_type = typename __make_signed<typename remove_cv<_Tp>::type>::__type;
    public:
        using __type = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
    };
    template <typename _Tp> class __make_signed_selector<_Tp, false, true> {
        typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;
    public:
        typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };
    template<> struct __make_signed<wchar_t> {
        using __type = typename __make_signed_selector<wchar_t, false, true>::__type;
    };
    constexpr bool value;
    template<> struct __make_signed<char16_t> {
        using __type = typename __make_signed_selector<char16_t, false, true>::__type;
    };
    template<> struct __make_signed<char32_t> {
        using __type = typename __make_signed_selector<char32_t, false, true>::__type;
    };
    template <typename _Tp> struct make_signed {
        typedef typename __make_signed_selector<_Tp>::__type type;
    };
    template<> struct make_signed<bool>;
    template <typename _Tp> using make_signed_t = typename make_signed<_Tp>::type;
    template <typename _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;
    template <typename _Tp> struct remove_extent {
        typedef _Tp type;
    };
    template <typename _Tp, std::size_t _Size> struct remove_extent<_Tp [_Size]> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_extent<_Tp []> {
        typedef _Tp type;
    };
    template <typename _Tp> struct remove_all_extents {
        typedef _Tp type;
    };
    template <typename _Tp, std::size_t _Size> struct remove_all_extents<_Tp [_Size]> {
        typedef typename remove_all_extents<_Tp>::type type;
    };
    template <typename _Tp> struct remove_all_extents<_Tp []> {
        typedef typename remove_all_extents<_Tp>::type type;
    };
    template <typename _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;
    template <typename _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;
    template <typename _Tp, typename> struct __remove_pointer_helper {
        typedef _Tp type;
    };
    template <typename _Tp, typename _Up> struct __remove_pointer_helper<_Tp, _Up *> {
        typedef _Up type;
    };
    template <typename _Tp> struct remove_pointer : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type> {
    };
    template <typename _Tp, bool = __or_<__is_referenceable<_Tp>, is_void<_Tp> >::value> struct __add_pointer_helper {
        typedef _Tp type;
    };
    template <typename _Tp> struct __add_pointer_helper<_Tp, true> {
        typedef typename remove_reference<_Tp>::type *type;
    };
    template <typename _Tp> struct add_pointer : public __add_pointer_helper<_Tp> {
    };
    template <typename _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;
    template <typename _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;
    template <std::size_t _Len> struct __aligned_storage_msa {
        union __type {
            unsigned char __data[_Len];
            struct __attribute__((aligned)) {
            } __align;
        };
    };
    template <std::size_t _Len, std::size_t _Align = __alignof(typename __aligned_storage_msa<_Len>::__type)> struct aligned_storage {
        union type {
            unsigned char __data[_Len];
            struct __attribute__((aligned((_Align)))) {
            } __align;
        };
    };
    template <typename ..._Types> struct __strictest_alignment {
        static const std::size_t _S_alignment = 0;
        static const std::size_t _S_size = 0;
    };
    template <typename _Tp, typename ..._Types> struct __strictest_alignment<_Tp, _Types...> {
        static const std::size_t _S_alignment = alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
        static const std::size_t _S_size = sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
    template <std::size_t _Len, typename ..._Types> struct aligned_union {
    private:
        static_assert(sizeof...(_Types) != 0, "At least one type is required");
        using __strictest = __strictest_alignment<_Types...>;
        static const std::size_t _S_len = _Len > __strictest::_S_size ? _Len : __strictest::_S_size;
    public:
        static const std::size_t alignment_value = __strictest::_S_alignment;
        typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };
    const std::size_t alignment_value;
    template <typename _Up, bool _IsArray = is_array<_Up>::value, bool _IsFunction = is_function<_Up>::value> struct __decay_selector;
    template <typename _Up> struct __decay_selector<_Up, false, false> {
        typedef typename remove_cv<_Up>::type __type;
    };
    template <typename _Up> struct __decay_selector<_Up, true, false> {
        typedef typename remove_extent<_Up>::type *__type;
    };
    template <typename _Up> struct __decay_selector<_Up, false, true> {
        typedef typename add_pointer<_Up>::type __type;
    };
    template <typename _Tp> class decay {
        typedef typename remove_reference<_Tp>::type __remove_type;
    public:
        typedef typename __decay_selector<__remove_type>::__type type;
    };
    template <typename _Tp> class reference_wrapper;
    template <typename _Tp> struct __strip_reference_wrapper {
        typedef _Tp __type;
    };
    template <typename _Tp> struct __strip_reference_wrapper<reference_wrapper<_Tp>> {
        typedef _Tp &__type;
    };
    template <typename _Tp> struct __decay_and_strip {
        typedef typename __strip_reference_wrapper<typename decay<_Tp>::type>::__type __type;
    };
    template <bool, typename _Tp = void> struct enable_if {
    };
template<> struct enable_if<false, void> {
    };
template<> struct enable_if<false, std::error_code &> {
    };
template<> struct enable_if<true, void> {
        typedef void type;
    };
template<> struct enable_if<false, std::basic_istream<char> &> {
    };
template<> struct enable_if<false, std::basic_istream<wchar_t> &> {
    };
template<> struct enable_if<false, std::basic_ostream<char> &> {
    };
template<> struct enable_if<false, double> {
    };
template<> struct enable_if<true, double> {
        typedef double type;
    };
template<> struct enable_if<true, int> {
        typedef int type;
    };
template<> struct enable_if<false, int> {
    };
template<> struct enable_if<false, float> {
    };
template<> struct enable_if<true, float> {
        typedef float type;
    };
    template <typename _Tp> struct enable_if<true, _Tp> {
        typedef _Tp type;
    };
    template <typename ..._Cond> using _Require = typename enable_if<__and_<_Cond...>::value>::type;
    template <bool _Cond, typename _Iftrue, typename _Iffalse> struct conditional {
        typedef _Iftrue type;
    };
template<> struct conditional<true, std::__is_nt_default_constructible_impl<std::allocator<char>, false>, std::is_default_constructible<std::allocator<char> >> {
        typedef std::__is_nt_default_constructible_impl<std::allocator<char>, false> type;
    };
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_istream<std::basic_istream<char> &>, std::__is_extractable<std::basic_istream<char> &, char &, void> >, std::__not_<std::is_lvalue_reference<std::basic_istream<char> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_istream<char> &> > type;
    };
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_istream<std::basic_istream<char> &>, std::__is_extractable<std::basic_istream<char> &, unsigned char &, void> >, std::__not_<std::is_lvalue_reference<std::basic_istream<char> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_istream<char> &> > type;
    };
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_istream<std::basic_istream<char> &>, std::__is_extractable<std::basic_istream<char> &, signed char &, void> >, std::__not_<std::is_lvalue_reference<std::basic_istream<char> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_istream<char> &> > type;
    };
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_istream<std::basic_istream<wchar_t> &>, std::__is_extractable<std::basic_istream<wchar_t> &, wchar_t &, void> >, std::__not_<std::is_lvalue_reference<std::basic_istream<wchar_t> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_istream<wchar_t> &> > type;
    };
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[13], void> >, std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> > type;
    };
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[11], void> >, std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> > type;
    };
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[12], void> >, std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> > type;
    };
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[16], void> >, std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> > type;
    };
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[18], void> >, std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> > type;
    };
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, const int &, void> >, std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> > type;
    };
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[3], void> >, std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> > type;
    };
template<> struct conditional<false, std::__and_<std::__is_convertible_to_basic_ostream<std::basic_ostream<char> &>, std::__is_insertable<std::basic_ostream<char> &, char const (&)[8], void> >, std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> >> {
        typedef std::__not_<std::is_lvalue_reference<std::basic_ostream<char> &> > type;
    };
template<> struct conditional<false, std::is_void<std::random_access_iterator_tag>, std::__or_<std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag> >> {
        typedef std::__or_<std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag> > type;
    };
template<> struct conditional<false, std::is_function<std::input_iterator_tag>, std::is_array<std::input_iterator_tag>> {
        typedef std::is_array<std::input_iterator_tag> type;
    };
template<> struct conditional<false, std::__undefined, char> {
        typedef char type;
    };
template<> struct conditional<false, std::__undefined, const char> {
        typedef const char type;
    };
template<> struct conditional<false, std::__undefined, wchar_t> {
        typedef wchar_t type;
    };
template<> struct conditional<false, std::__undefined, const wchar_t> {
        typedef const wchar_t type;
    };
template<> struct conditional<false, std::__undefined, char16_t> {
        typedef char16_t type;
    };
template<> struct conditional<false, std::__undefined, const char16_t> {
        typedef const char16_t type;
    };
template<> struct conditional<false, std::__undefined, char32_t> {
        typedef char32_t type;
    };
template<> struct conditional<false, std::__undefined, const char32_t> {
        typedef const char32_t type;
    };
    template <typename _Iftrue, typename _Iffalse> struct conditional<false, _Iftrue, _Iffalse> {
        typedef _Iffalse type;
    };
    template <typename ..._Tp> struct common_type;
    struct __do_common_type_impl {
        template <typename _Tp, typename _Up> static __success_type<typename decay<decltype(true ? std::declval<_Tp>() : std::declval<_Up>())>::type> _S_test(int);
        template <typename, typename> static std::__failure_type _S_test(...);
    };
    template <typename _Tp, typename _Up> struct __common_type_impl : private std::__do_common_type_impl {
        typedef decltype(_S_test<_Tp, _Up>(0)) type;
    };
    struct __do_member_type_wrapper {
        template <typename _Tp> static __success_type<typename _Tp::type> _S_test(int);
        template <typename> static std::__failure_type _S_test(...);
    };
    template <typename _Tp> struct __member_type_wrapper : private std::__do_member_type_wrapper {
        typedef decltype(_S_test<_Tp>(0)) type;
    };
    template <typename _CTp, typename ..._Args> struct __expanded_common_type_wrapper {
        typedef common_type<typename _CTp::type, _Args...> type;
    };
    template <typename ..._Args> struct __expanded_common_type_wrapper<std::__failure_type, _Args...> {
        typedef std::__failure_type type;
    };
    template<> struct common_type<> {
    };
    template <typename _Tp> struct common_type<_Tp> : common_type<_Tp, _Tp> {
    };
    template <typename _Tp, typename _Up> struct common_type<_Tp, _Up> : public __common_type_impl<_Tp, _Up>::type {
    };
    template <typename _Tp, typename _Up, typename ..._Vp> struct common_type<_Tp, _Up, _Vp...> : public __expanded_common_type_wrapper<typename __member_type_wrapper<common_type<_Tp, _Up> >::type, _Vp...>::type {
    };
    template <typename _Tp, bool = is_enum<_Tp>::value> struct __underlying_type_impl {
        using type = __underlying_type(_Tp);
    };
    template <typename _Tp> struct __underlying_type_impl<_Tp, false> {
    };
    template <typename _Tp> struct underlying_type : public __underlying_type_impl<_Tp> {
    };
    template <typename _Tp> struct __declval_protector {
        static const bool __stop = false;
    };
    template <typename _Tp> auto declval() noexcept -> decltype(__declval<_Tp>(0))     {
        static_assert(__declval_protector<_Tp>::__stop, "declval() must not be used!");
        return __declval<_Tp>(0);
    }
    template<> auto declval<std::basic_istream<char> *>() noexcept -> decltype(__declval<std::basic_istream<char> *>(0))    template<> auto declval<std::basic_istream<wchar_t> *>() noexcept -> decltype(__declval<std::basic_istream<wchar_t> *>(0))    template<> auto declval<std::basic_ostream<char> *>() noexcept -> decltype(__declval<std::basic_ostream<char> *>(0))    template<> auto declval<std::random_access_iterator_tag>() noexcept -> decltype(__declval<std::random_access_iterator_tag>(0))    template <typename _Tp> using __remove_cvref_t = typename remove_cv<typename remove_reference<_Tp>::type>::type;
    template <typename _Signature> class result_of;
    struct __invoke_memfun_ref {
    };
    struct __invoke_memfun_deref {
    };
    struct __invoke_memobj_ref {
    };
    struct __invoke_memobj_deref {
    };
    struct __invoke_other {
    };
    template <typename _Tp, typename _Tag> struct __result_of_success : __success_type<_Tp> {
        using __invoke_type = _Tag;
    };
    struct __result_of_memfun_ref_impl {
        template <typename _Fp, typename _Tp1, typename ..._Args> static __result_of_success<decltype((std::declval<_Tp1>() .* std::declval<_Fp>())(std::declval<_Args>()...)), std::__invoke_memfun_ref> _S_test(int);
        template <typename ...> static std::__failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_memfun_ref : private std::__result_of_memfun_ref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };
    struct __result_of_memfun_deref_impl {
        template <typename _Fp, typename _Tp1, typename ..._Args> static __result_of_success<decltype(((*std::declval<_Tp1>()) .* std::declval<_Fp>())(std::declval<_Args>()...)), std::__invoke_memfun_deref> _S_test(int);
        template <typename ...> static std::__failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_memfun_deref : private std::__result_of_memfun_deref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };
    struct __result_of_memobj_ref_impl {
        template <typename _Fp, typename _Tp1> static __result_of_success<decltype(std::declval<_Tp1>() .* std::declval<_Fp>()), std::__invoke_memobj_ref> _S_test(int);
        template <typename, typename> static std::__failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_memobj_ref : private std::__result_of_memobj_ref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };
    struct __result_of_memobj_deref_impl {
        template <typename _Fp, typename _Tp1> static __result_of_success<decltype((*std::declval<_Tp1>()) .* std::declval<_Fp>()), std::__invoke_memobj_deref> _S_test(int);
        template <typename, typename> static std::__failure_type _S_test(...);
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_memobj_deref : private std::__result_of_memobj_deref_impl {
        typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_memobj;
    template <typename _Res, typename _Class, typename _Arg> struct __result_of_memobj<_Res _Class::*, _Arg> {
        typedef __remove_cvref_t<_Arg> _Argval;
        typedef _Res _Class::*_MemPtr;
        typedef typename conditional<__or_<is_same<_Argval, _Class>, is_base_of<_Class, _Argval> >::value, __result_of_memobj_ref<_MemPtr, _Arg>, __result_of_memobj_deref<_MemPtr, _Arg> >::type::type type;
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_memfun;
    template <typename _Res, typename _Class, typename _Arg, typename ..._Args> struct __result_of_memfun<_Res _Class::*, _Arg, _Args...> {
        typedef typename remove_reference<_Arg>::type _Argval;
        typedef _Res _Class::*_MemPtr;
        typedef typename conditional<is_base_of<_Class, _Argval>::value, __result_of_memfun_ref<_MemPtr, _Arg, _Args...>, __result_of_memfun_deref<_MemPtr, _Arg, _Args...> >::type::type type;
    };
    template <typename _Tp, typename _Up = __remove_cvref_t<_Tp>> struct __inv_unwrap {
        using type = _Tp;
    };
    template <typename _Tp, typename _Up> struct __inv_unwrap<_Tp, reference_wrapper<_Up>> {
        using type = _Up &;
    };
    template <bool, bool, typename _Functor, typename ..._ArgTypes> struct __result_of_impl {
        typedef std::__failure_type type;
    };
    template <typename _MemPtr, typename _Arg> struct __result_of_impl<true, false, _MemPtr, _Arg> : public __result_of_memobj<typename decay<_MemPtr>::type, typename __inv_unwrap<_Arg>::type> {
    };
    template <typename _MemPtr, typename _Arg, typename ..._Args> struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...> : public __result_of_memfun<typename decay<_MemPtr>::type, typename __inv_unwrap<_Arg>::type, _Args...> {
    };
    struct __result_of_other_impl {
        template <typename _Fn, typename ..._Args> static __result_of_success<decltype(std::declval<_Fn>()(std::declval<_Args>()...)), std::__invoke_other> _S_test(int);
        template <typename ...> static std::__failure_type _S_test(...);
    };
    template <typename _Functor, typename ..._ArgTypes> struct __result_of_impl<false, false, _Functor, _ArgTypes...> : private std::__result_of_other_impl {
        typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };
    template <typename _Functor, typename ..._ArgTypes> struct __invoke_result : public __result_of_impl<is_member_object_pointer<typename remove_reference<_Functor>::type>::value, is_member_function_pointer<typename remove_reference<_Functor>::type>::value, _Functor, _ArgTypes...>::type {
    };
    template <typename _Functor, typename ..._ArgTypes> struct result_of<_Functor (_ArgTypes...)> : public __invoke_result<_Functor, _ArgTypes...> {
    };
    template <std::size_t _Len, std::size_t _Align = __alignof(typename __aligned_storage_msa<_Len>::__type)> using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
    template <std::size_t _Len, typename ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
    template <typename _Tp> using decay_t = typename decay<_Tp>::type;
    template <bool _Cond, typename _Tp = void> using enable_if_t = typename enable_if<_Cond, _Tp>::type;
    template <bool _Cond, typename _Iftrue, typename _Iffalse> using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;
    template <typename ..._Tp> using common_type_t = typename common_type<_Tp...>::type;
    template <typename _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;
    template <typename _Tp> using result_of_t = typename result_of<_Tp>::type;
    template <bool _Cond, typename _Tp = void> using __enable_if_t = typename enable_if<_Cond, _Tp>::type;
    template <typename ...> using __void_t = void;
    template <typename ...> using void_t = void;
    template <typename _Default, typename _AlwaysVoid, template <typename ...> class _Op, typename ..._Args> struct __detector {
        using value_t = std::false_type;
        using type = _Default;
    };
    template <typename _Default, template <typename ...> class _Op, typename ..._Args> struct __detector<_Default, __void_t<_Op<_Args...> >, _Op, _Args...> {
        using value_t = std::true_type;
        using type = _Op<_Args...>;
    };
    template <typename _Default, template <typename ...> class _Op, typename ..._Args> using __detected_or = __detector<_Default, void, _Op, _Args...>;
    template <typename _Default, template <typename ...> class _Op, typename ..._Args> using __detected_or_t = typename __detected_or<_Default, _Op, _Args...>::type;
    template <typename _Tp> struct __is_swappable;
    template <typename _Tp> struct __is_nothrow_swappable;
    template <typename ..._Elements> class tuple;
    template <typename> struct __is_tuple_like_impl : std::false_type {
    };
    template <typename ..._Tps> struct __is_tuple_like_impl<tuple<_Tps...>> : std::true_type {
    };
    template <typename _Tp> struct __is_tuple_like : public __is_tuple_like_impl<__remove_cvref_t<_Tp> >::type {
    };
    template <typename _Tp> inline typename enable_if<__and_<__not_<__is_tuple_like<_Tp> >, is_move_constructible<_Tp>, is_move_assignable<_Tp> >::value>::type swap(_Tp &, _Tp &) noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp> >::valueswap(_Tp &, _Tp &) noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp> >::value);
    template <typename _Tp, std::size_t _Nm> inline typename enable_if<__is_swappable<_Tp>::value>::type swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::valueswap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::value);
    namespace __swappable_details {
        using std::swap;
        struct __do_is_swappable_impl {
            template <typename _Tp, typename = decltype(swap(std::declval<_Tp &>(), std::declval<_Tp &>()))> static std::true_type __test(int);
            template <typename> static std::false_type __test(...);
        };
        struct __do_is_nothrow_swappable_impl {
            template <typename _Tp> static __bool_constant<noexcept(swap(std::declval<_Tp &>(), std::declval<_Tp &>()))> __test(int);
            template <typename> static std::false_type __test(...);
        };
    }
    template <typename _Tp> struct __is_swappable_impl : public __swappable_details::__do_is_swappable_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp> struct __is_nothrow_swappable_impl : public __swappable_details::__do_is_nothrow_swappable_impl {
        typedef decltype(__test<_Tp>(0)) type;
    };
    template <typename _Tp> struct __is_swappable : public __is_swappable_impl<_Tp>::type {
    };
    template <typename _Tp> struct __is_nothrow_swappable : public __is_nothrow_swappable_impl<_Tp>::type {
    };
    template <typename _Tp> struct is_swappable : public __is_swappable_impl<_Tp>::type {
    };
    template <typename _Tp> struct is_nothrow_swappable : public __is_nothrow_swappable_impl<_Tp>::type {
    };
    template <typename _Tp> constexpr bool is_swappable_v = is_swappable<_Tp>::value;
    template <typename _Tp> constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;
    namespace __swappable_with_details {
        using std::swap;
        struct __do_is_swappable_with_impl {
            template <typename _Tp, typename _Up, typename = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())), typename = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))> static std::true_type __test(int);
            template <typename, typename> static std::false_type __test(...);
        };
        struct __do_is_nothrow_swappable_with_impl {
            template <typename _Tp, typename _Up> static __bool_constant<noexcept(swap(std::declval<_Tp>(), std::declval<_Up>())) && noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))> __test(int);
            template <typename, typename> static std::false_type __test(...);
        };
    }
    template <typename _Tp, typename _Up> struct __is_swappable_with_impl : public __swappable_with_details::__do_is_swappable_with_impl {
        typedef decltype(__test<_Tp, _Up>(0)) type;
    };
    template <typename _Tp> struct __is_swappable_with_impl<_Tp &, _Tp &> : public __swappable_details::__do_is_swappable_impl {
        typedef decltype(__test<_Tp &>(0)) type;
    };
    template <typename _Tp, typename _Up> struct __is_nothrow_swappable_with_impl : public __swappable_with_details::__do_is_nothrow_swappable_with_impl {
        typedef decltype(__test<_Tp, _Up>(0)) type;
    };
    template <typename _Tp> struct __is_nothrow_swappable_with_impl<_Tp &, _Tp &> : public __swappable_details::__do_is_nothrow_swappable_impl {
        typedef decltype(__test<_Tp &>(0)) type;
    };
    template <typename _Tp, typename _Up> struct is_swappable_with : public __is_swappable_with_impl<_Tp, _Up>::type {
    };
    template <typename _Tp, typename _Up> struct is_nothrow_swappable_with : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type {
    };
    template <typename _Tp, typename _Up> constexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;
    template <typename _Tp, typename _Up> constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;
    template <typename _Result, typename _Ret, bool = is_void<_Ret>::value, typename = void> struct __is_invocable_impl : std::false_type {
    };
    template <typename _Result, typename _Ret> struct __is_invocable_impl<_Result, _Ret, true, __void_t<typename _Result::type>> : std::true_type {
    };
    template <typename _Result, typename _Ret> struct __is_invocable_impl<_Result, _Ret, false, __void_t<typename _Result::type>> {
    private:
        static typename _Result::type _S_get();
        template <typename _Tp> static void _S_conv(_Tp);
        template <typename _Tp, typename = decltype(_S_conv<_Tp>(_S_get()))> static std::true_type _S_test(int);
        template <typename _Tp> static std::false_type _S_test(...);
    public:
        using type = decltype(_S_test<_Ret>(1));
    };
    template <typename _Fn, typename ..._ArgTypes> struct __is_invocable : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type {
    };
    template <typename _Fn, typename _Tp, typename ..._Args> constexpr bool __call_is_nt(std::__invoke_memfun_ref)     {
        using _Up = typename __inv_unwrap<_Tp>::type;
        return noexcept((std::declval<_Up>() .* std::declval<_Fn>())(std::declval<_Args>()...));
    }
    template <typename _Fn, typename _Tp, typename ..._Args> constexpr bool __call_is_nt(std::__invoke_memfun_deref)     {
        return noexcept(((*std::declval<_Tp>()) .* std::declval<_Fn>())(std::declval<_Args>()...));
    }
    template <typename _Fn, typename _Tp> constexpr bool __call_is_nt(std::__invoke_memobj_ref)     {
        using _Up = typename __inv_unwrap<_Tp>::type;
        return noexcept(std::declval<_Up>() .* std::declval<_Fn>());
    }
    template <typename _Fn, typename _Tp> constexpr bool __call_is_nt(std::__invoke_memobj_deref)     {
        return noexcept((*std::declval<_Tp>()) .* std::declval<_Fn>());
    }
    template <typename _Fn, typename ..._Args> constexpr bool __call_is_nt(std::__invoke_other)     {
        return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }
    template <typename _Result, typename _Fn, typename ..._Args> struct __call_is_nothrow : __bool_constant<std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type({}))> {
    };
    template <typename _Fn, typename ..._Args> using __call_is_nothrow_ = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;
    template <typename _Fn, typename ..._Args> struct __is_nothrow_invocable : __and_<__is_invocable<_Fn, _Args...>, __call_is_nothrow_<_Fn, _Args...> >::type {
    };
    struct __nonesuch {
        __nonesuch() = delete
        ~__nonesuch() = delete
        __nonesuch(const std::__nonesuch &) = delete
        void operator=(const std::__nonesuch &) = delete
    };
}
namespace std {
    template <typename> class allocator
template<> class allocator<char16_t> : public __allocator_base<char16_t> {
    public:
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char16_t *pointer;
        typedef const char16_t *const_pointer;
        typedef char16_t &reference;
        typedef const char16_t &const_reference;
        typedef char16_t value_type;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        typedef std::true_type is_always_equal;
        allocator() noexcept : __allocator_base<char16_t>()         {
        }
        allocator(const std::allocator<char16_t> &__a) noexcept : __allocator_base<char16_t>(__a)         {
        }
        std::allocator<char16_t> &operator=(const std::allocator<char16_t> &) = default
        template <typename _Tp1> allocator(const allocator<_Tp1> &) noexcept;
        template<> allocator<char16_t>(const allocator<char16_t> &) noexcept;
        ~allocator<char16_t>() noexcept         {
        }
        friend bool operator==(const std::allocator<char16_t> &, const std::allocator<char16_t> &) noexcept;
        friend bool operator!=(const std::allocator<char16_t> &, const std::allocator<char16_t> &) noexcept;
    }
template<> class allocator<char32_t> : public __allocator_base<char32_t> {
    public:
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char32_t *pointer;
        typedef const char32_t *const_pointer;
        typedef char32_t &reference;
        typedef const char32_t &const_reference;
        typedef char32_t value_type;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        typedef std::true_type is_always_equal;
        allocator() noexcept : __allocator_base<char32_t>()         {
        }
        allocator(const std::allocator<char32_t> &__a) noexcept : __allocator_base<char32_t>(__a)         {
        }
        std::allocator<char32_t> &operator=(const std::allocator<char32_t> &) = default
        template <typename _Tp1> allocator(const allocator<_Tp1> &) noexcept;
        template<> allocator<char32_t>(const allocator<char32_t> &) noexcept;
        ~allocator<char32_t>() noexcept         {
        }
        friend bool operator==(const std::allocator<char32_t> &, const std::allocator<char32_t> &) noexcept;
        friend bool operator!=(const std::allocator<char32_t> &, const std::allocator<char32_t> &) noexcept;
    };
    template<> class allocator<void>;
    template <typename, typename> struct uses_allocator;
}
namespace std {
    template <class _CharT> struct char_traits;
    template<> struct char_traits<char>;
    template<> struct char_traits<wchar_t>;
    template<> struct char_traits<char16_t>;
    template<> struct char_traits<char32_t>;
    inline namespace __cxx11 {
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_string
template<> class basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char16_t> >::rebind<char16_t>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<char16_t> traits_type;
            typedef typename char_traits<char16_t>::char_type value_type;
            typedef std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> > > iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> > > const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type npos = static_cast<std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type>(-1);
        protected:
            typedef std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __const_iterator;
        private:
            struct _Alloc_hider : std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::allocator_type {
                std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::pointer _M_p;
            };
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::_Alloc_hider _M_dataplus;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(char16_t)
            };
            union {
                char16_t _M_local_buf[8];
                std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type _M_allocated_capacity;
            };
            void _M_data(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::pointer __p)             {
                this->_M_dataplus._M_p = __p;
            }
            void _M_length(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __length)             {
                this->_M_string_length = __length;
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::pointer _M_local_data()             {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_pointer _M_local_data() const             {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            void _M_capacity(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __capacity)             {
                this->_M_allocated_capacity = __capacity;
            }
            void _M_set_length(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n)             {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char16_t());
            }
            bool _M_is_local() const             {
                return this->_M_data() == this->_M_local_data();
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::pointer basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >::_M_create(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type &__capacity, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __old_capacity)             {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _Alloc_traits::allocate(this->_M_get_allocator(), __capacity + 1);
            }
            void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            void _M_destroy(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __size) throw()             {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> void _M_construct_aux(_InIterator __beg, _InIterator __end, std::__false_type);
            template<> void _M_construct_aux<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::__false_type)             {
                typedef typename iterator_traits<const char16_t *>::iterator_category _Tag;
                this->_M_construct(__beg, __end, _Tag());
            }
;
            template <typename _Integer> void _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type);
            void _M_construct_aux_2(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __req, char16_t __c);
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end);
            template<> void _M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end)             {
                typedef typename std::__is_integer<const char16_t *>::__type _Integral;
                this->_M_construct_aux(__beg, __end, _Integral());
            }
;
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> void _M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> void basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >::_M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::forward_iterator_tag)             {
                if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                    std::__throw_logic_error(("basic_string::_M_construct null not valid"));
                std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __dnew = static_cast<std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type>(std::distance(__beg, __end));
                if (__dnew > std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type(0)));
                    this->_M_capacity(__dnew);
                }
                try {
                    this->_S_copy_chars(this->_M_data(), __beg, __end);
                } catch (...) {
                    this->_M_dispose();
                    throw;
                }
                this->_M_set_length(__dnew);
            }
;
            void _M_construct(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __req, char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }
            const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::allocator_type &_M_get_allocator() const             {
                return this->_M_dataplus;
            }
        private:
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type _M_check(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, const char *__s) const;
            void _M_check_length(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n2, const char *__s) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type _M_limit(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __off) const noexcept;
            bool _M_disjunct(const char16_t *__s) const noexcept;
            static void _S_copy(char16_t *__d, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static void _S_move(char16_t *__d, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            static void _S_assign(char16_t *__d, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, char16_t __c);
            template <class _Iterator> static void _S_copy_chars(char16_t *__p, _Iterator __k1, _Iterator __k2);
            template<> static void _S_copy_chars<const char16_t *>(char16_t *__p, const char16_t *__k1, const char16_t *__k2);
            static void _S_copy_chars(char16_t *__p, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator __k2) noexcept;
            static void _S_copy_chars(char16_t *__p, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __k2) noexcept;
            static void _S_copy_chars(char16_t *__p, char16_t *__k1, char16_t *__k2) noexcept;
            static void _S_copy_chars(char16_t *__p, const char16_t *__k1, const char16_t *__k2) noexcept             {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static int _S_compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n2) noexcept;
            void _M_assign(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &);
            void _M_mutate(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __len1, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __len2);
            void _M_erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
        public:
            basic_string();
            explicit basic_string(const std::allocator<char16_t> &__a) noexcept;
            basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str);
            basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, const std::allocator<char16_t> &__a);
            basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, const std::allocator<char16_t> &__a);
            basic_string(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, const std::allocator<char16_t> &__a = std::allocator<char16_t>()) : _M_dataplus(this->_M_local_data(), __a)             {
                this->_M_construct(__s, __s + __n);
            }
            basic_string(const char16_t *__s, const std::allocator<char16_t> &__a);
            basic_string(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, char16_t __c, const std::allocator<char16_t> &__a);
            basic_string(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &&__str) noexcept : _M_dataplus(this->_M_local_data(), std::move(__str._M_get_allocator()))             {
                if (__str._M_is_local()) {
                    traits_type::copy(this->_M_local_buf, __str._M_local_buf, _S_local_capacity + 1);
                } else {
                    this->_M_data(__str._M_data());
                    this->_M_capacity(__str._M_allocated_capacity);
                }
                this->_M_length(__str.length());
                __str._M_data(__str._M_local_data());
                __str._M_set_length(0);
            }
            basic_string(initializer_list<char16_t> __l, const std::allocator<char16_t> &__a);
            basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, const std::allocator<char16_t> &__a);
            basic_string(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &&__str, const std::allocator<char16_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char16_t> &__a);
            ~basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >() noexcept             {
                this->_M_dispose();
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &operator=(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &operator=(const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &operator=(char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &operator=(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &&__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &operator=(initializer_list<char16_t> __l);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator begin() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator begin() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator end() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator end() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::reverse_iterator rbegin() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_reverse_iterator rbegin() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::reverse_iterator rend() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_reverse_iterator rend() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator cbegin() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator cend() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_reverse_iterator crbegin() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_reverse_iterator crend() const noexcept;
        public:
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type size() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type length() const noexcept             {
                return this->_M_string_length;
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type max_size() const noexcept             {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            void resize(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, char16_t __c);
            void resize(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            void shrink_to_fit() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type capacity() const noexcept;
            void reserve(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __res_arg);
            void clear() noexcept;
            bool empty() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_reference operator[](std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::reference operator[](std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_reference at(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::reference at(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::reference front() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_reference front() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::reference back() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_reference back() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &operator+=(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &operator+=(const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &operator+=(char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &operator+=(initializer_list<char16_t> __l);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &append(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &append(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &append(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &append(const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &append(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &append(initializer_list<char16_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &append(_InputIterator __first, _InputIterator __last);
            void push_back(char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &assign(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &assign(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &&__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &assign(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &assign(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &assign(const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &assign(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &assign(_InputIterator __first, _InputIterator __last);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &assign(initializer_list<char16_t> __l);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __p, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __p, _InputIterator __beg, _InputIterator __end);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __p, initializer_list<char16_t> __l);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __p, char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __position);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __first, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __last);
            void pop_back() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n1, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n1, const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n2, char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i2, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i2, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i2, const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i2, char16_t *__k1, char16_t *__k2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i2, const char16_t *__k1, const char16_t *__k2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator __k2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __k2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __i2, initializer_list<char16_t> __l);
        private:
            template <class _Integer> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &_M_replace_dispatch(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &_M_replace_dispatch(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &_M_replace_aux(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n2, char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &_M_replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __len1, const char16_t *__s, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __len2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &_M_append(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
        public:
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type copy(char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const;
            void swap(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__s) noexcept;
            const char16_t *c_str() const noexcept;
            const char16_t *data() const noexcept             {
                return this->_M_data();
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::allocator_type get_allocator() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type rfind(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type rfind(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type rfind(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type rfind(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_first_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_first_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_first_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_first_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_last_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_last_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_last_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_last_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_first_not_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_first_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_first_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_first_not_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_last_not_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_last_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_last_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_last_not_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > substr(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n) const;
            int compare(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str) const;
            int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str) const;
            int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n2) const;
            int compare(const char16_t *__s) const noexcept;
            int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n1, const char16_t *__s) const;
            int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n1, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n2) const;
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        }
template<> class basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char32_t> >::rebind<char32_t>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<char32_t> traits_type;
            typedef typename char_traits<char32_t>::char_type value_type;
            typedef std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> > > iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> > > const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type npos = static_cast<std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type>(-1);
        protected:
            typedef std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __const_iterator;
        private:
            struct _Alloc_hider : std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::allocator_type {
                std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::pointer _M_p;
            };
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::_Alloc_hider _M_dataplus;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(char32_t)
            };
            union {
                char32_t _M_local_buf[4];
                std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type _M_allocated_capacity;
            };
            void _M_data(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::pointer __p)             {
                this->_M_dataplus._M_p = __p;
            }
            void _M_length(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __length)             {
                this->_M_string_length = __length;
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::pointer _M_local_data()             {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_pointer _M_local_data() const             {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            void _M_capacity(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __capacity)             {
                this->_M_allocated_capacity = __capacity;
            }
            void _M_set_length(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n)             {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char32_t());
            }
            bool _M_is_local() const             {
                return this->_M_data() == this->_M_local_data();
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::pointer basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >::_M_create(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type &__capacity, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __old_capacity)             {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _Alloc_traits::allocate(this->_M_get_allocator(), __capacity + 1);
            }
            void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            void _M_destroy(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __size) throw()             {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> void _M_construct_aux(_InIterator __beg, _InIterator __end, std::__false_type);
            template<> void _M_construct_aux<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::__false_type)             {
                typedef typename iterator_traits<const char32_t *>::iterator_category _Tag;
                this->_M_construct(__beg, __end, _Tag());
            }
;
            template <typename _Integer> void _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type);
            void _M_construct_aux_2(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __req, char32_t __c);
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end);
            template<> void _M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end)             {
                typedef typename std::__is_integer<const char32_t *>::__type _Integral;
                this->_M_construct_aux(__beg, __end, _Integral());
            }
;
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> void _M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> void basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >::_M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::forward_iterator_tag)             {
                if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                    std::__throw_logic_error(("basic_string::_M_construct null not valid"));
                std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __dnew = static_cast<std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type>(std::distance(__beg, __end));
                if (__dnew > std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type(0)));
                    this->_M_capacity(__dnew);
                }
                try {
                    this->_S_copy_chars(this->_M_data(), __beg, __end);
                } catch (...) {
                    this->_M_dispose();
                    throw;
                }
                this->_M_set_length(__dnew);
            }
;
            void _M_construct(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __req, char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }
            const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::allocator_type &_M_get_allocator() const             {
                return this->_M_dataplus;
            }
        private:
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type _M_check(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, const char *__s) const;
            void _M_check_length(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n2, const char *__s) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type _M_limit(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __off) const noexcept;
            bool _M_disjunct(const char32_t *__s) const noexcept;
            static void _S_copy(char32_t *__d, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static void _S_move(char32_t *__d, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            static void _S_assign(char32_t *__d, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, char32_t __c);
            template <class _Iterator> static void _S_copy_chars(char32_t *__p, _Iterator __k1, _Iterator __k2);
            template<> static void _S_copy_chars<const char32_t *>(char32_t *__p, const char32_t *__k1, const char32_t *__k2);
            static void _S_copy_chars(char32_t *__p, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator __k2) noexcept;
            static void _S_copy_chars(char32_t *__p, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __k2) noexcept;
            static void _S_copy_chars(char32_t *__p, char32_t *__k1, char32_t *__k2) noexcept;
            static void _S_copy_chars(char32_t *__p, const char32_t *__k1, const char32_t *__k2) noexcept             {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static int _S_compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n2) noexcept;
            void _M_assign(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &);
            void _M_mutate(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __len1, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __len2);
            void _M_erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
        public:
            basic_string();
            explicit basic_string(const std::allocator<char32_t> &__a) noexcept;
            basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str);
            basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, const std::allocator<char32_t> &__a);
            basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, const std::allocator<char32_t> &__a);
            basic_string(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, const std::allocator<char32_t> &__a = std::allocator<char32_t>()) : _M_dataplus(this->_M_local_data(), __a)             {
                this->_M_construct(__s, __s + __n);
            }
            basic_string(const char32_t *__s, const std::allocator<char32_t> &__a);
            basic_string(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, char32_t __c, const std::allocator<char32_t> &__a);
            basic_string(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &&__str) noexcept : _M_dataplus(this->_M_local_data(), std::move(__str._M_get_allocator()))             {
                if (__str._M_is_local()) {
                    traits_type::copy(this->_M_local_buf, __str._M_local_buf, _S_local_capacity + 1);
                } else {
                    this->_M_data(__str._M_data());
                    this->_M_capacity(__str._M_allocated_capacity);
                }
                this->_M_length(__str.length());
                __str._M_data(__str._M_local_data());
                __str._M_set_length(0);
            }
            basic_string(initializer_list<char32_t> __l, const std::allocator<char32_t> &__a);
            basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, const std::allocator<char32_t> &__a);
            basic_string(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &&__str, const std::allocator<char32_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char32_t> &__a);
            ~basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >() noexcept             {
                this->_M_dispose();
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &operator=(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &operator=(const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &operator=(char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &operator=(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &&__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &operator=(initializer_list<char32_t> __l);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator begin() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator begin() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator end() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator end() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::reverse_iterator rbegin() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_reverse_iterator rbegin() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::reverse_iterator rend() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_reverse_iterator rend() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator cbegin() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator cend() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_reverse_iterator crbegin() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_reverse_iterator crend() const noexcept;
        public:
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type size() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type length() const noexcept             {
                return this->_M_string_length;
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type max_size() const noexcept             {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            void resize(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, char32_t __c);
            void resize(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            void shrink_to_fit() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type capacity() const noexcept;
            void reserve(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __res_arg);
            void clear() noexcept;
            bool empty() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_reference operator[](std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::reference operator[](std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_reference at(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::reference at(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::reference front() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_reference front() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::reference back() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_reference back() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &operator+=(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &operator+=(const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &operator+=(char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &operator+=(initializer_list<char32_t> __l);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &append(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &append(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &append(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &append(const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &append(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &append(initializer_list<char32_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &append(_InputIterator __first, _InputIterator __last);
            void push_back(char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &assign(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &assign(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &&__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &assign(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &assign(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &assign(const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &assign(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &assign(_InputIterator __first, _InputIterator __last);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &assign(initializer_list<char32_t> __l);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __p, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __p, _InputIterator __beg, _InputIterator __end);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __p, initializer_list<char32_t> __l);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __p, char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __position);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __first, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __last);
            void pop_back() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n1, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n1, const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n2, char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i2, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i2, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i2, const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i2, char32_t *__k1, char32_t *__k2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i2, const char32_t *__k1, const char32_t *__k2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator __k2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __k2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __i2, initializer_list<char32_t> __l);
        private:
            template <class _Integer> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &_M_replace_dispatch(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &_M_replace_dispatch(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &_M_replace_aux(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n2, char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &_M_replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __len1, const char32_t *__s, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __len2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &_M_append(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
        public:
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type copy(char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const;
            void swap(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__s) noexcept;
            const char32_t *c_str() const noexcept;
            const char32_t *data() const noexcept             {
                return this->_M_data();
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::allocator_type get_allocator() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type rfind(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type rfind(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type rfind(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type rfind(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_first_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_first_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_first_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_first_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_last_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_last_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_last_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_last_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_first_not_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_first_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_first_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_first_not_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_last_not_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_last_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_last_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_last_not_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > substr(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n) const;
            int compare(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str) const;
            int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str) const;
            int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n2) const;
            int compare(const char32_t *__s) const noexcept;
            int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n1, const char32_t *__s) const;
            int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n1, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n2) const;
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        };
    }
    typedef basic_string<char> string;
    typedef basic_string<wchar_t> wstring;
    typedef basic_string<char16_t> u16string;
    typedef basic_string<char32_t> u32string;
}
typedef float _Float32;
typedef double _Float64;
typedef double _Float32x;
typedef long double _Float64x;
typedef unsigned long size_t;
typedef __builtin_va_list va_list;
typedef __builtin_va_list __gnuc_va_list;
typedef unsigned int wint_t;
typedef struct {
    int __count;
    union {
        unsigned int __wch;
        char __wchb[4];
    } __value;
} __mbstate_t;
typedef __mbstate_t mbstate_t;
struct _IO_FILE;
typedef struct _IO_FILE __FILE;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
struct __locale_struct {
    struct __locale_data *__locales[13];
    const unsigned short *__ctype_b;
    const int *__ctype_tolower;
    const int *__ctype_toupper;
    const char *__names[13];
};
typedef struct __locale_struct *__locale_t;
typedef __locale_t locale_t;
extern "C" {
    struct tm;
    extern wchar_t *wcscpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw() __attribute__((nonnull(1, 2)));
    extern wchar_t *wcsncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) throw() __attribute__((nonnull(1, 2)));
    extern wchar_t *wcscat(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw() __attribute__((nonnull(1, 2)));
    extern wchar_t *wcsncat(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) throw() __attribute__((nonnull(1, 2)));
    extern int wcscmp(const wchar_t *__s1, const wchar_t *__s2) throw() __attribute__((pure)) __attribute__((nonnull(1, 2)));
    extern int wcsncmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) throw() __attribute__((pure)) __attribute__((nonnull(1, 2)));
    extern int wcscasecmp(const wchar_t *__s1, const wchar_t *__s2) throw();
    extern int wcsncasecmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) throw();
    extern int wcscasecmp_l(const wchar_t *__s1, const wchar_t *__s2, locale_t __loc) throw();
    extern int wcsncasecmp_l(const wchar_t *__s1, const wchar_t *__s2, size_t __n, locale_t __loc) throw();
    extern int wcscoll(const wchar_t *__s1, const wchar_t *__s2) throw();
    extern size_t wcsxfrm(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) throw();
    extern int wcscoll_l(const wchar_t *__s1, const wchar_t *__s2, locale_t __loc) throw();
    extern size_t wcsxfrm_l(wchar_t *__s1, const wchar_t *__s2, size_t __n, locale_t __loc) throw();
    extern wchar_t *wcsdup(const wchar_t *__s) throw() __attribute__((malloc));
    extern wchar_t *wcschr(const wchar_t *__wcs, wchar_t __wc) throw() __attribute__((pure));
    extern wchar_t *wcsrchr(const wchar_t *__wcs, wchar_t __wc) throw() __attribute__((pure));
    extern wchar_t *wcschrnul(const wchar_t *__s, wchar_t __wc) throw() __attribute__((pure));
    extern size_t wcscspn(const wchar_t *__wcs, const wchar_t *__reject) throw() __attribute__((pure));
    extern size_t wcsspn(const wchar_t *__wcs, const wchar_t *__accept) throw() __attribute__((pure));
    extern wchar_t *wcspbrk(const wchar_t *__wcs, const wchar_t *__accept) throw() __attribute__((pure));
    extern wchar_t *wcsstr(const wchar_t *__haystack, const wchar_t *__needle) throw() __attribute__((pure));
    extern wchar_t *wcstok(wchar_t *__restrict __s, const wchar_t *__restrict __delim, wchar_t **__restrict __ptr) throw();
    extern size_t wcslen(const wchar_t *__s) throw() __attribute__((pure));
    extern wchar_t *wcswcs(const wchar_t *__haystack, const wchar_t *__needle) throw() __attribute__((pure));
    extern size_t wcsnlen(const wchar_t *__s, size_t __maxlen) throw() __attribute__((pure));
    extern wchar_t *wmemchr(const wchar_t *__s, wchar_t __c, size_t __n) throw() __attribute__((pure));
    extern int wmemcmp(const wchar_t *__s1, const wchar_t *__s2, size_t __n) throw() __attribute__((pure));
    extern wchar_t *wmemcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) throw();
    extern wchar_t *wmemmove(wchar_t *__s1, const wchar_t *__s2, size_t __n) throw();
    extern wchar_t *wmemset(wchar_t *__s, wchar_t __c, size_t __n) throw();
    extern wchar_t *wmempcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n) throw();
    extern wint_t btowc(int __c) throw();
    extern int wctob(wint_t __c) throw();
    extern int mbsinit(const mbstate_t *__ps) throw() __attribute__((pure));
    extern size_t mbrtowc(wchar_t *__restrict __pwc, const char *__restrict __s, size_t __n, mbstate_t *__restrict __p) throw();
    extern size_t wcrtomb(char *__restrict __s, wchar_t __wc, mbstate_t *__restrict __ps) throw();
    extern size_t __mbrlen(const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) throw();
    extern size_t mbrlen(const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) throw();
    extern size_t mbsrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, size_t __len, mbstate_t *__restrict __ps) throw();
    extern size_t wcsrtombs(char *__restrict __dst, const wchar_t **__restrict __src, size_t __len, mbstate_t *__restrict __ps) throw();
    extern size_t mbsnrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, size_t __nmc, size_t __len, mbstate_t *__restrict __ps) throw();
    extern size_t wcsnrtombs(char *__restrict __dst, const wchar_t **__restrict __src, size_t __nwc, size_t __len, mbstate_t *__restrict __ps) throw();
    extern int wcwidth(wchar_t __c) throw();
    extern int wcswidth(const wchar_t *__s, size_t __n) throw();
    extern double wcstod(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern float wcstof(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern long double wcstold(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern _Float32 wcstof32(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern _Float64 wcstof64(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern _Float32x wcstof32x(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern _Float64x wcstof64x(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
    extern long wcstol(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern unsigned long wcstoul(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern long long wcstoll(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern unsigned long long wcstoull(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern long long wcstoq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern unsigned long long wcstouq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
    extern long wcstol_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) throw();
    extern unsigned long wcstoul_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) throw();
    extern long long wcstoll_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) throw();
    extern unsigned long long wcstoull_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, locale_t __loc) throw();
    extern double wcstod_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) throw();
    extern float wcstof_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) throw();
    extern long double wcstold_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) throw();
    extern _Float32 wcstof32_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) throw();
    extern _Float64 wcstof64_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) throw();
    extern _Float32x wcstof32x_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) throw();
    extern _Float64x wcstof64x_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, locale_t __loc) throw();
    extern wchar_t *wcpcpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw();
    extern wchar_t *wcpncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n) throw();
    extern __FILE *open_wmemstream(wchar_t **__bufloc, size_t *__sizeloc) throw();
    extern int fwide(__FILE *__fp, int __mode) throw();
    extern int fwprintf(__FILE *__restrict __stream, const wchar_t *__restrict __format, ...);
    extern int wprintf(const wchar_t *__restrict __format, ...);
    extern int swprintf(wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __format, ...) throw();
    extern int vfwprintf(__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vwprintf(const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vswprintf(wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __format, __gnuc_va_list __arg) throw();
    extern int fwscanf(__FILE *__restrict __stream, const wchar_t *__restrict __format, ...);
    extern int wscanf(const wchar_t *__restrict __format, ...);
    extern int swscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) throw();
    extern int fwscanf(__FILE *__restrict __stream, const wchar_t *__restrict __format, ...) asm("__isoc99_fwscanf");
    extern int wscanf(const wchar_t *__restrict __format, ...) asm("__isoc99_wscanf");
    extern int swscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) throw() asm("__isoc99_swscanf");
    extern int vfwscanf(__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vwscanf(const wchar_t *__restrict __format, __gnuc_va_list __arg);
    extern int vswscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) throw();
    extern int vfwscanf(__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) asm("__isoc99_vfwscanf");
    extern int vwscanf(const wchar_t *__restrict __format, __gnuc_va_list __arg) asm("__isoc99_vwscanf");
    extern int vswscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) throw() asm("__isoc99_vswscanf");
    extern wint_t fgetwc(__FILE *__stream);
    extern wint_t getwc(__FILE *__stream);
    extern wint_t getwchar();
    extern wint_t fputwc(wchar_t __wc, __FILE *__stream);
    extern wint_t putwc(wchar_t __wc, __FILE *__stream);
    extern wint_t putwchar(wchar_t __wc);
    extern wchar_t *fgetws(wchar_t *__restrict __ws, int __n, __FILE *__restrict __stream);
    extern int fputws(const wchar_t *__restrict __ws, __FILE *__restrict __stream);
    extern wint_t ungetwc(wint_t __wc, __FILE *__stream);
    extern wint_t getwc_unlocked(__FILE *__stream);
    extern wint_t getwchar_unlocked();
    extern wint_t fgetwc_unlocked(__FILE *__stream);
    extern wint_t fputwc_unlocked(wchar_t __wc, __FILE *__stream);
    extern wint_t putwc_unlocked(wchar_t __wc, __FILE *__stream);
    extern wint_t putwchar_unlocked(wchar_t __wc);
    extern wchar_t *fgetws_unlocked(wchar_t *__restrict __ws, int __n, __FILE *__restrict __stream);
    extern int fputws_unlocked(const wchar_t *__restrict __ws, __FILE *__restrict __stream);
    extern size_t wcsftime(wchar_t *__restrict __s, size_t __maxsize, const wchar_t *__restrict __format, const struct tm *__restrict __tp) throw();
    extern size_t wcsftime_l(wchar_t *__restrict __s, size_t __maxsize, const wchar_t *__restrict __format, const struct tm *__restrict __tp, locale_t __loc) throw();
}
namespace std {
    using ::mbstate_t;
}
extern "C++" {
    namespace std {
        using ::wint_t;
        using ::btowc;
        using ::fgetwc;
        using ::fgetws;
        using ::fputwc;
        using ::fputws;
        using ::fwide;
        using ::fwprintf;
        using ::fwscanf;
        using ::getwc;
        using ::getwchar;
        using ::mbrlen;
        using ::mbrtowc;
        using ::mbsinit;
        using ::mbsrtowcs;
        using ::putwc;
        using ::putwchar;
        using ::swprintf;
        using ::swscanf;
        using ::ungetwc;
        using ::vfwprintf;
        using ::vfwscanf;
        using ::vswprintf;
        using ::vswscanf;
        using ::vwprintf;
        using ::vwscanf;
        using ::wcrtomb;
        using ::wcscat;
        using ::wcscmp;
        using ::wcscoll;
        using ::wcscpy;
        using ::wcscspn;
        using ::wcsftime;
        using ::wcslen;
        using ::wcsncat;
        using ::wcsncmp;
        using ::wcsncpy;
        using ::wcsrtombs;
        using ::wcsspn;
        using ::wcstod;
        using ::wcstof;
        using ::wcstok;
        using ::wcstol;
        using ::wcstoul;
        using ::wcsxfrm;
        using ::wctob;
        using ::wmemcmp;
        using ::wmemcpy;
        using ::wmemmove;
        using ::wmemset;
        using ::wprintf;
        using ::wscanf;
        using ::wcschr;
        using ::wcspbrk;
        using ::wcsrchr;
        using ::wcsstr;
        using ::wmemchr;
        inline wchar_t *wcschr(wchar_t *__p, wchar_t __c)         {
            return wcschr(const_cast<const wchar_t *>(__p), __c);
        }
        inline wchar_t *wcspbrk(wchar_t *__s1, const wchar_t *__s2)         {
            return wcspbrk(const_cast<const wchar_t *>(__s1), __s2);
        }
        inline wchar_t *wcsrchr(wchar_t *__p, wchar_t __c)         {
            return wcsrchr(const_cast<const wchar_t *>(__p), __c);
        }
        inline wchar_t *wcsstr(wchar_t *__s1, const wchar_t *__s2)         {
            return wcsstr(const_cast<const wchar_t *>(__s1), __s2);
        }
        inline wchar_t *wmemchr(wchar_t *__p, wchar_t __c, std::size_t __n)         {
            return wmemchr(const_cast<const wchar_t *>(__p), __c, __n);
        }
    }
}
namespace __gnu_cxx {
    using ::wcstold;
    using ::wcstoll;
    using ::wcstoull;
}
namespace std {
    using ::__gnu_cxx::wcstold;
    using ::__gnu_cxx::wcstoll;
    using ::__gnu_cxx::wcstoull;
}
namespace std {
    using std::wcstof;
    using std::vfwscanf;
    using std::vswscanf;
    using std::vwscanf;
    using std::wcstold;
    using std::wcstoll;
    using std::wcstoull;
}
namespace std {
    typedef long streamoff;
    typedef std::ptrdiff_t streamsize;
    template <typename _StateT> class fpos {
    private:
        std::streamoff _M_off;
        _StateT _M_state;
    public:
        fpos<_StateT>() : _M_off(0), _M_state()         {
        }
        fpos<_StateT>(std::streamoff __off) : _M_off(__off), _M_state()         {
        }
        fpos<_StateT>(const fpos<_StateT> &) = default
        fpos<_StateT> &operator=(const fpos<_StateT> &) = default
        ~fpos<_StateT>() = default
        operator streamoff() const         {
            return this->_M_off;
        }
        void state(_StateT __st)         {
            this->_M_state = __st;
        }
        _StateT state() const         {
            return this->_M_state;
        }
        fpos<_StateT> &operator+=(std::streamoff __off)         {
            this->_M_off += __off;
            return *this;
        }
        fpos<_StateT> &operator-=(std::streamoff __off)         {
            this->_M_off -= __off;
            return *this;
        }
        fpos<_StateT> operator+(std::streamoff __off) const         {
            fpos<_StateT> __pos(*this);
            __pos += __off;
            return __pos;
        }
        fpos<_StateT> operator-(std::streamoff __off) const         {
            fpos<_StateT> __pos(*this);
            __pos -= __off;
            return __pos;
        }
        std::streamoff operator-(const fpos<_StateT> &__other) const         {
            return this->_M_off - __other._M_off;
        }
    };
    template <typename _StateT> inline bool operator==(const fpos<_StateT> &__lhs, const fpos<_StateT> &__rhs)     {
        return std::streamoff(__lhs) == std::streamoff(__rhs);
    }
    template <typename _StateT> inline bool operator!=(const fpos<_StateT> &__lhs, const fpos<_StateT> &__rhs)     {
        return std::streamoff(__lhs) != std::streamoff(__rhs);
    }
    typedef fpos<mbstate_t> streampos;
    typedef fpos<mbstate_t> wstreampos;
    typedef fpos<mbstate_t> u16streampos;
    typedef fpos<mbstate_t> u32streampos;
}
namespace std {
    class ios_base;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ios;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_streambuf;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_istream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ostream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_iostream;
    inline namespace __cxx11 {
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_stringbuf;
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_istringstream;
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_ostringstream;
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_stringstream;
    }
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_filebuf;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ifstream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ofstream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_fstream;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class istreambuf_iterator;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class ostreambuf_iterator;
    typedef basic_ios<char> ios;
    typedef basic_streambuf<char> streambuf;
    typedef basic_istream<char> istream;
    typedef basic_ostream<char> ostream;
    typedef basic_iostream<char> iostream;
    typedef basic_stringbuf<char> stringbuf;
    typedef basic_istringstream<char> istringstream;
    typedef basic_ostringstream<char> ostringstream;
    typedef basic_stringstream<char> stringstream;
    typedef basic_filebuf<char> filebuf;
    typedef basic_ifstream<char> ifstream;
    typedef basic_ofstream<char> ofstream;
    typedef basic_fstream<char> fstream;
    typedef basic_ios<wchar_t> wios;
    typedef basic_streambuf<wchar_t> wstreambuf;
    typedef basic_istream<wchar_t> wistream;
    typedef basic_ostream<wchar_t> wostream;
    typedef basic_iostream<wchar_t> wiostream;
    typedef basic_stringbuf<wchar_t> wstringbuf;
    typedef basic_istringstream<wchar_t> wistringstream;
    typedef basic_ostringstream<wchar_t> wostringstream;
    typedef basic_stringstream<wchar_t> wstringstream;
    typedef basic_filebuf<wchar_t> wfilebuf;
    typedef basic_ifstream<wchar_t> wifstream;
    typedef basic_ofstream<wchar_t> wofstream;
    typedef basic_fstream<wchar_t> wfstream;
}
extern "C++" {
    namespace std {
        class exception {
        public:
            exception() noexcept             {
            }
            virtual ~exception() noexcept;
            exception(const std::exception &) = default
            std::exception &operator=(const std::exception &) = default
            exception(std::exception &&) = default
            std::exception &operator=(std::exception &&) = default
            virtual const char *what() const noexcept;
        };
    }
}
extern "C++" {
    namespace std {
        class bad_exception : public std::exception {
        public:
            bad_exception() noexcept : std::exception()             {
            }
            virtual ~bad_exception() noexcept;
            virtual const char *what() const noexcept;
        };
        typedef void (*terminate_handler)();
        typedef void (*unexpected_handler)();
        std::terminate_handler set_terminate(std::terminate_handler) noexcept;
        std::terminate_handler get_terminate() noexcept;
        void terminate() noexcept;
        std::unexpected_handler set_unexpected(std::unexpected_handler) noexcept;
        std::unexpected_handler get_unexpected() noexcept;
        void unexpected();
        bool uncaught_exception() noexcept __attribute__((pure));
        int uncaught_exceptions() noexcept __attribute__((pure));
    }
    namespace __gnu_cxx {
        void __verbose_terminate_handler();
    }
}
typedef long ptrdiff_t;
typedef struct {
    long long __clang_max_align_nonce1 __attribute__((aligned(__alignof(long long))));
    long double __clang_max_align_nonce2 __attribute__((aligned(__alignof(long double))));
} max_align_t;
namespace std {
    class type_info;
}
namespace __cxxabiv1 {
    struct __cxa_refcounted_exception;
    extern "C" {
        void *__cxa_allocate_exception(size_t) noexcept;
        void __cxa_free_exception(void *) noexcept;
        __cxxabiv1::__cxa_refcounted_exception *__cxa_init_primary_exception(void *object, std::type_info *tinfo, void (*dest)(void *)) noexcept;
    }
}
namespace std {
    std::size_t _Hash_bytes(const void *__ptr, std::size_t __len, std::size_t __seed);
    std::size_t _Fnv_hash_bytes(const void *__ptr, std::size_t __len, std::size_t __seed);
}
extern "C++" {
    namespace __cxxabiv1 {
        class __class_type_info;
    }
    namespace std {
        class type_info {
        public:
            virtual ~type_info() noexcept;
            const char *name() const noexcept             {
                return this->__name[0] == '*' ? this->__name + 1 : this->__name;
            }
            bool before(const std::type_info &__arg) const noexcept             {
                return (this->__name[0] == '*' && __arg.__name[0] == '*') ? this->__name < __arg.__name : __builtin_strcmp(this->__name, __arg.__name) < 0;
            }
            bool operator==(const std::type_info &__arg) const noexcept             {
                return ((this->__name == __arg.__name) || (this->__name[0] != '*' && __builtin_strcmp(this->__name, __arg.__name) == 0));
            }
            bool operator!=(const std::type_info &__arg) const noexcept             {
                return !this->operator==(__arg);
            }
            std::size_t hash_code() const noexcept             {
                return _Hash_bytes(this->name(), __builtin_strlen(this->name()), static_cast<std::size_t>(3339675911UL));
            }
            virtual bool __is_pointer_p() const;
            virtual bool __is_function_p() const;
            virtual bool __do_catch(const std::type_info *__thr_type, void **__thr_obj, unsigned int __outer) const;
            virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target, void **__obj_ptr) const;
        protected:
            const char *__name;
            explicit type_info(const char *__n) : __name(__n)             {
            }
        private:
            std::type_info &operator=(const std::type_info &);
            type_info(const std::type_info &);
        };
        class bad_cast : public std::exception {
        public:
            bad_cast() noexcept : std::exception()             {
            }
            virtual ~bad_cast() noexcept;
            virtual const char *what() const noexcept;
        };
        class bad_typeid : public std::exception {
        public:
            bad_typeid() noexcept : std::exception()             {
            }
            virtual ~bad_typeid() noexcept;
            virtual const char *what() const noexcept;
        };
    }
}
extern "C++" {
    namespace std {
        class bad_alloc : public std::exception {
        public:
            bad_alloc() throw() : std::exception()             {
            }
            bad_alloc(const std::bad_alloc &) = default
            std::bad_alloc &operator=(const std::bad_alloc &) = default
            virtual ~bad_alloc() throw();
            virtual const char *what() const throw();
        };
        class bad_array_new_length : public std::bad_alloc {
        public:
            bad_array_new_length() throw() : std::bad_alloc()             {
            }
            virtual ~bad_array_new_length() throw();
            virtual const char *what() const throw();
        };
        struct nothrow_t {
            explicit nothrow_t() = default
        };
        extern const std::nothrow_t nothrow;
        typedef void (*new_handler)();
        std::new_handler set_new_handler(std::new_handler) throw();
        std::new_handler get_new_handler() noexcept;
    }
    void *operator new(std::size_t);
    void *operator new[](std::size_t);
    void operator delete(void *) noexcept;
    void operator delete[](void *) noexcept;
    void *operator new(std::size_t, const std::nothrow_t &) noexcept __attribute__((malloc));
    void *operator new[](std::size_t, const std::nothrow_t &) noexcept __attribute__((malloc));
    void operator delete(void *, const std::nothrow_t &) noexcept;
    void operator delete[](void *, const std::nothrow_t &) noexcept;
    inline void *operator new(std::size_t, void *__p) noexcept     {
        return __p;
    }
    inline void *operator new[](std::size_t, void *__p) noexcept     {
        return __p;
    }
    inline void operator delete(void *, void *) noexcept     {
    }
    inline void operator delete[](void *, void *) noexcept     {
    }
}
extern "C++" {
    namespace std {
        class type_info;
        namespace __exception_ptr {
            class exception_ptr;
        }
        using __exception_ptr::exception_ptr;
        std::__exception_ptr::exception_ptr current_exception() noexcept;
        template <typename _Ex> std::__exception_ptr::exception_ptr make_exception_ptr(_Ex) noexcept;
        void rethrow_exception(std::__exception_ptr::exception_ptr);
        namespace __exception_ptr {
            using std::rethrow_exception;
            class exception_ptr {
                void *_M_exception_object;
                explicit exception_ptr(void *__e) noexcept;
                void _M_addref() noexcept;
                void _M_release() noexcept;
                void *_M_get() const noexcept __attribute__((pure));
                friend std::__exception_ptr::exception_ptr std::current_exception() noexcept;
                friend void std::rethrow_exception(std::__exception_ptr::exception_ptr);
                friend template <typename _Ex> std::__exception_ptr::exception_ptr std::make_exception_ptr(_Ex) noexcept;
            public:
                exception_ptr() noexcept;
                exception_ptr(const std::__exception_ptr::exception_ptr &) noexcept;
                exception_ptr(std::nullptr_t) noexcept : _M_exception_object(0)                 {
                }
                exception_ptr(std::__exception_ptr::exception_ptr &&__o) noexcept : _M_exception_object(__o._M_exception_object)                 {
                    __o._M_exception_object = 0;
                }
                std::__exception_ptr::exception_ptr &operator=(const std::__exception_ptr::exception_ptr &) noexcept;
                std::__exception_ptr::exception_ptr &operator=(std::__exception_ptr::exception_ptr &&__o) noexcept                 {
                    std::__exception_ptr::exception_ptr(static_cast<std::__exception_ptr::exception_ptr &&>(__o)).swap(*this);
                    return *this;
                }
                ~exception_ptr() noexcept;
                void swap(std::__exception_ptr::exception_ptr &) noexcept;
                explicit operator bool() const                 {
                    return this->_M_exception_object;
                }
                friend bool operator==(const std::__exception_ptr::exception_ptr &, const std::__exception_ptr::exception_ptr &) noexcept __attribute__((pure));
                const class std::type_info *__cxa_exception_type() const noexcept __attribute__((pure));
            };
            bool operator==(const std::__exception_ptr::exception_ptr &, const std::__exception_ptr::exception_ptr &) noexcept __attribute__((pure));
            bool operator!=(const std::__exception_ptr::exception_ptr &, const std::__exception_ptr::exception_ptr &) noexcept __attribute__((pure));
            inline void swap(std::__exception_ptr::exception_ptr &__lhs, std::__exception_ptr::exception_ptr &__rhs)             {
                __lhs.swap(__rhs);
            }
            template <typename _Ex> inline void __dest_thunk(void *__x)             {
                static_cast<_Ex *>(__x)->~_Ex();
            }
        }
        template <typename _Ex> std::__exception_ptr::exception_ptr make_exception_ptr(_Ex __ex) noexcept         {
            void *__e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
            (void)__cxxabiv1::__cxa_init_primary_exception(__e, const_cast<std::type_info *>(&typeid(__ex)), __exception_ptr::__dest_thunk<_Ex>);
            try {
                ::new (__e) _Ex((__ex));
                return std::__exception_ptr::exception_ptr(__e);
            } catch (...) {
                __cxxabiv1::__cxa_free_exception(__e);
                return current_exception();
            }
        }
    }
}
namespace std {
    template <typename _Tp> inline constexpr _Tp *__addressof(_Tp &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr char *__addressof<char>(char &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr const char *__addressof<const char>(const char &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr wchar_t *__addressof<wchar_t>(wchar_t &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr const wchar_t *__addressof<const wchar_t>(const wchar_t &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr char16_t *__addressof<char16_t>(char16_t &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr const char16_t *__addressof<const char16_t>(const char16_t &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr char32_t *__addressof<char32_t>(char32_t &__r) noexcept     {
        return __builtin_addressof(__r);
    }
    template<> inline constexpr const char32_t *__addressof<const char32_t>(const char32_t &__r) noexcept     {
        return __builtin_addressof(__r);
    }
}
namespace std {
    template <typename _Tp> constexpr _Tp &&forward(typename std::remove_reference<_Tp>::type &__t) noexcept     {
        return static_cast<_Tp &&>(__t);
    }
    template <typename _Tp> constexpr _Tp &&forward(typename std::remove_reference<_Tp>::type &&__t) noexcept     {
        static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument substituting _Tp is an lvalue reference type");
        return static_cast<_Tp &&>(__t);
    }
    template <typename _Tp> constexpr typename std::remove_reference<_Tp>::type &&move(_Tp &&__t) noexcept     {
        return static_cast<typename std::remove_reference<_Tp>::type &&>(__t);
    }
    template<> constexpr typename std::remove_reference<allocator<char> &>::type &&move<std::allocator<char> &>(std::allocator<char> &__t) noexcept     {
        return static_cast<typename std::remove_reference<allocator<char> &>::type &&>(__t);
    }
    template<> constexpr typename std::remove_reference<allocator<wchar_t> &>::type &&move<std::allocator<wchar_t> &>(std::allocator<wchar_t> &__t) noexcept     {
        return static_cast<typename std::remove_reference<allocator<wchar_t> &>::type &&>(__t);
    }
    template<> constexpr typename std::remove_reference<allocator<char16_t> &>::type &&move<std::allocator<char16_t> &>(std::allocator<char16_t> &__t) noexcept     {
        return static_cast<typename std::remove_reference<allocator<char16_t> &>::type &&>(__t);
    }
    template<> constexpr typename std::remove_reference<allocator<char32_t> &>::type &&move<std::allocator<char32_t> &>(std::allocator<char32_t> &__t) noexcept     {
        return static_cast<typename std::remove_reference<allocator<char32_t> &>::type &&>(__t);
    }
    template<> constexpr typename std::remove_reference<basic_string<char> &>::type &&move<std::__cxx11::basic_string<char> &>(std::__cxx11::basic_string<char> &__t) noexcept     {
        return static_cast<typename std::remove_reference<basic_string<char> &>::type &&>(__t);
    }
    template <typename _Tp> struct __move_if_noexcept_cond : public __and_<__not_<is_nothrow_move_constructible<_Tp> >, is_copy_constructible<_Tp> >::type {
    };
    template <typename _Tp> constexpr typename conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp &, _Tp &&>::type move_if_noexcept(_Tp &__x) noexcept     {
        return std::move(__x);
    }
    template <typename _Tp> inline _Tp *addressof(_Tp &__r) noexcept     {
        return std::__addressof(__r);
    }
    template<> inline char *addressof<char>(char &__r) noexcept     {
        return std::__addressof(__r);
    }
    template<> inline const char *addressof<const char>(const char &__r) noexcept     {
        return std::__addressof(__r);
    }
    template<> inline wchar_t *addressof<wchar_t>(wchar_t &__r) noexcept     {
        return std::__addressof(__r);
    }
    template<> inline const wchar_t *addressof<const wchar_t>(const wchar_t &__r) noexcept     {
        return std::__addressof(__r);
    }
    template<> inline char16_t *addressof<char16_t>(char16_t &__r) noexcept     {
        return std::__addressof(__r);
    }
    template<> inline const char16_t *addressof<const char16_t>(const char16_t &__r) noexcept     {
        return std::__addressof(__r);
    }
    template<> inline char32_t *addressof<char32_t>(char32_t &__r) noexcept     {
        return std::__addressof(__r);
    }
    template<> inline const char32_t *addressof<const char32_t>(const char32_t &__r) noexcept     {
        return std::__addressof(__r);
    }
    template <typename _Tp> const _Tp *addressof(const _Tp &&) = delete    template<> const char *addressof<char>(const char &&) = delete    template<> const wchar_t *addressof<wchar_t>(const wchar_t &&) = delete    template<> const char16_t *addressof<char16_t>(const char16_t &&) = delete    template<> const char32_t *addressof<char32_t>(const char32_t &&) = delete
    template <typename _Tp, typename _Up = _Tp> inline _Tp __exchange(_Tp &__obj, _Up &&__new_val)     {
        _Tp __old_val = std::move(__obj);
        __obj = std::forward<_Up>(__new_val);
        return __old_val;
    }
    template <typename _Tp> inline typename enable_if<__and_<__not_<__is_tuple_like<_Tp> >, is_move_constructible<_Tp>, is_move_assignable<_Tp> >::value>::type swap(_Tp &__a, _Tp &__b) noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp> >::valueswap(_Tp &__a, _Tp &__b) noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp> >::value)     {
        _Tp __tmp = std::move(__a);
        __a = std::move(__b);
        __b = std::move(__tmp);
    }
    template <typename _Tp, std::size_t _Nm> inline typename enable_if<__is_swappable<_Tp>::value>::type swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::valueswap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(__is_nothrow_swappable<_Tp>::value)     {
        for (std::size_t __n = 0; __n < _Nm; ++__n)
            swap(__a[__n], __b[__n]);
    }
}
extern "C++" {
    namespace std {
        class nested_exception {
            std::__exception_ptr::exception_ptr _M_ptr;
        public:
            nested_exception() noexcept : _M_ptr(current_exception())             {
            }
            nested_exception(const std::nested_exception &) noexcept = default
            std::nested_exception &operator=(const std::nested_exception &) noexcept = default
            virtual ~nested_exception() noexcept;
            void rethrow_nested() const [[noreturn]]             {
                if (this->_M_ptr)
                    rethrow_exception(this->_M_ptr);
                std::terminate();
            }
            std::__exception_ptr::exception_ptr nested_ptr() const noexcept             {
                return this->_M_ptr;
            }
        };
        template <typename _Except> struct _Nested_exception : public _Except, public std::nested_exception {
            explicit _Nested_exception<_Except>(const _Except &__ex) : _Except(__ex)             {
            }
            explicit _Nested_exception<_Except>(_Except &&__ex) : _Except(static_cast<_Except &&>(__ex))             {
            }
        };
        template <typename _Tp> inline void __throw_with_nested_impl(_Tp &&__t, std::true_type) [[noreturn]]         {
            using _Up = typename remove_reference<_Tp>::type;
            throw _Nested_exception<_Up>({std::forward<_Tp>(__t)});
        }
        template <typename _Tp> inline void __throw_with_nested_impl(_Tp &&__t, std::false_type) [[noreturn]]         {
            throw std::forward<_Tp>(__t);
        }
        template <typename _Tp> inline void throw_with_nested(_Tp &&__t) [[noreturn]]         {
            using _Up = typename decay<_Tp>::type;
            using _CopyConstructible = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up> >;
            static_assert(_CopyConstructible::value, "throw_with_nested argument must be CopyConstructible");
            using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>, __not_<is_base_of<std::nested_exception, _Up> > >;
            std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest({}));
        }
        template <typename _Tp> using __rethrow_if_nested_cond = typename enable_if<__and_<is_polymorphic<_Tp>, __or_<__not_<is_base_of<nested_exception, _Tp> >, is_convertible<_Tp *, nested_exception *> > >::value>::type;
        template <typename _Ex> inline __rethrow_if_nested_cond<_Ex> __rethrow_if_nested_impl(const _Ex *__ptr)         {
            if (auto __ne_ptr = dynamic_cast<const std::nested_exception *>(__ptr))
                __ne_ptr->rethrow_nested();
        }
        inline void __rethrow_if_nested_impl(const void *)         {
        }
        template <typename _Ex> inline void rethrow_if_nested(const _Ex &__ex)         {
            std::__rethrow_if_nested_impl(std::__addressof(__ex));
        }
    }
}
namespace std {
    void __throw_bad_exception();
    void __throw_bad_alloc();
    void __throw_bad_cast();
    void __throw_bad_typeid();
    void __throw_logic_error(const char *);
    void __throw_domain_error(const char *);
    void __throw_invalid_argument(const char *);
    void __throw_length_error(const char *);
    void __throw_out_of_range(const char *);
    void __throw_out_of_range_fmt(const char *, ...);
    void __throw_runtime_error(const char *);
    void __throw_range_error(const char *);
    void __throw_overflow_error(const char *);
    void __throw_underflow_error(const char *);
    void __throw_ios_failure(const char *);
    void __throw_ios_failure(const char *, int);
    void __throw_system_error(int);
    void __throw_future_error(int);
    void __throw_bad_function_call();
}
extern "C++" {
    namespace std {
        struct __true_type {
        };
        struct __false_type {
        };
        template <bool> struct __truth_type {
            typedef std::__false_type __type;
        };
        template<> struct __truth_type<true> {
            typedef std::__true_type __type;
        };
        template <class _Sp, class _Tp> struct __traitor {
            enum  {
                __value = bool(_Sp::__value) || bool(_Tp::__value)
            };
            typedef typename __truth_type<__value>::__type __type;
        };
        template <typename, typename> struct __are_same {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __are_same<float, float> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
template<> struct __are_same<float, double> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __are_same<double, float> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __are_same<double, double> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
template<> struct __are_same<long double, float> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __are_same<long double, double> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template <typename _Tp> struct __are_same<_Tp, _Tp> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_void {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_void<void> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_integer {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<long double> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<double> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<float> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<char *> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<wchar_t *> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<const char *> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<const wchar_t *> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<const char16_t *> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
template<> struct __is_integer<const char32_t *> {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_integer<bool> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<signed char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<wchar_t> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<char16_t> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<char32_t> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<short> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned short> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<int> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned int> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<long> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned long> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<long long> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned long long> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<__int128> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_integer<unsigned __int128> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_floating {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_floating<float> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_floating<double> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_floating<long double> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_pointer {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template <typename _Tp> struct __is_pointer<_Tp *> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_arithmetic : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> > {
        };
        template <typename _Tp> struct __is_scalar : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> > {
        };
        template <typename _Tp> struct __is_char {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_char<char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_char<wchar_t> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_byte {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template<> struct __is_byte<char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_byte<signed char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template<> struct __is_byte<unsigned char> {
            enum  {
                __value = 1
            };
            typedef std::__true_type __type;
        };
        template <typename _Tp> struct __is_move_iterator {
            enum  {
                __value = 0
            };
            typedef std::__false_type __type;
        };
        template <typename _Iterator> inline _Iterator __miter_base(_Iterator __it)         {
            return __it;
        }
    }
}
extern "C++" {
    namespace __gnu_cxx {
        template <bool, typename> struct __enable_if {
        };
        template <typename _Tp> struct __enable_if<true, _Tp> {
            typedef _Tp __type;
        };
        template <bool _Cond, typename _Iftrue, typename _Iffalse> struct __conditional_type {
            typedef _Iftrue __type;
        };
template<> struct __conditional_type<true, __gnu_cxx::__numeric_traits_integer<int>, __gnu_cxx::__numeric_traits_floating<int>> {
            typedef __gnu_cxx::__numeric_traits_integer<int> __type;
        };
template<> struct __conditional_type<false, __gnu_cxx::__numeric_traits_integer<float>, __gnu_cxx::__numeric_traits_floating<float>> {
            typedef __gnu_cxx::__numeric_traits_floating<float> __type;
        };
template<> struct __conditional_type<false, __gnu_cxx::__numeric_traits_integer<double>, __gnu_cxx::__numeric_traits_floating<double>> {
            typedef __gnu_cxx::__numeric_traits_floating<double> __type;
        };
template<> struct __conditional_type<false, __gnu_cxx::__numeric_traits_integer<long double>, __gnu_cxx::__numeric_traits_floating<long double>> {
            typedef __gnu_cxx::__numeric_traits_floating<long double> __type;
        };
template<> struct __conditional_type<true, __gnu_cxx::__numeric_traits_integer<unsigned long>, __gnu_cxx::__numeric_traits_floating<unsigned long>> {
            typedef __gnu_cxx::__numeric_traits_integer<unsigned long> __type;
        };
template<> struct __conditional_type<true, __gnu_cxx::__numeric_traits_integer<char>, __gnu_cxx::__numeric_traits_floating<char>> {
            typedef __gnu_cxx::__numeric_traits_integer<char> __type;
        };
template<> struct __conditional_type<true, unsigned long, unsigned long long> {
            typedef unsigned long __type;
        };
template<> struct __conditional_type<true, __gnu_cxx::__numeric_traits_integer<short>, __gnu_cxx::__numeric_traits_floating<short>> {
            typedef __gnu_cxx::__numeric_traits_integer<short> __type;
        };
template<> struct __conditional_type<true, __gnu_cxx::__numeric_traits_integer<long>, __gnu_cxx::__numeric_traits_floating<long>> {
            typedef __gnu_cxx::__numeric_traits_integer<long> __type;
        };
        template <typename _Iftrue, typename _Iffalse> struct __conditional_type<false, _Iftrue, _Iffalse> {
            typedef _Iffalse __type;
        };
        template <typename _Tp> struct __add_unsigned {
        private:
            typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
        public:
            typedef typename __if_type::__type __type;
        };
        template<> struct __add_unsigned<char> {
            typedef unsigned char __type;
        };
        template<> struct __add_unsigned<signed char> {
            typedef unsigned char __type;
        };
        template<> struct __add_unsigned<short> {
            typedef unsigned short __type;
        };
        template<> struct __add_unsigned<int> {
            typedef unsigned int __type;
        };
        template<> struct __add_unsigned<long> {
            typedef unsigned long __type;
        };
        template<> struct __add_unsigned<long long> {
            typedef unsigned long long __type;
        };
        template<> struct __add_unsigned<bool>;
        template<> struct __add_unsigned<wchar_t>;
        template <typename _Tp> struct __remove_unsigned {
        private:
            typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
        public:
            typedef typename __if_type::__type __type;
        };
        template<> struct __remove_unsigned<char> {
            typedef signed char __type;
        };
        template<> struct __remove_unsigned<unsigned char> {
            typedef signed char __type;
        };
        template<> struct __remove_unsigned<unsigned short> {
            typedef short __type;
        };
        template<> struct __remove_unsigned<unsigned int> {
            typedef int __type;
        };
        template<> struct __remove_unsigned<unsigned long> {
            typedef long __type;
        };
        template<> struct __remove_unsigned<unsigned long long> {
            typedef long long __type;
        };
        template<> struct __remove_unsigned<bool>;
        template<> struct __remove_unsigned<wchar_t>;
        template <typename _Type> inline bool __is_null_pointer(_Type *__ptr)         {
            return __ptr == 0;
        }
        template<> inline bool __is_null_pointer<char>(char *__ptr)         {
            return __ptr == 0;
        }
        template<> inline bool __is_null_pointer<wchar_t>(wchar_t *__ptr)         {
            return __ptr == 0;
        }
        template<> inline bool __is_null_pointer<const char>(const char *__ptr)         {
            return __ptr == 0;
        }
        template<> inline bool __is_null_pointer<const wchar_t>(const wchar_t *__ptr)         {
            return __ptr == 0;
        }
        template<> inline bool __is_null_pointer<const char16_t>(const char16_t *__ptr)         {
            return __ptr == 0;
        }
        template<> inline bool __is_null_pointer<const char32_t>(const char32_t *__ptr)         {
            return __ptr == 0;
        }
        template <typename _Type> inline bool __is_null_pointer(_Type)         {
            return false;
        }
        template<> inline bool __is_null_pointer<char *>(char *)        template<> inline bool __is_null_pointer<wchar_t *>(wchar_t *)        template<> inline bool __is_null_pointer<const char *>(const char *)        template<> inline bool __is_null_pointer<const wchar_t *>(const wchar_t *)        template<> inline bool __is_null_pointer<const char16_t *>(const char16_t *)        template<> inline bool __is_null_pointer<const char32_t *>(const char32_t *)        inline bool __is_null_pointer(std::nullptr_t)         {
            return true;
        }
        template <typename _Tp, bool = std::__is_integer<_Tp>::__value> struct __promote {
            typedef double __type;
        };
        template <typename _Tp> struct __promote<_Tp, false> {
        };
        template<> struct __promote<long double> {
            typedef long double __type;
        };
        template<> struct __promote<double> {
            typedef double __type;
        };
        template<> struct __promote<float> {
            typedef float __type;
        };
        template <typename _Tp, typename _Up, typename _Tp2 = typename __promote<_Tp>::__type, typename _Up2 = typename __promote<_Up>::__type> struct __promote_2 {
            typedef typeof (_Tp2() + _Up2()) __type;
        };
        template <typename _Tp, typename _Up, typename _Vp, typename _Tp2 = typename __promote<_Tp>::__type, typename _Up2 = typename __promote<_Up>::__type, typename _Vp2 = typename __promote<_Vp>::__type> struct __promote_3 {
            typedef typeof (_Tp2() + _Up2() + _Vp2()) __type;
        };
        template <typename _Tp, typename _Up, typename _Vp, typename _Wp, typename _Tp2 = typename __promote<_Tp>::__type, typename _Up2 = typename __promote<_Up>::__type, typename _Vp2 = typename __promote<_Vp>::__type, typename _Wp2 = typename __promote<_Wp>::__type> struct __promote_4 {
            typedef typeof (_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
        };
    }
}
namespace __gnu_cxx {
    template <typename _Value> struct __numeric_traits_integer {
        static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
        static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);
        static const bool __is_signed = ((_Value)(-1) < 0);
        static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };
template<> struct __numeric_traits_integer<int> {
        static const int __min = (((int)(-1) < 0) ? (int)1 << (sizeof(int) * 8 - ((int)(-1) < 0)) : (int)0);
        static const int __max = (((int)(-1) < 0) ? (((((int)1 << ((sizeof(int) * 8 - ((int)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(int)0);
        static const bool __is_signed = ((int)(-1) < 0);
        static const int __digits = (sizeof(int) * 8 - ((int)(-1) < 0));
    };
template<> struct __numeric_traits_integer<unsigned long> {
        static const unsigned long __min = (((unsigned long)(-1) < 0) ? (unsigned long)1 << (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) : (unsigned long)0);
        static const unsigned long __max = (((unsigned long)(-1) < 0) ? (((((unsigned long)1 << ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned long)0);
        static const bool __is_signed = ((unsigned long)(-1) < 0);
        static const int __digits = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
    };
template<> struct __numeric_traits_integer<char> {
        static const char __min = (((char)(-1) < 0) ? (char)1 << (sizeof(char) * 8 - ((char)(-1) < 0)) : (char)0);
        static const char __max = (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0);
        static const bool __is_signed = ((char)(-1) < 0);
        static const int __digits = (sizeof(char) * 8 - ((char)(-1) < 0));
    };
template<> struct __numeric_traits_integer<short> {
        static const short __min = (((short)(-1) < 0) ? (short)1 << (sizeof(short) * 8 - ((short)(-1) < 0)) : (short)0);
        static const short __max = (((short)(-1) < 0) ? (((((short)1 << ((sizeof(short) * 8 - ((short)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(short)0);
        static const bool __is_signed = ((short)(-1) < 0);
        static const int __digits = (sizeof(short) * 8 - ((short)(-1) < 0));
    };
template<> struct __numeric_traits_integer<long> {
        static const long __min = (((long)(-1) < 0) ? (long)1 << (sizeof(long) * 8 - ((long)(-1) < 0)) : (long)0);
        static const long __max = (((long)(-1) < 0) ? (((((long)1 << ((sizeof(long) * 8 - ((long)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(long)0);
        static const bool __is_signed = ((long)(-1) < 0);
        static const int __digits = (sizeof(long) * 8 - ((long)(-1) < 0));
    };
    const _Value __min;
    const _Value __max;
    const bool __is_signed;
    const int __digits;
    template <typename _Value> struct __numeric_traits_floating {
        static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);
        static const bool __is_signed = true;
        static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
        static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };
template<> struct __numeric_traits_floating<float> {
        static const int __max_digits10 = (2 + (std::__are_same<float, float>::__value ? 24 : std::__are_same<float, double>::__value ? 53 : 64) * 643L / 2136);
        static const bool __is_signed = true;
        static const int __digits10 = (std::__are_same<float, float>::__value ? 6 : std::__are_same<float, double>::__value ? 15 : 18);
        static const int __max_exponent10 = (std::__are_same<float, float>::__value ? 38 : std::__are_same<float, double>::__value ? 308 : 4932);
    };
template<> struct __numeric_traits_floating<double> {
        static const int __max_digits10 = (2 + (std::__are_same<double, float>::__value ? 24 : std::__are_same<double, double>::__value ? 53 : 64) * 643L / 2136);
        static const bool __is_signed = true;
        static const int __digits10 = (std::__are_same<double, float>::__value ? 6 : std::__are_same<double, double>::__value ? 15 : 18);
        static const int __max_exponent10 = (std::__are_same<double, float>::__value ? 38 : std::__are_same<double, double>::__value ? 308 : 4932);
    };
template<> struct __numeric_traits_floating<long double> {
        static const int __max_digits10 = (2 + (std::__are_same<long double, float>::__value ? 24 : std::__are_same<long double, double>::__value ? 53 : 64) * 643L / 2136);
        static const bool __is_signed = true;
        static const int __digits10 = (std::__are_same<long double, float>::__value ? 6 : std::__are_same<long double, double>::__value ? 15 : 18);
        static const int __max_exponent10 = (std::__are_same<long double, float>::__value ? 38 : std::__are_same<long double, double>::__value ? 308 : 4932);
    };
    const int __max_digits10;
    const bool __is_signed;
    const int __digits10;
    const int __max_exponent10;
    template <typename _Value> struct __numeric_traits : public __conditional_type<std::__is_integer<_Value>::__value, __numeric_traits_integer<_Value>, __numeric_traits_floating<_Value> >::__type {
    };
template<> struct __numeric_traits<int> : public __conditional_type<std::__is_integer<int>::__value, __numeric_traits_integer<int>, __numeric_traits_floating<int> >::__type {
    };
template<> struct __numeric_traits<float> : public __conditional_type<std::__is_integer<float>::__value, __numeric_traits_integer<float>, __numeric_traits_floating<float> >::__type {
    };
template<> struct __numeric_traits<double> : public __conditional_type<std::__is_integer<double>::__value, __numeric_traits_integer<double>, __numeric_traits_floating<double> >::__type {
    };
template<> struct __numeric_traits<long double> : public __conditional_type<std::__is_integer<long double>::__value, __numeric_traits_integer<long double>, __numeric_traits_floating<long double> >::__type {
    };
template<> struct __numeric_traits<unsigned long> : public __conditional_type<std::__is_integer<unsigned long>::__value, __numeric_traits_integer<unsigned long>, __numeric_traits_floating<unsigned long> >::__type {
    };
template<> struct __numeric_traits<char> : public __conditional_type<std::__is_integer<char>::__value, __numeric_traits_integer<char>, __numeric_traits_floating<char> >::__type {
    };
template<> struct __numeric_traits<short> : public __conditional_type<std::__is_integer<short>::__value, __numeric_traits_integer<short>, __numeric_traits_floating<short> >::__type {
    };
template<> struct __numeric_traits<long> : public __conditional_type<std::__is_integer<long>::__value, __numeric_traits_integer<long>, __numeric_traits_floating<long> >::__type {
    };
    const int __max;
    const int __min;
    const int __max_exponent10;
    const int __max_exponent10;
    const int __max_exponent10;
    const int __digits;
    const char __max;
    const short __min;
    const short __max;
    const long __max;
    const long __min;
}
namespace std {
    struct piecewise_construct_t {
        explicit piecewise_construct_t() noexcept = default
    };
    constexpr std::piecewise_construct_t piecewise_construct = std::piecewise_construct_t();
    template <typename ...> class tuple;
    template <std::size_t ...> struct _Index_tuple;
    template <bool, typename _T1, typename _T2> struct _PCC {
        template <typename _U1, typename _U2> static constexpr bool _ConstructiblePair()         {
            return __and_<is_constructible<_T1, const _U1 &>, is_constructible<_T2, const _U2 &> >::value;
        }
        template <typename _U1, typename _U2> static constexpr bool _ImplicitlyConvertiblePair()         {
            return __and_<is_convertible<const _U1 &, _T1>, is_convertible<const _U2 &, _T2> >::value;
        }
        template <typename _U1, typename _U2> static constexpr bool _MoveConstructiblePair()         {
            return __and_<is_constructible<_T1, _U1 &&>, is_constructible<_T2, _U2 &&> >::value;
        }
        template <typename _U1, typename _U2> static constexpr bool _ImplicitlyMoveConvertiblePair()         {
            return __and_<is_convertible<_U1 &&, _T1>, is_convertible<_U2 &&, _T2> >::value;
        }
        template <bool __implicit, typename _U1, typename _U2> static constexpr bool _CopyMovePair()         {
            using __do_converts = __and_<is_convertible<const _U1 &, _T1>, is_convertible<_U2 &&, _T2> >;
            using __converts = typename conditional<__implicit, __do_converts, __not_<__do_converts> >::type;
            return __and_<is_constructible<_T1, const _U1 &>, is_constructible<_T2, _U2 &&>, __converts>::value;
        }
        template <bool __implicit, typename _U1, typename _U2> static constexpr bool _MoveCopyPair()         {
            using __do_converts = __and_<is_convertible<_U1 &&, _T1>, is_convertible<const _U2 &, _T2> >;
            using __converts = typename conditional<__implicit, __do_converts, __not_<__do_converts> >::type;
            return __and_<is_constructible<_T1, _U1 &&>, is_constructible<_T2, const _U2 &&>, __converts>::value;
        }
    };
    template <typename _T1, typename _T2> struct _PCC<false, _T1, _T2> {
        template <typename _U1, typename _U2> static constexpr bool _ConstructiblePair()         {
            return false;
        }
        template <typename _U1, typename _U2> static constexpr bool _ImplicitlyConvertiblePair()         {
            return false;
        }
        template <typename _U1, typename _U2> static constexpr bool _MoveConstructiblePair()         {
            return false;
        }
        template <typename _U1, typename _U2> static constexpr bool _ImplicitlyMoveConvertiblePair()         {
            return false;
        }
    };
    struct __nonesuch_no_braces : std::__nonesuch {
        explicit __nonesuch_no_braces(const std::__nonesuch &) = delete
    };
    template <typename _U1, typename _U2> class __pair_base {
        friend template <typename _T1, typename _T2> struct pair;
        __pair_base<_U1, _U2>() = default
        ~__pair_base<_U1, _U2>() = default
        __pair_base<_U1, _U2>(const __pair_base<_U1, _U2> &) = default
        __pair_base<_U1, _U2> &operator=(const __pair_base<_U1, _U2> &) = delete
    };
    template <typename _T1, typename _T2> struct pair : private __pair_base<_T1, _T2> {
        typedef _T1 first_type;
        typedef _T2 second_type;
        _T1 first;
        _T2 second;
        template <typename _U1 = _T1, typename _U2 = _T2, typename enable_if<__and_<__is_implicitly_default_constructible<_U1>, __is_implicitly_default_constructible<_U2> >::value, bool>::type = true> constexpr pair<_T1, _T2>() : first(), second()         {
        }
        template <typename _U1 = _T1, typename _U2 = _T2, typename enable_if<__and_<is_default_constructible<_U1>, is_default_constructible<_U2>, __not_<__and_<__is_implicitly_default_constructible<_U1>, __is_implicitly_default_constructible<_U2> > > >::value, bool>::type = false> constexpr explicit pair<_T1, _T2>() : first(), second()         {
        }
        using _PCCP = _PCC<true, _T1, _T2>;
        template <typename _U1 = _T1, typename _U2 = _T2, typename enable_if<_PCCP::template _ConstructiblePair<_U1, _U2>() && _PCCP::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair<_T1, _T2>(const _T1 &__a, const _T2 &__b) : first(__a), second(__b)         {
        }
        template <typename _U1 = _T1, typename _U2 = _T2, typename enable_if<_PCCP::template _ConstructiblePair<_U1, _U2>() && !_PCCP::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair<_T1, _T2>(const _T1 &__a, const _T2 &__b) : first(__a), second(__b)         {
        }
        template <typename _U1, typename _U2> using _PCCFP = _PCC<!is_same<_T1, _U1>::value || !is_same<_T2, _U2>::value, _T1, _T2>;
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _ConstructiblePair<_U1, _U2>() && _PCCFP<_U1, _U2>::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair<_T1, _T2>(const pair<_U1, _U2> &__p) : first(__p.first), second(__p.second)         {
        }
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _ConstructiblePair<_U1, _U2>() && !_PCCFP<_U1, _U2>::template _ImplicitlyConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair<_T1, _T2>(const pair<_U1, _U2> &__p) : first(__p.first), second(__p.second)         {
        }
        pair<_T1, _T2>(const pair<_T1, _T2> &) = default
        pair<_T1, _T2>(pair<_T1, _T2> &&) = default
        template <typename _U1, typename enable_if<_PCCP::template _MoveCopyPair<true, _U1, _T2>(), bool>::type = true> constexpr pair<_T1, _T2>(_U1 &&__x, const _T2 &__y) : first(std::forward<_U1>(__x)), second(__y)         {
        }
        template <typename _U1, typename enable_if<_PCCP::template _MoveCopyPair<false, _U1, _T2>(), bool>::type = false> constexpr explicit pair<_T1, _T2>(_U1 &&__x, const _T2 &__y) : first(std::forward<_U1>(__x)), second(__y)         {
        }
        template <typename _U2, typename enable_if<_PCCP::template _CopyMovePair<true, _T1, _U2>(), bool>::type = true> constexpr pair<_T1, _T2>(const _T1 &__x, _U2 &&__y) : first(__x), second(std::forward<_U2>(__y))         {
        }
        template <typename _U2, typename enable_if<_PCCP::template _CopyMovePair<false, _T1, _U2>(), bool>::type = false> explicit pair<_T1, _T2>(const _T1 &__x, _U2 &&__y) : first(__x), second(std::forward<_U2>(__y))         {
        }
        template <typename _U1, typename _U2, typename enable_if<_PCCP::template _MoveConstructiblePair<_U1, _U2>() && _PCCP::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair<_T1, _T2>(_U1 &&__x, _U2 &&__y) : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y))         {
        }
        template <typename _U1, typename _U2, typename enable_if<_PCCP::template _MoveConstructiblePair<_U1, _U2>() && !_PCCP::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair<_T1, _T2>(_U1 &&__x, _U2 &&__y) : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y))         {
        }
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _MoveConstructiblePair<_U1, _U2>() && _PCCFP<_U1, _U2>::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = true> constexpr pair<_T1, _T2>(pair<_U1, _U2> &&__p) : first(std::forward<_U1>(__p.first)), second(std::forward<_U2>(__p.second))         {
        }
        template <typename _U1, typename _U2, typename enable_if<_PCCFP<_U1, _U2>::template _MoveConstructiblePair<_U1, _U2>() && !_PCCFP<_U1, _U2>::template _ImplicitlyMoveConvertiblePair<_U1, _U2>(), bool>::type = false> constexpr explicit pair<_T1, _T2>(pair<_U1, _U2> &&__p) : first(std::forward<_U1>(__p.first)), second(std::forward<_U2>(__p.second))         {
        }
        template <typename ..._Args1, typename ..._Args2> pair<_T1, _T2>(std::piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);
        pair<_T1, _T2> &operator=(typename conditional<__and_<is_copy_assignable<_T1>, is_copy_assignable<_T2> >::value, const pair<_T1, _T2> &, const __nonesuch_no_braces &>::type __p)         {
            this->first = __p.first;
            this->second = __p.second;
            return *this;
        }
        pair<_T1, _T2> &operator=(typename conditional<__and_<is_move_assignable<_T1>, is_move_assignable<_T2> >::value, pair<_T1, _T2> &&, __nonesuch_no_braces &&>::type __p) noexcept(__and_<is_nothrow_move_assignable<_T1>, is_nothrow_move_assignable<_T2> >::valueoperator=(typename conditional<__and_<is_move_assignable<_T1>, is_move_assignable<_T2> >::value, pair<_T1, _T2> &&, __nonesuch_no_braces &&>::type __p) noexcept(__and_<is_nothrow_move_assignable<_T1>, is_nothrow_move_assignable<_T2> >::value)         {
            this->first = std::forward<std::pair::first_type>(__p.first);
            this->second = std::forward<std::pair::second_type>(__p.second);
            return *this;
        }
        template <typename _U1, typename _U2> typename enable_if<__and_<is_assignable<_T1 &, const _U1 &>, is_assignable<_T2 &, const _U2 &> >::value, pair<_T1, _T2> &>::type operator=(const pair<_U1, _U2> &__p)         {
            this->first = __p.first;
            this->second = __p.second;
            return *this;
        }
        template <typename _U1, typename _U2> typename enable_if<__and_<is_assignable<_T1 &, _U1 &&>, is_assignable<_T2 &, _U2 &&> >::value, pair<_T1, _T2> &>::type operator=(pair<_U1, _U2> &&__p)         {
            this->first = std::forward<_U1>(__p.first);
            this->second = std::forward<_U2>(__p.second);
            return *this;
        }
        void swap(pair<_T1, _T2> &__p) noexcept(__and_<__is_nothrow_swappable<_T1>, __is_nothrow_swappable<_T2> >::valueswap(pair<_T1, _T2> &__p) noexcept(__and_<__is_nothrow_swappable<_T1>, __is_nothrow_swappable<_T2> >::value)         {
            using std::swap;
            swap(this->first, __p.first);
            swap(this->second, __p.second);
        }
    private:
        template <typename ..._Args1, std::size_t ..._Indexes1, typename ..._Args2, std::size_t ..._Indexes2> pair<_T1, _T2>(tuple<_Args1...> &, tuple<_Args2...> &, _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
    };
    template <typename _T1, typename _T2> inline constexpr bool operator==(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)     {
        return __x.first == __y.first && __x.second == __y.second;
    }
    template <typename _T1, typename _T2> inline constexpr bool operator<(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)     {
        return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
    }
    template <typename _T1, typename _T2> inline constexpr bool operator!=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)     {
        return !(__x == __y);
    }
    template <typename _T1, typename _T2> inline constexpr bool operator>(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)     {
        return __y < __x;
    }
    template <typename _T1, typename _T2> inline constexpr bool operator<=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)     {
        return !(__y < __x);
    }
    template <typename _T1, typename _T2> inline constexpr bool operator>=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y)     {
        return !(__x < __y);
    }
    template <typename _T1, typename _T2> inline typename enable_if<__and_<__is_swappable<_T1>, __is_swappable<_T2> >::value>::type swap(pair<_T1, _T2> &__x, pair<_T1, _T2> &__y) noexcept(noexcept(__x.swap(__y))swap(pair<_T1, _T2> &__x, pair<_T1, _T2> &__y) noexcept(noexcept(__x.swap(__y)))     {
        __x.swap(__y);
    }
    template <typename _T1, typename _T2> typename enable_if<!__and_<__is_swappable<_T1>, __is_swappable<_T2> >::value>::type swap(pair<_T1, _T2> &, pair<_T1, _T2> &) = delete
    template <typename _T1, typename _T2> constexpr pair<typename __decay_and_strip<_T1>::__type, typename __decay_and_strip<_T2>::__type> make_pair(_T1 &&__x, _T2 &&__y)     {
        typedef typename __decay_and_strip<_T1>::__type __ds_type1;
        typedef typename __decay_and_strip<_T2>::__type __ds_type2;
        typedef pair<__ds_type1, __ds_type2> __pair_type;
        return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
}
namespace std {
    struct input_iterator_tag {
    };
    struct output_iterator_tag {
    };
    struct forward_iterator_tag : public std::input_iterator_tag {
    };
    struct bidirectional_iterator_tag : public std::forward_iterator_tag {
    };
    struct random_access_iterator_tag : public std::bidirectional_iterator_tag {
    };
    template <typename _Category, typename _Tp, typename _Distance = std::ptrdiff_t, typename _Pointer = _Tp *, typename _Reference = _Tp &> struct iterator {
        typedef _Category iterator_category;
        typedef _Tp value_type;
        typedef _Distance difference_type;
        typedef _Pointer pointer;
        typedef _Reference reference;
    };
template<> struct iterator<std::output_iterator_tag, void, void, void, void> {
        typedef std::output_iterator_tag iterator_category;
        typedef void value_type;
        typedef void difference_type;
        typedef void pointer;
        typedef void reference;
    };
    template <typename _Iterator, typename = __void_t<>> struct __iterator_traits {
    };
    template <typename _Iterator> struct __iterator_traits<_Iterator, __void_t<typename _Iterator::iterator_category, typename _Iterator::value_type, typename _Iterator::difference_type, typename _Iterator::pointer, typename _Iterator::reference>> {
        typedef typename _Iterator::iterator_category iterator_category;
        typedef typename _Iterator::value_type value_type;
        typedef typename _Iterator::difference_type difference_type;
        typedef typename _Iterator::pointer pointer;
        typedef typename _Iterator::reference reference;
    };
    template <typename _Iterator> struct iterator_traits : public __iterator_traits<_Iterator> {
    };
template<> struct iterator_traits<char *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char value_type;
        typedef std::ptrdiff_t difference_type;
        typedef char *pointer;
        typedef char &reference;
    };
template<> struct iterator_traits<const char *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char value_type;
        typedef std::ptrdiff_t difference_type;
        typedef const char *pointer;
        typedef const char &reference;
    };
template<> struct iterator_traits<wchar_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef wchar_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef wchar_t *pointer;
        typedef wchar_t &reference;
    };
template<> struct iterator_traits<const wchar_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef wchar_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef const wchar_t *pointer;
        typedef const wchar_t &reference;
    };
template<> struct iterator_traits<const char16_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char16_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef const char16_t *pointer;
        typedef const char16_t &reference;
    };
template<> struct iterator_traits<char16_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char16_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef char16_t *pointer;
        typedef char16_t &reference;
    };
template<> struct iterator_traits<const char32_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char32_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef const char32_t *pointer;
        typedef const char32_t &reference;
    };
template<> struct iterator_traits<char32_t *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef char32_t value_type;
        typedef std::ptrdiff_t difference_type;
        typedef char32_t *pointer;
        typedef char32_t &reference;
    };
    template <typename _Tp> struct iterator_traits<_Tp *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef _Tp value_type;
        typedef std::ptrdiff_t difference_type;
        typedef _Tp *pointer;
        typedef _Tp &reference;
    };
    template <typename _Tp> struct iterator_traits<const _Tp *> {
        typedef std::random_access_iterator_tag iterator_category;
        typedef _Tp value_type;
        typedef std::ptrdiff_t difference_type;
        typedef const _Tp *pointer;
        typedef const _Tp &reference;
    };
    template <typename _Iter> inline constexpr typename iterator_traits<_Iter>::iterator_category __iterator_category(const _Iter &)     {
        return typename iterator_traits<_Iter>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<char *>::iterator_category __iterator_category<char *>(char *const &)     {
        return typename iterator_traits<char *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<wchar_t *>::iterator_category __iterator_category<wchar_t *>(wchar_t *const &)     {
        return typename iterator_traits<wchar_t *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<const char *>::iterator_category __iterator_category<const char *>(const char *const &)     {
        return typename iterator_traits<const char *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<const wchar_t *>::iterator_category __iterator_category<const wchar_t *>(const wchar_t *const &)     {
        return typename iterator_traits<const wchar_t *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<const char16_t *>::iterator_category __iterator_category<const char16_t *>(const char16_t *const &)     {
        return typename iterator_traits<const char16_t *>::iterator_category();
    }
    template<> inline constexpr typename iterator_traits<const char32_t *>::iterator_category __iterator_category<const char32_t *>(const char32_t *const &)     {
        return typename iterator_traits<const char32_t *>::iterator_category();
    }
    template <typename _InIter> using _RequireInputIter = typename enable_if<is_convertible<typename iterator_traits<_InIter>::iterator_category, input_iterator_tag>::value>::type;
}
namespace std {
    template <typename> struct _List_iterator;
    template <typename> struct _List_const_iterator;
    template <typename _InputIterator> inline constexpr typename iterator_traits<_InputIterator>::difference_type __distance(_InputIterator __first, _InputIterator __last, std::input_iterator_tag)     {
        typename iterator_traits<_InputIterator>::difference_type __n = 0;
        while (__first != __last)
            {
                ++__first;
                ++__n;
            }
        return __n;
    }
    template<> inline constexpr typename iterator_traits<char *>::difference_type __distance<char *>(char *__first, char *__last, std::input_iterator_tag)    template<> inline constexpr typename iterator_traits<wchar_t *>::difference_type __distance<wchar_t *>(wchar_t *__first, wchar_t *__last, std::input_iterator_tag)    template<> inline constexpr typename iterator_traits<const char *>::difference_type __distance<const char *>(const char *__first, const char *__last, std::input_iterator_tag)    template<> inline constexpr typename iterator_traits<const wchar_t *>::difference_type __distance<const wchar_t *>(const wchar_t *__first, const wchar_t *__last, std::input_iterator_tag)    template<> inline constexpr typename iterator_traits<const char16_t *>::difference_type __distance<const char16_t *>(const char16_t *__first, const char16_t *__last, std::input_iterator_tag)    template<> inline constexpr typename iterator_traits<const char32_t *>::difference_type __distance<const char32_t *>(const char32_t *__first, const char32_t *__last, std::input_iterator_tag)    template <typename _RandomAccessIterator> inline constexpr typename iterator_traits<_RandomAccessIterator>::difference_type __distance(_RandomAccessIterator __first, _RandomAccessIterator __last, std::random_access_iterator_tag)     {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<char *>::difference_type __distance<char *>(char *__first, char *__last, std::random_access_iterator_tag)     {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<wchar_t *>::difference_type __distance<wchar_t *>(wchar_t *__first, wchar_t *__last, std::random_access_iterator_tag)     {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<const char *>::difference_type __distance<const char *>(const char *__first, const char *__last, std::random_access_iterator_tag)     {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<const wchar_t *>::difference_type __distance<const wchar_t *>(const wchar_t *__first, const wchar_t *__last, std::random_access_iterator_tag)     {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<const char16_t *>::difference_type __distance<const char16_t *>(const char16_t *__first, const char16_t *__last, std::random_access_iterator_tag)     {
        return __last - __first;
    }
    template<> inline constexpr typename iterator_traits<const char32_t *>::difference_type __distance<const char32_t *>(const char32_t *__first, const char32_t *__last, std::random_access_iterator_tag)     {
        return __last - __first;
    }
    template <typename _Tp> std::ptrdiff_t __distance(std::_List_iterator<_Tp>, std::_List_iterator<_Tp>, std::input_iterator_tag);
    template <typename _Tp> std::ptrdiff_t __distance(std::_List_const_iterator<_Tp>, std::_List_const_iterator<_Tp>, std::input_iterator_tag);
    template <typename _InputIterator> inline typename iterator_traits<_InputIterator>::difference_type distance(_InputIterator __first, _InputIterator __last)     {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline typename iterator_traits<char *>::difference_type distance<char *>(char *__first, char *__last)     {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline typename iterator_traits<wchar_t *>::difference_type distance<wchar_t *>(wchar_t *__first, wchar_t *__last)     {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline typename iterator_traits<const char *>::difference_type distance<const char *>(const char *__first, const char *__last)     {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline typename iterator_traits<const wchar_t *>::difference_type distance<const wchar_t *>(const wchar_t *__first, const wchar_t *__last)     {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline typename iterator_traits<const char16_t *>::difference_type distance<const char16_t *>(const char16_t *__first, const char16_t *__last)     {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template<> inline typename iterator_traits<const char32_t *>::difference_type distance<const char32_t *>(const char32_t *__first, const char32_t *__last)     {
        return std::__distance(__first, __last, std::__iterator_category(__first));
    }
    template <typename _InputIterator, typename _Distance> inline constexpr void __advance(_InputIterator &__i, _Distance __n, std::input_iterator_tag)     {
        ;
        while (__n--)
            ++__i;
    }
    template <typename _BidirectionalIterator, typename _Distance> inline constexpr void __advance(_BidirectionalIterator &__i, _Distance __n, std::bidirectional_iterator_tag)     {
        if (__n > 0)
            while (__n--)
                ++__i;
        else
            while (__n++)
                --__i;
    }
    template <typename _RandomAccessIterator, typename _Distance> inline constexpr void __advance(_RandomAccessIterator &__i, _Distance __n, std::random_access_iterator_tag)     {
        if (__builtin_constant_p(__n) && __n == 1)
            ++__i;
        else if (__builtin_constant_p(__n) && __n == -1)
            --__i;
        else
            __i += __n;
    }
    template <typename _InputIterator, typename _Distance> inline void advance(_InputIterator &__i, _Distance __n)     {
        typename iterator_traits<_InputIterator>::difference_type __d = __n;
        std::__advance(__i, __d, std::__iterator_category(__i));
    }
    template <typename _InputIterator> inline _InputIterator next(_InputIterator __x, typename iterator_traits<_InputIterator>::difference_type __n = 1)     {
        std::advance(__x, __n);
        return __x;
    }
    template <typename _BidirectionalIterator> inline _BidirectionalIterator prev(_BidirectionalIterator __x, typename iterator_traits<_BidirectionalIterator>::difference_type __n = 1)     {
        std::advance(__x, -__n);
        return __x;
    }
}
namespace std {
    class __undefined;
    template <typename _Tp> struct __get_first_arg {
        using type = std::__undefined;
    };
    template <template <typename, typename ...> class _Template, typename _Tp, typename ..._Types> struct __get_first_arg<_Template<_Tp, _Types...>> {
        using type = _Tp;
    };
    template <typename _Tp> using __get_first_arg_t = typename __get_first_arg<_Tp>::type;
    template <typename _Tp, typename _Up> struct __replace_first_arg {
    };
    template <template <typename, typename ...> class _Template, typename _Up, typename _Tp, typename ..._Types> struct __replace_first_arg<_Template<_Tp, _Types...>, _Up> {
        using type = _Template<_Up, _Types...>;
    };
    template <typename _Tp, typename _Up> using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;
    template <typename _Tp> using __make_not_void = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;
    template <typename _Ptr> struct pointer_traits {
    private:
        template <typename _Tp> using __element_type = typename _Tp::element_type;
        template <typename _Tp> using __difference_type = typename _Tp::difference_type;
        template <typename _Tp, typename _Up, typename = void> struct __rebind : __replace_first_arg<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __rebind<_Tp, _Up, __void_t<typename _Tp::rebind<_Up> >> {
            using type = typename _Tp::rebind<_Up>;
        };
    public:
        using pointer = _Ptr;
        using element_type = __detected_or_t<__get_first_arg_t<_Ptr>, __element_type, _Ptr>;
        using difference_type = __detected_or_t<std::ptrdiff_t, __difference_type, _Ptr>;
        template <typename _Up> using rebind = typename __rebind<_Ptr, _Up>::type;
        static _Ptr pointer_to(__make_not_void<std::pointer_traits::element_type> &__e)         {
            return _Ptr::pointer_to(__e);
        }
        static_assert(!is_same<element_type, __undefined>::value, "pointer type defines element_type or is like SomePointer<T, Args>");
    };
template<> struct pointer_traits<char *> {
        typedef char *pointer;
        typedef char element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
        static std::pointer_traits<char *>::pointer pointer_to(__make_not_void<std::pointer_traits<char *>::element_type> &__r) noexcept         {
            return std::addressof(__r);
        }
    };
template<> struct pointer_traits<const char *> {
        typedef const char *pointer;
        typedef const char element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
        static std::pointer_traits<const char *>::pointer pointer_to(__make_not_void<std::pointer_traits<const char *>::element_type> &__r) noexcept         {
            return std::addressof(__r);
        }
    };
template<> struct pointer_traits<wchar_t *> {
        typedef wchar_t *pointer;
        typedef wchar_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
        static std::pointer_traits<wchar_t *>::pointer pointer_to(__make_not_void<std::pointer_traits<wchar_t *>::element_type> &__r) noexcept         {
            return std::addressof(__r);
        }
    };
template<> struct pointer_traits<const wchar_t *> {
        typedef const wchar_t *pointer;
        typedef const wchar_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
        static std::pointer_traits<const wchar_t *>::pointer pointer_to(__make_not_void<std::pointer_traits<const wchar_t *>::element_type> &__r) noexcept         {
            return std::addressof(__r);
        }
    };
template<> struct pointer_traits<char16_t *> {
        typedef char16_t *pointer;
        typedef char16_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
        static std::pointer_traits<char16_t *>::pointer pointer_to(__make_not_void<std::pointer_traits<char16_t *>::element_type> &__r) noexcept         {
            return std::addressof(__r);
        }
    };
template<> struct pointer_traits<const char16_t *> {
        typedef const char16_t *pointer;
        typedef const char16_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
        static std::pointer_traits<const char16_t *>::pointer pointer_to(__make_not_void<std::pointer_traits<const char16_t *>::element_type> &__r) noexcept         {
            return std::addressof(__r);
        }
    };
template<> struct pointer_traits<char32_t *> {
        typedef char32_t *pointer;
        typedef char32_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
        static std::pointer_traits<char32_t *>::pointer pointer_to(__make_not_void<std::pointer_traits<char32_t *>::element_type> &__r) noexcept         {
            return std::addressof(__r);
        }
    };
template<> struct pointer_traits<const char32_t *> {
        typedef const char32_t *pointer;
        typedef const char32_t element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
        static std::pointer_traits<const char32_t *>::pointer pointer_to(__make_not_void<std::pointer_traits<const char32_t *>::element_type> &__r) noexcept         {
            return std::addressof(__r);
        }
    };
    template <typename _Tp> struct pointer_traits<_Tp *> {
        typedef _Tp *pointer;
        typedef _Tp element_type;
        typedef std::ptrdiff_t difference_type;
        template <typename _Up> using rebind = _Up *;
        static std::pointer_traits<type-parameter-0-0 *>::pointer pointer_to(__make_not_void<std::pointer_traits<type-parameter-0-0 *>::element_type> &__r) noexcept         {
            return std::addressof(__r);
        }
    };
    template <typename _Ptr, typename _Tp> using __ptr_rebind = typename pointer_traits<_Ptr>::rebind<_Tp>;
    template <typename _Tp> constexpr _Tp *__to_address(_Tp *__ptr) noexcept     {
        static_assert(!std::is_function<_Tp>::value, "not a function pointer");
        return __ptr;
    }
    template <typename _Ptr> constexpr typename std::pointer_traits<_Ptr>::element_type *__to_address(const _Ptr &__ptr)     {
        return std::__to_address(__ptr.operator->());
    }
}
namespace std {
    template <typename _Iterator> class reverse_iterator : public iterator<typename iterator_traits<_Iterator>::iterator_category, typename iterator_traits<_Iterator>::value_type, typename iterator_traits<_Iterator>::difference_type, typename iterator_traits<_Iterator>::pointer, typename iterator_traits<_Iterator>::reference> {
    protected:
        _Iterator current;
        typedef iterator_traits<_Iterator> __traits_type;
    public:
        typedef _Iterator iterator_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::pointer pointer;
        typedef typename __traits_type::reference reference;
        reverse_iterator<_Iterator>() : current()         {
        }
        explicit reverse_iterator<_Iterator>(std::reverse_iterator::iterator_type __x) : current(__x)         {
        }
        reverse_iterator<_Iterator>(const reverse_iterator<_Iterator> &__x) : current(__x.current)         {
        }
        reverse_iterator<_Iterator> &operator=(const reverse_iterator<_Iterator> &) = default
        template <typename _Iter> reverse_iterator<_Iterator>(const reverse_iterator<_Iter> &__x) : current(__x.base())         {
        }
        std::reverse_iterator::iterator_type base() const         {
            return this->current;
        }
        std::reverse_iterator::reference operator*() const         {
            _Iterator __tmp = this->current;
            return *--__tmp;
        }
        std::reverse_iterator::pointer operator->() const         {
            _Iterator __tmp = this->current;
            --__tmp;
            return _S_to_pointer(__tmp);
        }
        reverse_iterator<_Iterator> &operator++()         {
            --this->current;
            return *this;
        }
        reverse_iterator<_Iterator> operator++(int)         {
            reverse_iterator<_Iterator> __tmp = *this;
            --this->current;
            return __tmp;
        }
        reverse_iterator<_Iterator> &operator--()         {
            ++this->current;
            return *this;
        }
        reverse_iterator<_Iterator> operator--(int)         {
            reverse_iterator<_Iterator> __tmp = *this;
            ++this->current;
            return __tmp;
        }
        reverse_iterator<_Iterator> operator+(std::reverse_iterator::difference_type __n) const         {
            return reverse_iterator<_Iterator>(this->current - __n);
        }
        reverse_iterator<_Iterator> &operator+=(std::reverse_iterator::difference_type __n)         {
            this->current -= __n;
            return *this;
        }
        reverse_iterator<_Iterator> operator-(std::reverse_iterator::difference_type __n) const         {
            return reverse_iterator<_Iterator>(this->current + __n);
        }
        reverse_iterator<_Iterator> &operator-=(std::reverse_iterator::difference_type __n)         {
            this->current += __n;
            return *this;
        }
        std::reverse_iterator::reference operator[](std::reverse_iterator::difference_type __n) const         {
            return *(*this + __n);
        }
    private:
        template <typename _Tp> static _Tp *_S_to_pointer(_Tp *__p)         {
            return __p;
        }
        template <typename _Tp> static std::reverse_iterator::pointer _S_to_pointer(_Tp __t)         {
            return __t.operator->();
        }
    };
    template <typename _Iterator> inline bool operator==(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y)     {
        return __x.base() == __y.base();
    }
    template <typename _Iterator> inline bool operator<(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y)     {
        return __y.base() < __x.base();
    }
    template <typename _Iterator> inline bool operator!=(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y)     {
        return !(__x == __y);
    }
    template <typename _Iterator> inline bool operator>(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y)     {
        return __y < __x;
    }
    template <typename _Iterator> inline bool operator<=(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y)     {
        return !(__y < __x);
    }
    template <typename _Iterator> inline bool operator>=(const reverse_iterator<_Iterator> &__x, const reverse_iterator<_Iterator> &__y)     {
        return !(__x < __y);
    }
    template <typename _IteratorL, typename _IteratorR> inline bool operator==(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y)     {
        return __x.base() == __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline bool operator<(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y)     {
        return __y.base() < __x.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline bool operator!=(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y)     {
        return !(__x == __y);
    }
    template <typename _IteratorL, typename _IteratorR> inline bool operator>(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y)     {
        return __y < __x;
    }
    template <typename _IteratorL, typename _IteratorR> inline bool operator<=(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y)     {
        return !(__y < __x);
    }
    template <typename _IteratorL, typename _IteratorR> inline bool operator>=(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y)     {
        return !(__x < __y);
    }
    template <typename _IteratorL, typename _IteratorR> inline auto operator-(const reverse_iterator<_IteratorL> &__x, const reverse_iterator<_IteratorR> &__y) -> decltype(__y.base() - __x.base())     {
        return __y.base() - __x.base();
    }
    template <typename _Iterator> inline reverse_iterator<_Iterator> operator+(typename reverse_iterator<_Iterator>::difference_type __n, const reverse_iterator<_Iterator> &__x)     {
        return reverse_iterator<_Iterator>(__x.base() - __n);
    }
    template <typename _Iterator> inline reverse_iterator<_Iterator> __make_reverse_iterator(_Iterator __i)     {
        return reverse_iterator<_Iterator>(__i);
    }
    template <typename _Iterator> inline reverse_iterator<_Iterator> make_reverse_iterator(_Iterator __i)     {
        return reverse_iterator<_Iterator>(__i);
    }
    template <typename _Iterator> auto __niter_base(reverse_iterator<_Iterator> __it) -> decltype(__make_reverse_iterator(__niter_base(__it.base())))     {
        return __make_reverse_iterator(__niter_base(__it.base()));
    }
    template <typename _Iterator> struct __is_move_iterator<reverse_iterator<_Iterator>> : __is_move_iterator<_Iterator> {
    };
    template <typename _Iterator> auto __miter_base(reverse_iterator<_Iterator> __it) -> decltype(__make_reverse_iterator(__miter_base(__it.base())))     {
        return __make_reverse_iterator(__miter_base(__it.base()));
    }
    template <typename _Container> class back_insert_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
    protected:
        _Container *container;
    public:
        typedef _Container container_type;
        explicit back_insert_iterator<_Container>(_Container &__x) : container(std::__addressof(__x))         {
        }
        back_insert_iterator<_Container> &operator=(const typename _Container::value_type &__value)         {
            this->container->push_back(__value);
            return *this;
        }
        back_insert_iterator<_Container> &operator=(typename _Container::value_type &&__value)         {
            this->container->push_back(std::move(__value));
            return *this;
        }
        back_insert_iterator<_Container> &operator*()         {
            return *this;
        }
        back_insert_iterator<_Container> &operator++()         {
            return *this;
        }
        back_insert_iterator<_Container> operator++(int)         {
            return *this;
        }
    };
    template <typename _Container> inline back_insert_iterator<_Container> back_inserter(_Container &__x)     {
        return back_insert_iterator<_Container>(__x);
    }
    template <typename _Container> class front_insert_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
    protected:
        _Container *container;
    public:
        typedef _Container container_type;
        explicit front_insert_iterator<_Container>(_Container &__x) : container(std::__addressof(__x))         {
        }
        front_insert_iterator<_Container> &operator=(const typename _Container::value_type &__value)         {
            this->container->push_front(__value);
            return *this;
        }
        front_insert_iterator<_Container> &operator=(typename _Container::value_type &&__value)         {
            this->container->push_front(std::move(__value));
            return *this;
        }
        front_insert_iterator<_Container> &operator*()         {
            return *this;
        }
        front_insert_iterator<_Container> &operator++()         {
            return *this;
        }
        front_insert_iterator<_Container> operator++(int)         {
            return *this;
        }
    };
    template <typename _Container> inline front_insert_iterator<_Container> front_inserter(_Container &__x)     {
        return front_insert_iterator<_Container>(__x);
    }
    template <typename _Container> class insert_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
    protected:
        _Container *container;
        typename _Container::iterator iter;
    public:
        typedef _Container container_type;
        insert_iterator<_Container>(_Container &__x, typename _Container::iterator __i) : container(std::__addressof(__x)), iter(__i)         {
        }
        insert_iterator<_Container> &operator=(const typename _Container::value_type &__value)         {
            this->iter = this->container->insert(this->iter, __value);
            ++this->iter;
            return *this;
        }
        insert_iterator<_Container> &operator=(typename _Container::value_type &&__value)         {
            this->iter = this->container->insert(this->iter, std::move(__value));
            ++this->iter;
            return *this;
        }
        insert_iterator<_Container> &operator*()         {
            return *this;
        }
        insert_iterator<_Container> &operator++()         {
            return *this;
        }
        insert_iterator<_Container> &operator++(int)         {
            return *this;
        }
    };
    template <typename _Container, typename _Iterator> inline insert_iterator<_Container> inserter(_Container &__x, _Iterator __i)     {
        return insert_iterator<_Container>(__x, typename _Container::iterator(__i));
    }
}
namespace __gnu_cxx {
    using std::iterator_traits;
    using std::iterator;
    template <typename _Iterator, typename _Container> class __normal_iterator {
    protected:
        _Iterator _M_current;
        typedef iterator_traits<_Iterator> __traits_type;
    public:
        typedef _Iterator iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator<_Iterator, _Container>() noexcept : _M_current(_Iterator())         {
        }
        explicit __normal_iterator<_Iterator, _Container>(const _Iterator &__i) noexcept : _M_current(__i)         {
        }
        template <typename _Iter> __normal_iterator<_Iterator, _Container>(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename _Container::pointer>::__value), _Container>::__type> &__i) noexcept : _M_current(__i.base())         {
        }
        __gnu_cxx::__normal_iterator::reference operator*() const noexcept         {
            return *this->_M_current;
        }
        __gnu_cxx::__normal_iterator::pointer operator->() const noexcept         {
            return this->_M_current;
        }
        __normal_iterator<_Iterator, _Container> &operator++() noexcept         {
            ++this->_M_current;
            return *this;
        }
        __normal_iterator<_Iterator, _Container> operator++(int) noexcept         {
            return __normal_iterator<_Iterator, _Container>(this->_M_current++);
        }
        __normal_iterator<_Iterator, _Container> &operator--() noexcept         {
            --this->_M_current;
            return *this;
        }
        __normal_iterator<_Iterator, _Container> operator--(int) noexcept         {
            return __normal_iterator<_Iterator, _Container>(this->_M_current--);
        }
        __gnu_cxx::__normal_iterator::reference operator[](__gnu_cxx::__normal_iterator::difference_type __n) const noexcept         {
            return this->_M_current[__n];
        }
        __normal_iterator<_Iterator, _Container> &operator+=(__gnu_cxx::__normal_iterator::difference_type __n) noexcept         {
            this->_M_current += __n;
            return *this;
        }
        __normal_iterator<_Iterator, _Container> operator+(__gnu_cxx::__normal_iterator::difference_type __n) const noexcept         {
            return __normal_iterator<_Iterator, _Container>(this->_M_current + __n);
        }
        __normal_iterator<_Iterator, _Container> &operator-=(__gnu_cxx::__normal_iterator::difference_type __n) noexcept         {
            this->_M_current -= __n;
            return *this;
        }
        __normal_iterator<_Iterator, _Container> operator-(__gnu_cxx::__normal_iterator::difference_type __n) const noexcept         {
            return __normal_iterator<_Iterator, _Container>(this->_M_current - __n);
        }
        const _Iterator &base() const noexcept         {
            return this->_M_current;
        }
    };
template<> class __normal_iterator<char *, std::__cxx11::basic_string<char>> {
    protected:
        char *_M_current;
        typedef iterator_traits<char *> __traits_type;
    public:
        typedef char *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(char *const &__i) noexcept;
        template <typename _Iter> __normal_iterator(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename basic_string<char>::pointer>::__value), basic_string<char> >::__type> &__i) noexcept;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> >::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> >::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > &operator++() noexcept;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > &operator--() noexcept;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> >::reference operator[](__gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> >::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > &operator+=(__gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> >::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > operator+(__gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> >::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > &operator-=(__gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> >::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> > operator-(__gnu_cxx::__normal_iterator<char *, std::__cxx11::basic_string<char> >::difference_type __n) const noexcept;
        char *const &base() const noexcept;
    };
template<> class __normal_iterator<const char *, std::__cxx11::basic_string<char>> {
    protected:
        const char *_M_current;
        typedef iterator_traits<const char *> __traits_type;
    public:
        typedef const char *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(const char *const &__i) noexcept;
        template <typename _Iter> __normal_iterator(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename basic_string<char>::pointer>::__value), basic_string<char> >::__type> &__i) noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> >::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> >::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > &operator++() noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > &operator--() noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> >::reference operator[](__gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> >::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > &operator+=(__gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> >::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > operator+(__gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> >::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > &operator-=(__gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> >::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> > operator-(__gnu_cxx::__normal_iterator<const char *, std::__cxx11::basic_string<char> >::difference_type __n) const noexcept;
        const char *const &base() const noexcept;
    };
template<> class __normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t>> {
    protected:
        wchar_t *_M_current;
        typedef iterator_traits<wchar_t *> __traits_type;
    public:
        typedef wchar_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(wchar_t *const &__i) noexcept;
        template <typename _Iter> __normal_iterator(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename basic_string<wchar_t>::pointer>::__value), basic_string<wchar_t> >::__type> &__i) noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t> >::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t> >::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t> > &operator++() noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t> > operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t> > &operator--() noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t> > operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t> >::reference operator[](__gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t> >::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t> > &operator+=(__gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t> >::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t> > operator+(__gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t> >::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t> > &operator-=(__gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t> >::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t> > operator-(__gnu_cxx::__normal_iterator<wchar_t *, std::__cxx11::basic_string<wchar_t> >::difference_type __n) const noexcept;
        wchar_t *const &base() const noexcept;
    };
template<> class __normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t>> {
    protected:
        const wchar_t *_M_current;
        typedef iterator_traits<const wchar_t *> __traits_type;
    public:
        typedef const wchar_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(const wchar_t *const &__i) noexcept;
        template <typename _Iter> __normal_iterator(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename basic_string<wchar_t>::pointer>::__value), basic_string<wchar_t> >::__type> &__i) noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t> >::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t> >::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t> > &operator++() noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t> > operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t> > &operator--() noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t> > operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t> >::reference operator[](__gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t> >::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t> > &operator+=(__gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t> >::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t> > operator+(__gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t> >::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t> > &operator-=(__gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t> >::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t> > operator-(__gnu_cxx::__normal_iterator<const wchar_t *, std::__cxx11::basic_string<wchar_t> >::difference_type __n) const noexcept;
        const wchar_t *const &base() const noexcept;
    };
template<> class __normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >> {
    protected:
        char16_t *_M_current;
        typedef iterator_traits<char16_t *> __traits_type;
    public:
        typedef char16_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(char16_t *const &__i) noexcept;
        template <typename _Iter> __normal_iterator(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >::pointer>::__value), basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> > >::__type> &__i) noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > >::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > >::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > > &operator++() noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > > operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > > &operator--() noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > > operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > >::reference operator[](__gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > >::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > > &operator+=(__gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > >::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > > operator+(__gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > >::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > > &operator-=(__gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > >::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > > operator-(__gnu_cxx::__normal_iterator<char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > >::difference_type __n) const noexcept;
        char16_t *const &base() const noexcept;
    };
template<> class __normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >> {
    protected:
        const char16_t *_M_current;
        typedef iterator_traits<const char16_t *> __traits_type;
    public:
        typedef const char16_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(const char16_t *const &__i) noexcept;
        template <typename _Iter> __normal_iterator(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >::pointer>::__value), basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> > >::__type> &__i) noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > >::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > >::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > > &operator++() noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > > operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > > &operator--() noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > > operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > >::reference operator[](__gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > >::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > > &operator+=(__gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > >::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > > operator+(__gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > >::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > > &operator-=(__gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > >::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > > operator-(__gnu_cxx::__normal_iterator<const char16_t *, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > >::difference_type __n) const noexcept;
        const char16_t *const &base() const noexcept;
    };
template<> class __normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >> {
    protected:
        char32_t *_M_current;
        typedef iterator_traits<char32_t *> __traits_type;
    public:
        typedef char32_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(char32_t *const &__i) noexcept;
        template <typename _Iter> __normal_iterator(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >::pointer>::__value), basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> > >::__type> &__i) noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > >::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > >::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > > &operator++() noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > > operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > > &operator--() noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > > operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > >::reference operator[](__gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > >::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > > &operator+=(__gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > >::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > > operator+(__gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > >::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > > &operator-=(__gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > >::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > > operator-(__gnu_cxx::__normal_iterator<char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > >::difference_type __n) const noexcept;
        char32_t *const &base() const noexcept;
    };
template<> class __normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >> {
    protected:
        const char32_t *_M_current;
        typedef iterator_traits<const char32_t *> __traits_type;
    public:
        typedef const char32_t *iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef typename __traits_type::reference reference;
        typedef typename __traits_type::pointer pointer;
        constexpr __normal_iterator() noexcept;
        explicit __normal_iterator(const char32_t *const &__i) noexcept;
        template <typename _Iter> __normal_iterator(const __normal_iterator<_Iter, typename __enable_if<(std::__are_same<_Iter, typename basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >::pointer>::__value), basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> > >::__type> &__i) noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > >::reference operator*() const noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > >::pointer operator->() const noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > > &operator++() noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > > operator++(int) noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > > &operator--() noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > > operator--(int) noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > >::reference operator[](__gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > >::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > > &operator+=(__gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > >::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > > operator+(__gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > >::difference_type __n) const noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > > &operator-=(__gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > >::difference_type __n) noexcept;
        __gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > > operator-(__gnu_cxx::__normal_iterator<const char32_t *, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > >::difference_type __n) const noexcept;
        const char32_t *const &base() const noexcept;
    };
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator==(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept     {
        return __lhs.base() == __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline bool operator==(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept     {
        return __lhs.base() == __rhs.base();
    }
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator!=(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept     {
        return __lhs.base() != __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline bool operator!=(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept     {
        return __lhs.base() != __rhs.base();
    }
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator<(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept     {
        return __lhs.base() < __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline bool operator<(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept     {
        return __lhs.base() < __rhs.base();
    }
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator>(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept     {
        return __lhs.base() > __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline bool operator>(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept     {
        return __lhs.base() > __rhs.base();
    }
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator<=(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept     {
        return __lhs.base() <= __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline bool operator<=(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept     {
        return __lhs.base() <= __rhs.base();
    }
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline bool operator>=(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept     {
        return __lhs.base() >= __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline bool operator>=(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept     {
        return __lhs.base() >= __rhs.base();
    }
    template <typename _IteratorL, typename _IteratorR, typename _Container> inline auto operator-(const __normal_iterator<_IteratorL, _Container> &__lhs, const __normal_iterator<_IteratorR, _Container> &__rhs) noexcept -> decltype(__lhs.base() - __rhs.base())     {
        return __lhs.base() - __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline typename __normal_iterator<_Iterator, _Container>::difference_type operator-(const __normal_iterator<_Iterator, _Container> &__lhs, const __normal_iterator<_Iterator, _Container> &__rhs) noexcept     {
        return __lhs.base() - __rhs.base();
    }
    template <typename _Iterator, typename _Container> inline __normal_iterator<_Iterator, _Container> operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n, const __normal_iterator<_Iterator, _Container> &__i) noexcept     {
        return __normal_iterator<_Iterator, _Container>(__i.base() + __n);
    }
}
namespace std {
    template <typename _Iterator, typename _Container> _Iterator __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it) noexcept(std::is_nothrow_copy_constructible<_Iterator>::value__niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it) noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)     {
        return __it.base();
    }
    template <typename _Iterator> class move_iterator {
    protected:
        _Iterator _M_current;
        typedef iterator_traits<_Iterator> __traits_type;
        typedef typename __traits_type::reference __base_ref;
    public:
        typedef _Iterator iterator_type;
        typedef typename __traits_type::iterator_category iterator_category;
        typedef typename __traits_type::value_type value_type;
        typedef typename __traits_type::difference_type difference_type;
        typedef _Iterator pointer;
        typedef typename conditional<is_reference<__base_ref>::value, typename remove_reference<__base_ref>::type &&, __base_ref>::type reference;
        move_iterator<_Iterator>() : _M_current()         {
        }
        explicit move_iterator<_Iterator>(std::move_iterator::iterator_type __i) : _M_current(__i)         {
        }
        template <typename _Iter> move_iterator<_Iterator>(const move_iterator<_Iter> &__i) : _M_current(__i.base())         {
        }
        std::move_iterator::iterator_type base() const         {
            return this->_M_current;
        }
        std::move_iterator::reference operator*() const         {
            return static_cast<std::move_iterator::reference>(*this->_M_current);
        }
        std::move_iterator::pointer operator->() const         {
            return this->_M_current;
        }
        move_iterator<_Iterator> &operator++()         {
            ++this->_M_current;
            return *this;
        }
        move_iterator<_Iterator> operator++(int)         {
            move_iterator<_Iterator> __tmp = *this;
            ++this->_M_current;
            return __tmp;
        }
        move_iterator<_Iterator> &operator--()         {
            --this->_M_current;
            return *this;
        }
        move_iterator<_Iterator> operator--(int)         {
            move_iterator<_Iterator> __tmp = *this;
            --this->_M_current;
            return __tmp;
        }
        move_iterator<_Iterator> operator+(std::move_iterator::difference_type __n) const         {
            return move_iterator<_Iterator>(this->_M_current + __n);
        }
        move_iterator<_Iterator> &operator+=(std::move_iterator::difference_type __n)         {
            this->_M_current += __n;
            return *this;
        }
        move_iterator<_Iterator> operator-(std::move_iterator::difference_type __n) const         {
            return move_iterator<_Iterator>(this->_M_current - __n);
        }
        move_iterator<_Iterator> &operator-=(std::move_iterator::difference_type __n)         {
            this->_M_current -= __n;
            return *this;
        }
        std::move_iterator::reference operator[](std::move_iterator::difference_type __n) const         {
            return std::move(this->_M_current[__n]);
        }
    };
    template <typename _IteratorL, typename _IteratorR> inline bool operator==(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y)     {
        return __x.base() == __y.base();
    }
    template <typename _Iterator> inline bool operator==(const move_iterator<_Iterator> &__x, const move_iterator<_Iterator> &__y)     {
        return __x.base() == __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline bool operator!=(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y)     {
        return !(__x == __y);
    }
    template <typename _Iterator> inline bool operator!=(const move_iterator<_Iterator> &__x, const move_iterator<_Iterator> &__y)     {
        return !(__x == __y);
    }
    template <typename _IteratorL, typename _IteratorR> inline bool operator<(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y)     {
        return __x.base() < __y.base();
    }
    template <typename _Iterator> inline bool operator<(const move_iterator<_Iterator> &__x, const move_iterator<_Iterator> &__y)     {
        return __x.base() < __y.base();
    }
    template <typename _IteratorL, typename _IteratorR> inline bool operator<=(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y)     {
        return !(__y < __x);
    }
    template <typename _Iterator> inline bool operator<=(const move_iterator<_Iterator> &__x, const move_iterator<_Iterator> &__y)     {
        return !(__y < __x);
    }
    template <typename _IteratorL, typename _IteratorR> inline bool operator>(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y)     {
        return __y < __x;
    }
    template <typename _Iterator> inline bool operator>(const move_iterator<_Iterator> &__x, const move_iterator<_Iterator> &__y)     {
        return __y < __x;
    }
    template <typename _IteratorL, typename _IteratorR> inline bool operator>=(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y)     {
        return !(__x < __y);
    }
    template <typename _Iterator> inline bool operator>=(const move_iterator<_Iterator> &__x, const move_iterator<_Iterator> &__y)     {
        return !(__x < __y);
    }
    template <typename _IteratorL, typename _IteratorR> inline auto operator-(const move_iterator<_IteratorL> &__x, const move_iterator<_IteratorR> &__y) -> decltype(__x.base() - __y.base())     {
        return __x.base() - __y.base();
    }
    template <typename _Iterator> inline move_iterator<_Iterator> operator+(typename move_iterator<_Iterator>::difference_type __n, const move_iterator<_Iterator> &__x)     {
        return __x + __n;
    }
    template <typename _Iterator> inline move_iterator<_Iterator> make_move_iterator(_Iterator __i)     {
        return move_iterator<_Iterator>(__i);
    }
    template <typename _Iterator, typename _ReturnType = typename conditional<__move_if_noexcept_cond<typename iterator_traits<_Iterator>::value_type>::value, _Iterator, move_iterator<_Iterator> >::type> inline _ReturnType __make_move_if_noexcept_iterator(_Iterator __i)     {
        return _ReturnType(__i);
    }
    template <typename _Tp, typename _ReturnType = typename conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp *, move_iterator<_Tp *> >::type> inline _ReturnType __make_move_if_noexcept_iterator(_Tp *__i)     {
        return _ReturnType(__i);
    }
    template <typename _Iterator> auto __niter_base(move_iterator<_Iterator> __it) -> decltype(make_move_iterator(__niter_base(__it.base())))     {
        return make_move_iterator(__niter_base(__it.base()));
    }
    template <typename _Iterator> struct __is_move_iterator<move_iterator<_Iterator>> {
        enum  {
            __value = 1
        };
        typedef std::__true_type __type;
    };
    template <typename _Iterator> auto __miter_base(move_iterator<_Iterator> __it) -> decltype(__miter_base(__it.base()))     {
        return __miter_base(__it.base());
    }
}
namespace std {
    namespace __debug {
    }
}
namespace __gnu_debug {
    using namespace std::__debug;
}
namespace __gnu_cxx {
    namespace __ops {
        struct _Iter_less_iter {
            template <typename _Iterator1, typename _Iterator2> constexpr bool operator()(_Iterator1 __it1, _Iterator2 __it2) const             {
                return *__it1 < *__it2;
            }
        };
        inline constexpr __gnu_cxx::__ops::_Iter_less_iter __iter_less_iter()         {
            return __gnu_cxx::__ops::_Iter_less_iter();
        }
        struct _Iter_less_val {
            _Iter_less_val() noexcept = default
            explicit _Iter_less_val(__gnu_cxx::__ops::_Iter_less_iter)             {
            }
            template <typename _Iterator, typename _Value> bool operator()(_Iterator __it, _Value &__val) const             {
                return *__it < __val;
            }
        };
        inline __gnu_cxx::__ops::_Iter_less_val __iter_less_val()         {
            return __gnu_cxx::__ops::_Iter_less_val();
        }
        inline __gnu_cxx::__ops::_Iter_less_val __iter_comp_val(__gnu_cxx::__ops::_Iter_less_iter)         {
            return __gnu_cxx::__ops::_Iter_less_val();
        }
        struct _Val_less_iter {
            _Val_less_iter() noexcept = default
            explicit _Val_less_iter(__gnu_cxx::__ops::_Iter_less_iter)             {
            }
            template <typename _Value, typename _Iterator> bool operator()(_Value &__val, _Iterator __it) const             {
                return __val < *__it;
            }
        };
        inline __gnu_cxx::__ops::_Val_less_iter __val_less_iter()         {
            return __gnu_cxx::__ops::_Val_less_iter();
        }
        inline __gnu_cxx::__ops::_Val_less_iter __val_comp_iter(__gnu_cxx::__ops::_Iter_less_iter)         {
            return __gnu_cxx::__ops::_Val_less_iter();
        }
        struct _Iter_equal_to_iter {
            template <typename _Iterator1, typename _Iterator2> bool operator()(_Iterator1 __it1, _Iterator2 __it2) const             {
                return *__it1 == *__it2;
            }
        };
        inline __gnu_cxx::__ops::_Iter_equal_to_iter __iter_equal_to_iter()         {
            return __gnu_cxx::__ops::_Iter_equal_to_iter();
        }
        struct _Iter_equal_to_val {
            template <typename _Iterator, typename _Value> bool operator()(_Iterator __it, _Value &__val) const             {
                return *__it == __val;
            }
        };
        inline __gnu_cxx::__ops::_Iter_equal_to_val __iter_equal_to_val()         {
            return __gnu_cxx::__ops::_Iter_equal_to_val();
        }
        inline __gnu_cxx::__ops::_Iter_equal_to_val __iter_comp_val(__gnu_cxx::__ops::_Iter_equal_to_iter)         {
            return __gnu_cxx::__ops::_Iter_equal_to_val();
        }
        template <typename _Compare> struct _Iter_comp_iter {
            _Compare _M_comp;
            constexpr explicit _Iter_comp_iter<_Compare>(_Compare __comp) : _M_comp(std::move(__comp))             {
            }
            template <typename _Iterator1, typename _Iterator2> constexpr bool operator()(_Iterator1 __it1, _Iterator2 __it2)             {
                return bool(this->_M_comp(*__it1, *__it2));
            }
        };
        template <typename _Compare> inline constexpr _Iter_comp_iter<_Compare> __iter_comp_iter(_Compare __comp)         {
            return _Iter_comp_iter<_Compare>(std::move(__comp));
        }
        template <typename _Compare> struct _Iter_comp_val {
            _Compare _M_comp;
            explicit _Iter_comp_val<_Compare>(_Compare __comp) : _M_comp(std::move(__comp))             {
            }
            explicit _Iter_comp_val<_Compare>(const _Iter_comp_iter<_Compare> &__comp) : _M_comp(__comp._M_comp)             {
            }
            explicit _Iter_comp_val<_Compare>(_Iter_comp_iter<_Compare> &&__comp) : _M_comp(std::move(__comp._M_comp))             {
            }
            template <typename _Iterator, typename _Value> bool operator()(_Iterator __it, _Value &__val)             {
                return bool(this->_M_comp(*__it, __val));
            }
        };
        template <typename _Compare> inline _Iter_comp_val<_Compare> __iter_comp_val(_Compare __comp)         {
            return _Iter_comp_val<_Compare>(std::move(__comp));
        }
        template <typename _Compare> inline _Iter_comp_val<_Compare> __iter_comp_val(_Iter_comp_iter<_Compare> __comp)         {
            return _Iter_comp_val<_Compare>(std::move(__comp));
        }
        template <typename _Compare> struct _Val_comp_iter {
            _Compare _M_comp;
            explicit _Val_comp_iter<_Compare>(_Compare __comp) : _M_comp(std::move(__comp))             {
            }
            explicit _Val_comp_iter<_Compare>(const _Iter_comp_iter<_Compare> &__comp) : _M_comp(__comp._M_comp)             {
            }
            explicit _Val_comp_iter<_Compare>(_Iter_comp_iter<_Compare> &&__comp) : _M_comp(std::move(__comp._M_comp))             {
            }
            template <typename _Value, typename _Iterator> bool operator()(_Value &__val, _Iterator __it)             {
                return bool(this->_M_comp(__val, *__it));
            }
        };
        template <typename _Compare> inline _Val_comp_iter<_Compare> __val_comp_iter(_Compare __comp)         {
            return _Val_comp_iter<_Compare>(std::move(__comp));
        }
        template <typename _Compare> inline _Val_comp_iter<_Compare> __val_comp_iter(_Iter_comp_iter<_Compare> __comp)         {
            return _Val_comp_iter<_Compare>(std::move(__comp));
        }
        template <typename _Value> struct _Iter_equals_val {
            _Value &_M_value;
            explicit _Iter_equals_val<_Value>(_Value &__value) : _M_value(__value)             {
            }
            template <typename _Iterator> bool operator()(_Iterator __it)             {
                return *__it == this->_M_value;
            }
        };
        template <typename _Value> inline _Iter_equals_val<_Value> __iter_equals_val(_Value &__val)         {
            return _Iter_equals_val<_Value>(__val);
        }
        template <typename _Iterator1> struct _Iter_equals_iter {
            _Iterator1 _M_it1;
            explicit _Iter_equals_iter<_Iterator1>(_Iterator1 __it1) : _M_it1(__it1)             {
            }
            template <typename _Iterator2> bool operator()(_Iterator2 __it2)             {
                return *__it2 == *this->_M_it1;
            }
        };
        template <typename _Iterator> inline _Iter_equals_iter<_Iterator> __iter_comp_iter(__gnu_cxx::__ops::_Iter_equal_to_iter, _Iterator __it)         {
            return _Iter_equals_iter<_Iterator>(__it);
        }
        template <typename _Predicate> struct _Iter_pred {
            _Predicate _M_pred;
            explicit _Iter_pred<_Predicate>(_Predicate __pred) : _M_pred(std::move(__pred))             {
            }
            template <typename _Iterator> bool operator()(_Iterator __it)             {
                return bool(this->_M_pred(*__it));
            }
        };
        template <typename _Predicate> inline _Iter_pred<_Predicate> __pred_iter(_Predicate __pred)         {
            return _Iter_pred<_Predicate>(std::move(__pred));
        }
        template <typename _Compare, typename _Value> struct _Iter_comp_to_val {
            _Compare _M_comp;
            _Value &_M_value;
            _Iter_comp_to_val<_Compare, _Value>(_Compare __comp, _Value &__value) : _M_comp(std::move(__comp)), _M_value(__value)             {
            }
            template <typename _Iterator> bool operator()(_Iterator __it)             {
                return bool(this->_M_comp(*__it, this->_M_value));
            }
        };
        template <typename _Compare, typename _Value> _Iter_comp_to_val<_Compare, _Value> __iter_comp_val(_Compare __comp, _Value &__val)         {
            return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
        }
        template <typename _Compare, typename _Iterator1> struct _Iter_comp_to_iter {
            _Compare _M_comp;
            _Iterator1 _M_it1;
            _Iter_comp_to_iter<_Compare, _Iterator1>(_Compare __comp, _Iterator1 __it1) : _M_comp(std::move(__comp)), _M_it1(__it1)             {
            }
            template <typename _Iterator2> bool operator()(_Iterator2 __it2)             {
                return bool(this->_M_comp(*__it2, *this->_M_it1));
            }
        };
        template <typename _Compare, typename _Iterator> inline _Iter_comp_to_iter<_Compare, _Iterator> __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)         {
            return _Iter_comp_to_iter<_Compare, _Iterator>(std::move(__comp._M_comp), __it);
        }
        template <typename _Predicate> struct _Iter_negate {
            _Predicate _M_pred;
            explicit _Iter_negate<_Predicate>(_Predicate __pred) : _M_pred(std::move(__pred))             {
            }
            template <typename _Iterator> bool operator()(_Iterator __it)             {
                return !bool(this->_M_pred(*__it));
            }
        };
        template <typename _Predicate> inline _Iter_negate<_Predicate> __negate(_Iter_pred<_Predicate> __pred)         {
            return _Iter_negate<_Predicate>(std::move(__pred._M_pred));
        }
    }
}
namespace std {
    template <typename _ForwardIterator1, typename _ForwardIterator2> inline void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)     {
        swap(*__a, *__b);
    }
    template <typename _ForwardIterator1, typename _ForwardIterator2> _ForwardIterator2 swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)     {
        ;
        for (; __first1 != __last1; ++__first1 , (void)++__first2)
            std::iter_swap(__first1, __first2);
        return __first2;
    }
    template <typename _Tp> inline constexpr const _Tp &min(const _Tp &__a, const _Tp &__b)     {
        if (__b < __a)
            return __b;
        return __a;
    }
    template<> inline constexpr const unsigned long &min<unsigned long>(const unsigned long &__a, const unsigned long &__b)     {
        if (__b < __a)
            return __b;
        return __a;
    }
    template<> inline constexpr const long &min<long>(const long &__a, const long &__b)     {
        if (__b < __a)
            return __b;
        return __a;
    }
    template <typename _Tp> inline constexpr const _Tp &max(const _Tp &__a, const _Tp &__b)     {
        if (__a < __b)
            return __b;
        return __a;
    }
    template <typename _Tp, typename _Compare> inline constexpr const _Tp &min(const _Tp &__a, const _Tp &__b, _Compare __comp)     {
        if (__comp(__b, __a))
            return __b;
        return __a;
    }
    template <typename _Tp, typename _Compare> inline constexpr const _Tp &max(const _Tp &__a, const _Tp &__b, _Compare __comp)     {
        if (__comp(__a, __b))
            return __b;
        return __a;
    }
    template <typename _Iterator> inline _Iterator __niter_base(_Iterator __it) noexcept(std::is_nothrow_copy_constructible<_Iterator>::value__niter_base(_Iterator __it) noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)     {
        return __it;
    }
    template <typename _From, typename _To> inline _From __niter_wrap(_From __from, _To __res)     {
        return __from + (__res - std::__niter_base(__from));
    }
    template <typename _Iterator> inline _Iterator __niter_wrap(const _Iterator &, _Iterator __res)     {
        return __res;
    }
    template <bool _IsMove, bool _IsSimple, typename _Category> struct __copy_move {
        template <typename _II, typename _OI> static _OI __copy_m(_II __first, _II __last, _OI __result)         {
            for (; __first != __last; ++__result , (void)++__first)
                *__result = *__first;
            return __result;
        }
    };
    template <typename _Category> struct __copy_move<true, false, _Category> {
        template <typename _II, typename _OI> static _OI __copy_m(_II __first, _II __last, _OI __result)         {
            for (; __first != __last; ++__result , (void)++__first)
                *__result = std::move(*__first);
            return __result;
        }
    };
    template<> struct __copy_move<false, false, std::random_access_iterator_tag> {
        template <typename _II, typename _OI> static _OI __copy_m(_II __first, _II __last, _OI __result)         {
            typedef typename iterator_traits<_II>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                *__result = *__first;
                ++__first;
                ++__result;
            }
            return __result;
        }
    };
    template<> struct __copy_move<true, false, std::random_access_iterator_tag> {
        template <typename _II, typename _OI> static _OI __copy_m(_II __first, _II __last, _OI __result)         {
            typedef typename iterator_traits<_II>::difference_type _Distance;
            for (_Distance __n = __last - __first; __n > 0; --__n) {
                *__result = std::move(*__first);
                ++__first;
                ++__result;
            }
            return __result;
        }
    };
    template <bool _IsMove> struct __copy_move<_IsMove, true, std::random_access_iterator_tag> {
        template <typename _Tp> static _Tp *__copy_m(const _Tp *__first, const _Tp *__last, _Tp *__result)         {
            using __assignable = conditional<_IsMove, is_move_assignable<_Tp>, is_copy_assignable<_Tp> >;
            static_assert(__assignable::type::value, "type is not assignable");
            const std::ptrdiff_t _Num = __last - __first;
            if (_Num)
                __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
            return __result + _Num;
        }
    };
    template <bool _IsMove, typename _II, typename _OI> inline _OI __copy_move_a(_II __first, _II __last, _OI __result)     {
        typedef typename iterator_traits<_II>::value_type _ValueTypeI;
        typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
        typedef typename iterator_traits<_II>::iterator_category _Category;
        const bool __simple = (__is_trivially_copyable(_ValueTypeI) && __is_pointer<_II>::__value && __is_pointer<_OI>::__value && __are_same<_ValueTypeI, _ValueTypeO>::__value);
        return std::__copy_move<_IsMove, __simple, _Category>::__copy_m(__first, __last, __result);
    }
    template <typename _CharT> struct char_traits;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class istreambuf_iterator;
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class ostreambuf_iterator;
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type __copy_move_a2(_CharT *, _CharT *, ostreambuf_iterator<_CharT, char_traits<_CharT> >);
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type __copy_move_a2(const _CharT *, const _CharT *, ostreambuf_iterator<_CharT, char_traits<_CharT> >);
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >, istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT *);
    template <bool _IsMove, typename _II, typename _OI> inline _OI __copy_move_a2(_II __first, _II __last, _OI __result)     {
        return std::__niter_wrap(__result, std::__copy_move_a<_IsMove>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template <typename _II, typename _OI> inline _OI copy(_II __first, _II __last, _OI __result)     {
        ;
        return std::__copy_move_a2<__is_move_iterator<_II>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <typename _II, typename _OI> inline _OI move(_II __first, _II __last, _OI __result)     {
        ;
        return std::__copy_move_a2<true>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <bool, bool, typename> struct __copy_move_backward {
        template <typename _BI1, typename _BI2> static _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)         {
            while (__first != __last)
                *--__result = *--__last;
            return __result;
        }
    };
    template <typename _Category> struct __copy_move_backward<true, false, _Category> {
        template <typename _BI1, typename _BI2> static _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)         {
            while (__first != __last)
                *--__result = std::move(*--__last);
            return __result;
        }
    };
    template<> struct __copy_move_backward<false, false, std::random_access_iterator_tag> {
        template <typename _BI1, typename _BI2> static _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)         {
            typename iterator_traits<_BI1>::difference_type __n;
            for (__n = __last - __first; __n > 0; --__n)
                *--__result = *--__last;
            return __result;
        }
    };
    template<> struct __copy_move_backward<true, false, std::random_access_iterator_tag> {
        template <typename _BI1, typename _BI2> static _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)         {
            typename iterator_traits<_BI1>::difference_type __n;
            for (__n = __last - __first; __n > 0; --__n)
                *--__result = std::move(*--__last);
            return __result;
        }
    };
    template <bool _IsMove> struct __copy_move_backward<_IsMove, true, std::random_access_iterator_tag> {
        template <typename _Tp> static _Tp *__copy_move_b(const _Tp *__first, const _Tp *__last, _Tp *__result)         {
            using __assignable = conditional<_IsMove, is_move_assignable<_Tp>, is_copy_assignable<_Tp> >;
            static_assert(__assignable::type::value, "type is not assignable");
            const std::ptrdiff_t _Num = __last - __first;
            if (_Num)
                __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
            return __result - _Num;
        }
    };
    template <bool _IsMove, typename _BI1, typename _BI2> inline _BI2 __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)     {
        typedef typename iterator_traits<_BI1>::value_type _ValueType1;
        typedef typename iterator_traits<_BI2>::value_type _ValueType2;
        typedef typename iterator_traits<_BI1>::iterator_category _Category;
        const bool __simple = (__is_trivially_copyable(_ValueType1) && __is_pointer<_BI1>::__value && __is_pointer<_BI2>::__value && __are_same<_ValueType1, _ValueType2>::__value);
        return std::__copy_move_backward<_IsMove, __simple, _Category>::__copy_move_b(__first, __last, __result);
    }
    template <bool _IsMove, typename _BI1, typename _BI2> inline _BI2 __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)     {
        return std::__niter_wrap(__result, std::__copy_move_backward_a<_IsMove>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
    }
    template <typename _BI1, typename _BI2> inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)     {
        ;
        return std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <typename _BI1, typename _BI2> inline _BI2 move_backward(_BI1 __first, _BI1 __last, _BI2 __result)     {
        ;
        return std::__copy_move_backward_a2<true>(std::__miter_base(__first), std::__miter_base(__last), __result);
    }
    template <typename _ForwardIterator, typename _Tp> inline typename __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type __fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)     {
        for (; __first != __last; ++__first)
            *__first = __value;
    }
    template <typename _ForwardIterator, typename _Tp> inline typename __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type __fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)     {
        const _Tp __tmp = __value;
        for (; __first != __last; ++__first)
            *__first = __tmp;
    }
    template <typename _Tp> inline typename __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type __fill_a(_Tp *__first, _Tp *__last, const _Tp &__c)     {
        const _Tp __tmp = __c;
        if (const std::size_t __len = __last - __first)
            __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }
    template <typename _ForwardIterator, typename _Tp> inline void fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)     {
        ;
        std::__fill_a(std::__niter_base(__first), std::__niter_base(__last), __value);
    }
    template <typename _OutputIterator, typename _Size, typename _Tp> inline typename __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value)     {
        for (decltype(__n + 0) __niter = __n; __niter > 0; --__niter , (void)++__first)
            *__first = __value;
        return __first;
    }
    template <typename _OutputIterator, typename _Size, typename _Tp> inline typename __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value)     {
        const _Tp __tmp = __value;
        for (decltype(__n + 0) __niter = __n; __niter > 0; --__niter , (void)++__first)
            *__first = __tmp;
        return __first;
    }
    template <typename _Size, typename _Tp> inline typename __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp *>::__type __fill_n_a(_Tp *__first, _Size __n, const _Tp &__c)     {
        std::__fill_a(__first, __first + __n, __c);
        return __first + __n;
    }
    template <typename _OI, typename _Size, typename _Tp> inline _OI fill_n(_OI __first, _Size __n, const _Tp &__value)     {
        ;
        return std::__niter_wrap(__first, std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }
    template <bool _BoolType> struct __equal {
        template <typename _II1, typename _II2> static bool equal(_II1 __first1, _II1 __last1, _II2 __first2)         {
            for (; __first1 != __last1; ++__first1 , (void)++__first2)
                if (!(*__first1 == *__first2))
                    return false;
            return true;
        }
    };
    template<> struct __equal<true> {
        template <typename _Tp> static bool equal(const _Tp *__first1, const _Tp *__last1, const _Tp *__first2)         {
            if (const std::size_t __len = (__last1 - __first1))
                return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
            return true;
        }
    };
    template <typename _II1, typename _II2> inline bool __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)     {
        typedef typename iterator_traits<_II1>::value_type _ValueType1;
        typedef typename iterator_traits<_II2>::value_type _ValueType2;
        const bool __simple = ((__is_integer<_ValueType1>::__value || __is_pointer<_ValueType1>::__value) && __is_pointer<_II1>::__value && __is_pointer<_II2>::__value && __are_same<_ValueType1, _ValueType2>::__value);
        return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }
    template <typename, typename> struct __lc_rai {
        template <typename _II1, typename _II2> static _II1 __newlast1(_II1, _II1 __last1, _II2, _II2)         {
            return __last1;
        }
        template <typename _II> static bool __cnd2(_II __first, _II __last)         {
            return __first != __last;
        }
    };
    template<> struct __lc_rai<std::random_access_iterator_tag, std::random_access_iterator_tag> {
        template <typename _RAI1, typename _RAI2> static _RAI1 __newlast1(_RAI1 __first1, _RAI1 __last1, _RAI2 __first2, _RAI2 __last2)         {
            const typename iterator_traits<_RAI1>::difference_type __diff1 = __last1 - __first1;
            const typename iterator_traits<_RAI2>::difference_type __diff2 = __last2 - __first2;
            return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
        }
        template <typename _RAI> static bool __cnd2(_RAI, _RAI)         {
            return true;
        }
    };
    template <typename _II1, typename _II2, typename _Compare> bool __lexicographical_compare_impl(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)     {
        typedef typename iterator_traits<_II1>::iterator_category _Category1;
        typedef typename iterator_traits<_II2>::iterator_category _Category2;
        typedef std::__lc_rai<_Category1, _Category2> __rai_type;
        __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
        for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2); ++__first1 , (void)++__first2) {
            if (__comp(__first1, __first2))
                return true;
            if (__comp(__first2, __first1))
                return false;
        }
        return __first1 == __last1 && __first2 != __last2;
    }
    template <bool _BoolType> struct __lexicographical_compare {
        template <typename _II1, typename _II2> static bool __lc(_II1, _II1, _II2, _II2);
    };
    template <bool _BoolType> template <typename _II1, typename _II2> bool __lexicographical_compare<_BoolType>::__lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)     {
        return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_less_iter());
    }
    template<> struct __lexicographical_compare<true> {
        template <typename _Tp, typename _Up> static bool __lc(const _Tp *__first1, const _Tp *__last1, const _Up *__first2, const _Up *__last2)         {
            const std::size_t __len1 = __last1 - __first1;
            const std::size_t __len2 = __last2 - __first2;
            if (const std::size_t __len = std::min(__len1, __len2))
                if (int __result = __builtin_memcmp(__first1, __first2, __len))
                    return __result < 0;
            return __len1 < __len2;
        }
    };
    template <typename _II1, typename _II2> inline bool __lexicographical_compare_aux(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)     {
        typedef typename iterator_traits<_II1>::value_type _ValueType1;
        typedef typename iterator_traits<_II2>::value_type _ValueType2;
        const bool __simple = (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed && __is_pointer<_II1>::__value && __is_pointer<_II2>::__value);
        return std::__lexicographical_compare<__simple>::__lc(__first1, __last1, __first2, __last2);
    }
    template <typename _ForwardIterator, typename _Tp, typename _Compare> _ForwardIterator __lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)     {
        typedef typename iterator_traits<_ForwardIterator>::difference_type _DistanceType;
        _DistanceType __len = std::distance(__first, __last);
        while (__len > 0)
            {
                _DistanceType __half = __len >> 1;
                _ForwardIterator __middle = __first;
                std::advance(__middle, __half);
                if (__comp(__middle, __val)) {
                    __first = __middle;
                    ++__first;
                    __len = __len - __half - 1;
                } else
                    __len = __half;
            }
        return __first;
    }
    template <typename _ForwardIterator, typename _Tp> inline _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)     {
        ;
        return std::__lower_bound(__first, __last, __val, __gnu_cxx::__ops::__iter_less_val());
    }
    inline constexpr int __lg(int __n)     {
        return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n);
    }
    inline constexpr unsigned int __lg(unsigned int __n)     {
        return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n);
    }
    inline constexpr long __lg(long __n)     {
        return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n);
    }
    inline constexpr unsigned long __lg(unsigned long __n)     {
        return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n);
    }
    inline constexpr long long __lg(long long __n)     {
        return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n);
    }
    inline constexpr unsigned long long __lg(unsigned long long __n)     {
        return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n);
    }
    template <typename _II1, typename _II2> inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2)     {
        ;
        return std::__equal_aux(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2));
    }
    template <typename _IIter1, typename _IIter2, typename _BinaryPredicate> inline bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _BinaryPredicate __binary_pred)     {
        ;
        for (; __first1 != __last1; ++__first1 , (void)++__first2)
            if (!bool(__binary_pred(*__first1, *__first2)))
                return false;
        return true;
    }
    template <typename _II1, typename _II2> inline bool __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)     {
        using _RATag = std::random_access_iterator_tag;
        using _Cat1 = typename iterator_traits<_II1>::iterator_category;
        using _Cat2 = typename iterator_traits<_II2>::iterator_category;
        using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag> >;
        if (_RAIters()) {
            auto __d1 = std::distance(__first1, __last1);
            auto __d2 = std::distance(__first2, __last2);
            if (__d1 != __d2)
                return false;
            return std::equal(__first1, __last1, __first2);
        }
        for (; __first1 != __last1 && __first2 != __last2; ++__first1 , (void)++__first2)
            if (!(*__first1 == *__first2))
                return false;
        return __first1 == __last1 && __first2 == __last2;
    }
    template <typename _II1, typename _II2, typename _BinaryPredicate> inline bool __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _BinaryPredicate __binary_pred)     {
        using _RATag = std::random_access_iterator_tag;
        using _Cat1 = typename iterator_traits<_II1>::iterator_category;
        using _Cat2 = typename iterator_traits<_II2>::iterator_category;
        using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag> >;
        if (_RAIters()) {
            auto __d1 = std::distance(__first1, __last1);
            auto __d2 = std::distance(__first2, __last2);
            if (__d1 != __d2)
                return false;
            return std::equal(__first1, __last1, __first2, __binary_pred);
        }
        for (; __first1 != __last1 && __first2 != __last2; ++__first1 , (void)++__first2)
            if (!bool(__binary_pred(*__first1, *__first2)))
                return false;
        return __first1 == __last1 && __first2 == __last2;
    }
    template <typename _II1, typename _II2> inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)     {
        ;
        ;
        return std::__equal4(__first1, __last1, __first2, __last2);
    }
    template <typename _IIter1, typename _IIter2, typename _BinaryPredicate> inline bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)     {
        ;
        ;
        return std::__equal4(__first1, __last1, __first2, __last2, __binary_pred);
    }
    template <typename _II1, typename _II2> inline bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)     {
        ;
        ;
        return std::__lexicographical_compare_aux(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2), std::__niter_base(__last2));
    }
    template <typename _II1, typename _II2, typename _Compare> inline bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)     {
        ;
        ;
        return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> pair<_InputIterator1, _InputIterator2> __mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)     {
        while (__first1 != __last1 && __binary_pred(__first1, __first2))
            {
                ++__first1;
                ++__first2;
            }
        return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
    template <typename _InputIterator1, typename _InputIterator2> inline pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)     {
        ;
        return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_equal_to_iter());
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> inline pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)     {
        ;
        return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> pair<_InputIterator1, _InputIterator2> __mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __binary_pred)     {
        while (__first1 != __last1 && __first2 != __last2 && __binary_pred(__first1, __first2))
            {
                ++__first1;
                ++__first2;
            }
        return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
    template <typename _InputIterator1, typename _InputIterator2> inline pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)     {
        ;
        ;
        return std::__mismatch(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_equal_to_iter());
    }
    template <typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate> inline pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __binary_pred)     {
        ;
        ;
        return std::__mismatch(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
}
namespace __gnu_cxx {
    template <typename _CharT> struct _Char_types {
        typedef unsigned long int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef std::mbstate_t state_type;
    };
    template <typename _CharT> struct char_traits {
        typedef _CharT char_type;
        typedef typename _Char_types<_CharT>::int_type int_type;
        typedef typename _Char_types<_CharT>::pos_type pos_type;
        typedef typename _Char_types<_CharT>::off_type off_type;
        typedef typename _Char_types<_CharT>::state_type state_type;
        static constexpr void assign(__gnu_cxx::char_traits::char_type &__c1, const __gnu_cxx::char_traits::char_type &__c2)         {
            __c1 = __c2;
        }
        static constexpr bool eq(const __gnu_cxx::char_traits::char_type &__c1, const __gnu_cxx::char_traits::char_type &__c2)         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const __gnu_cxx::char_traits::char_type &__c1, const __gnu_cxx::char_traits::char_type &__c2)         {
            return __c1 < __c2;
        }
        static constexpr int compare(const __gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n);
        static constexpr std::size_t length(const __gnu_cxx::char_traits::char_type *__s);
        static constexpr const __gnu_cxx::char_traits::char_type *find(const __gnu_cxx::char_traits::char_type *__s, std::size_t __n, const __gnu_cxx::char_traits::char_type &__a);
        static __gnu_cxx::char_traits::char_type *move(__gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n);
        static __gnu_cxx::char_traits::char_type *copy(__gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n);
        static __gnu_cxx::char_traits::char_type *assign(__gnu_cxx::char_traits::char_type *__s, std::size_t __n, __gnu_cxx::char_traits::char_type __a);
        static constexpr __gnu_cxx::char_traits::char_type to_char_type(const __gnu_cxx::char_traits::int_type &__c)         {
            return static_cast<__gnu_cxx::char_traits::char_type>(__c);
        }
        static constexpr __gnu_cxx::char_traits::int_type to_int_type(const __gnu_cxx::char_traits::char_type &__c)         {
            return static_cast<__gnu_cxx::char_traits::int_type>(__c);
        }
        static constexpr bool eq_int_type(const __gnu_cxx::char_traits::int_type &__c1, const __gnu_cxx::char_traits::int_type &__c2)         {
            return __c1 == __c2;
        }
        static constexpr __gnu_cxx::char_traits::int_type eof()         {
            return static_cast<__gnu_cxx::char_traits::int_type>(-1);
        }
        static constexpr __gnu_cxx::char_traits::int_type not_eof(const __gnu_cxx::char_traits::int_type &__c)         {
            return !eq_int_type(__c, eof()) ? __c : to_int_type(__gnu_cxx::char_traits::char_type());
        }
    };
    template <typename _CharT> constexpr int char_traits<_CharT>::compare(const __gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n)     {
        for (std::size_t __i = 0; __i < __n; ++__i)
            if (lt(__s1[__i], __s2[__i]))
                return -1;
            else if (lt(__s2[__i], __s1[__i]))
                return 1;
        return 0;
    }
    template <typename _CharT> constexpr std::size_t char_traits<_CharT>::length(const __gnu_cxx::char_traits::char_type *__p)     {
        std::size_t __i = 0;
        while (!eq(__p[__i], __gnu_cxx::char_traits::char_type()))
            ++__i;
        return __i;
    }
    template <typename _CharT> constexpr const typename char_traits<_CharT>::char_type *char_traits<_CharT>::find(const __gnu_cxx::char_traits::char_type *__s, std::size_t __n, const __gnu_cxx::char_traits::char_type &__a)     {
        for (std::size_t __i = 0; __i < __n; ++__i)
            if (eq(__s[__i], __a))
                return __s + __i;
        return 0;
    }
    template <typename _CharT> typename char_traits<_CharT>::char_type *char_traits<_CharT>::move(__gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n)     {
        if (__n == 0)
            return __s1;
        return static_cast<_CharT *>(__builtin_memmove(__s1, __s2, __n * sizeof(__gnu_cxx::char_traits::char_type)));
    }
    template <typename _CharT> typename char_traits<_CharT>::char_type *char_traits<_CharT>::copy(__gnu_cxx::char_traits::char_type *__s1, const __gnu_cxx::char_traits::char_type *__s2, std::size_t __n)     {
        std::copy(__s2, __s2 + __n, __s1);
        return __s1;
    }
    template <typename _CharT> typename char_traits<_CharT>::char_type *char_traits<_CharT>::assign(__gnu_cxx::char_traits::char_type *__s, std::size_t __n, __gnu_cxx::char_traits::char_type __a)     {
        std::fill_n(__s, __n, __a);
        return __s;
    }
}
namespace std {
    template <class _CharT> struct char_traits : public __gnu_cxx::char_traits<_CharT> {
    };
    template<> struct char_traits<char> {
        typedef char char_type;
        typedef int int_type;
        typedef std::streampos pos_type;
        typedef std::streamoff off_type;
        typedef mbstate_t state_type;
        static void assign(std::char_traits<char>::char_type &__c1, const std::char_traits<char>::char_type &__c2) noexcept         {
            __c1 = __c2;
        }
        static constexpr bool eq(const std::char_traits<char>::char_type &__c1, const std::char_traits<char>::char_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const std::char_traits<char>::char_type &__c1, const std::char_traits<char>::char_type &__c2) noexcept         {
            return (static_cast<unsigned char>(__c1) < static_cast<unsigned char>(__c2));
        }
        static int compare(const std::char_traits<char>::char_type *__s1, const std::char_traits<char>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return 0;
            return __builtin_memcmp(__s1, __s2, __n);
        }
        static std::size_t length(const std::char_traits<char>::char_type *__s)         {
            return __builtin_strlen(__s);
        }
        static const std::char_traits<char>::char_type *find(const std::char_traits<char>::char_type *__s, std::size_t __n, const std::char_traits<char>::char_type &__a)         {
            if (__n == 0)
                return 0;
            return static_cast<const std::char_traits<char>::char_type *>(__builtin_memchr(__s, __a, __n));
        }
        static std::char_traits<char>::char_type *move(std::char_traits<char>::char_type *__s1, const std::char_traits<char>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            return static_cast<std::char_traits<char>::char_type *>(__builtin_memmove(__s1, __s2, __n));
        }
        static std::char_traits<char>::char_type *copy(std::char_traits<char>::char_type *__s1, const std::char_traits<char>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            return static_cast<std::char_traits<char>::char_type *>(__builtin_memcpy(__s1, __s2, __n));
        }
        static std::char_traits<char>::char_type *assign(std::char_traits<char>::char_type *__s, std::size_t __n, std::char_traits<char>::char_type __a)         {
            if (__n == 0)
                return __s;
            return static_cast<std::char_traits<char>::char_type *>(__builtin_memset(__s, __a, __n));
        }
        static constexpr std::char_traits<char>::char_type to_char_type(const std::char_traits<char>::int_type &__c) noexcept         {
            return static_cast<std::char_traits<char>::char_type>(__c);
        }
        static constexpr std::char_traits<char>::int_type to_int_type(const std::char_traits<char>::char_type &__c) noexcept         {
            return static_cast<std::char_traits<char>::int_type>(static_cast<unsigned char>(__c));
        }
        static constexpr bool eq_int_type(const std::char_traits<char>::int_type &__c1, const std::char_traits<char>::int_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr std::char_traits<char>::int_type eof() noexcept         {
            return static_cast<std::char_traits<char>::int_type>(-1);
        }
        static constexpr std::char_traits<char>::int_type not_eof(const std::char_traits<char>::int_type &__c) noexcept         {
            return (__c == eof()) ? 0 : __c;
        }
    };
    template<> struct char_traits<wchar_t> {
        typedef wchar_t char_type;
        typedef wint_t int_type;
        typedef std::streamoff off_type;
        typedef std::wstreampos pos_type;
        typedef mbstate_t state_type;
        static void assign(std::char_traits<wchar_t>::char_type &__c1, const std::char_traits<wchar_t>::char_type &__c2) noexcept         {
            __c1 = __c2;
        }
        static constexpr bool eq(const std::char_traits<wchar_t>::char_type &__c1, const std::char_traits<wchar_t>::char_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const std::char_traits<wchar_t>::char_type &__c1, const std::char_traits<wchar_t>::char_type &__c2) noexcept         {
            return __c1 < __c2;
        }
        static int compare(const std::char_traits<wchar_t>::char_type *__s1, const std::char_traits<wchar_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return 0;
            return wmemcmp(__s1, __s2, __n);
        }
        static std::size_t length(const std::char_traits<wchar_t>::char_type *__s)         {
            return wcslen(__s);
        }
        static const std::char_traits<wchar_t>::char_type *find(const std::char_traits<wchar_t>::char_type *__s, std::size_t __n, const std::char_traits<wchar_t>::char_type &__a)         {
            if (__n == 0)
                return 0;
            return wmemchr(__s, __a, __n);
        }
        static std::char_traits<wchar_t>::char_type *move(std::char_traits<wchar_t>::char_type *__s1, const std::char_traits<wchar_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            return wmemmove(__s1, __s2, __n);
        }
        static std::char_traits<wchar_t>::char_type *copy(std::char_traits<wchar_t>::char_type *__s1, const std::char_traits<wchar_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            return wmemcpy(__s1, __s2, __n);
        }
        static std::char_traits<wchar_t>::char_type *assign(std::char_traits<wchar_t>::char_type *__s, std::size_t __n, std::char_traits<wchar_t>::char_type __a)         {
            if (__n == 0)
                return __s;
            return wmemset(__s, __a, __n);
        }
        static constexpr std::char_traits<wchar_t>::char_type to_char_type(const std::char_traits<wchar_t>::int_type &__c) noexcept         {
            return std::char_traits<wchar_t>::char_type(__c);
        }
        static constexpr std::char_traits<wchar_t>::int_type to_int_type(const std::char_traits<wchar_t>::char_type &__c) noexcept         {
            return std::char_traits<wchar_t>::int_type(__c);
        }
        static constexpr bool eq_int_type(const std::char_traits<wchar_t>::int_type &__c1, const std::char_traits<wchar_t>::int_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr std::char_traits<wchar_t>::int_type eof() noexcept         {
            return static_cast<std::char_traits<wchar_t>::int_type>((4294967295U));
        }
        static constexpr std::char_traits<wchar_t>::int_type not_eof(const std::char_traits<wchar_t>::int_type &__c) noexcept         {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }
    };
}
typedef unsigned char __u_char;
typedef unsigned short __u_short;
typedef unsigned int __u_int;
typedef unsigned long __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long __int64_t;
typedef unsigned long __uint64_t;
typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;
typedef long __quad_t;
typedef unsigned long __u_quad_t;
typedef long __intmax_t;
typedef unsigned long __uintmax_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned long __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef struct {
    int __val[2];
} __fsid_t;
typedef long __clock_t;
typedef unsigned long __rlim_t;
typedef unsigned long __rlim64_t;
typedef unsigned int __id_t;
typedef long __time_t;
typedef unsigned int __useconds_t;
typedef long __suseconds_t;
typedef int __daddr_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void *__timer_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __blkcnt64_t;
typedef unsigned long __fsblkcnt_t;
typedef unsigned long __fsblkcnt64_t;
typedef unsigned long __fsfilcnt_t;
typedef unsigned long __fsfilcnt64_t;
typedef long __fsword_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef unsigned long __syscall_ulong_t;
typedef __off64_t __loff_t;
typedef char *__caddr_t;
typedef long __intptr_t;
typedef unsigned int __socklen_t;
typedef int __sig_atomic_t;
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;
typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;
typedef signed char int_fast8_t;
typedef long int_fast16_t;
typedef long int_fast32_t;
typedef long int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned long uint_fast16_t;
typedef unsigned long uint_fast32_t;
typedef unsigned long uint_fast64_t;
typedef long intptr_t;
typedef unsigned long uintptr_t;
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
namespace std {
    using ::int8_t;
    using ::int16_t;
    using ::int32_t;
    using ::int64_t;
    using ::int_fast8_t;
    using ::int_fast16_t;
    using ::int_fast32_t;
    using ::int_fast64_t;
    using ::int_least8_t;
    using ::int_least16_t;
    using ::int_least32_t;
    using ::int_least64_t;
    using ::intmax_t;
    using ::intptr_t;
    using ::uint8_t;
    using ::uint16_t;
    using ::uint32_t;
    using ::uint64_t;
    using ::uint_fast8_t;
    using ::uint_fast16_t;
    using ::uint_fast32_t;
    using ::uint_fast64_t;
    using ::uint_least8_t;
    using ::uint_least16_t;
    using ::uint_least32_t;
    using ::uint_least64_t;
    using ::uintmax_t;
    using ::uintptr_t;
}
namespace std {
    template<> struct char_traits<char16_t> {
        typedef char16_t char_type;
        typedef uint_least16_t int_type;
        typedef std::streamoff off_type;
        typedef std::u16streampos pos_type;
        typedef mbstate_t state_type;
        static void assign(std::char_traits<char16_t>::char_type &__c1, const std::char_traits<char16_t>::char_type &__c2) noexcept         {
            __c1 = __c2;
        }
        static constexpr bool eq(const std::char_traits<char16_t>::char_type &__c1, const std::char_traits<char16_t>::char_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const std::char_traits<char16_t>::char_type &__c1, const std::char_traits<char16_t>::char_type &__c2) noexcept         {
            return __c1 < __c2;
        }
        static int compare(const std::char_traits<char16_t>::char_type *__s1, const std::char_traits<char16_t>::char_type *__s2, std::size_t __n)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (lt(__s1[__i], __s2[__i]))
                    return -1;
                else if (lt(__s2[__i], __s1[__i]))
                    return 1;
            return 0;
        }
        static std::size_t length(const std::char_traits<char16_t>::char_type *__s)         {
            std::size_t __i = 0;
            while (!eq(__s[__i], std::char_traits<char16_t>::char_type()))
                ++__i;
            return __i;
        }
        static const std::char_traits<char16_t>::char_type *find(const std::char_traits<char16_t>::char_type *__s, std::size_t __n, const std::char_traits<char16_t>::char_type &__a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (eq(__s[__i], __a))
                    return __s + __i;
            return 0;
        }
        static std::char_traits<char16_t>::char_type *move(std::char_traits<char16_t>::char_type *__s1, const std::char_traits<char16_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            return (static_cast<std::char_traits<char16_t>::char_type *>(__builtin_memmove(__s1, __s2, __n * sizeof(std::char_traits<char16_t>::char_type))));
        }
        static std::char_traits<char16_t>::char_type *copy(std::char_traits<char16_t>::char_type *__s1, const std::char_traits<char16_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            return (static_cast<std::char_traits<char16_t>::char_type *>(__builtin_memcpy(__s1, __s2, __n * sizeof(std::char_traits<char16_t>::char_type))));
        }
        static std::char_traits<char16_t>::char_type *assign(std::char_traits<char16_t>::char_type *__s, std::size_t __n, std::char_traits<char16_t>::char_type __a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                assign(__s[__i], __a);
            return __s;
        }
        static constexpr std::char_traits<char16_t>::char_type to_char_type(const std::char_traits<char16_t>::int_type &__c) noexcept         {
            return std::char_traits<char16_t>::char_type(__c);
        }
        static constexpr std::char_traits<char16_t>::int_type to_int_type(const std::char_traits<char16_t>::char_type &__c) noexcept         {
            return __c == eof() ? std::char_traits<char16_t>::int_type(65533) : std::char_traits<char16_t>::int_type(__c);
        }
        static constexpr bool eq_int_type(const std::char_traits<char16_t>::int_type &__c1, const std::char_traits<char16_t>::int_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr std::char_traits<char16_t>::int_type eof() noexcept         {
            return static_cast<std::char_traits<char16_t>::int_type>(-1);
        }
        static constexpr std::char_traits<char16_t>::int_type not_eof(const std::char_traits<char16_t>::int_type &__c) noexcept         {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }
    };
    template<> struct char_traits<char32_t> {
        typedef char32_t char_type;
        typedef uint_least32_t int_type;
        typedef std::streamoff off_type;
        typedef std::u32streampos pos_type;
        typedef mbstate_t state_type;
        static void assign(std::char_traits<char32_t>::char_type &__c1, const std::char_traits<char32_t>::char_type &__c2) noexcept         {
            __c1 = __c2;
        }
        static constexpr bool eq(const std::char_traits<char32_t>::char_type &__c1, const std::char_traits<char32_t>::char_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr bool lt(const std::char_traits<char32_t>::char_type &__c1, const std::char_traits<char32_t>::char_type &__c2) noexcept         {
            return __c1 < __c2;
        }
        static int compare(const std::char_traits<char32_t>::char_type *__s1, const std::char_traits<char32_t>::char_type *__s2, std::size_t __n)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (lt(__s1[__i], __s2[__i]))
                    return -1;
                else if (lt(__s2[__i], __s1[__i]))
                    return 1;
            return 0;
        }
        static std::size_t length(const std::char_traits<char32_t>::char_type *__s)         {
            std::size_t __i = 0;
            while (!eq(__s[__i], std::char_traits<char32_t>::char_type()))
                ++__i;
            return __i;
        }
        static const std::char_traits<char32_t>::char_type *find(const std::char_traits<char32_t>::char_type *__s, std::size_t __n, const std::char_traits<char32_t>::char_type &__a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                if (eq(__s[__i], __a))
                    return __s + __i;
            return 0;
        }
        static std::char_traits<char32_t>::char_type *move(std::char_traits<char32_t>::char_type *__s1, const std::char_traits<char32_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            return (static_cast<std::char_traits<char32_t>::char_type *>(__builtin_memmove(__s1, __s2, __n * sizeof(std::char_traits<char32_t>::char_type))));
        }
        static std::char_traits<char32_t>::char_type *copy(std::char_traits<char32_t>::char_type *__s1, const std::char_traits<char32_t>::char_type *__s2, std::size_t __n)         {
            if (__n == 0)
                return __s1;
            return (static_cast<std::char_traits<char32_t>::char_type *>(__builtin_memcpy(__s1, __s2, __n * sizeof(std::char_traits<char32_t>::char_type))));
        }
        static std::char_traits<char32_t>::char_type *assign(std::char_traits<char32_t>::char_type *__s, std::size_t __n, std::char_traits<char32_t>::char_type __a)         {
            for (std::size_t __i = 0; __i < __n; ++__i)
                assign(__s[__i], __a);
            return __s;
        }
        static constexpr std::char_traits<char32_t>::char_type to_char_type(const std::char_traits<char32_t>::int_type &__c) noexcept         {
            return std::char_traits<char32_t>::char_type(__c);
        }
        static constexpr std::char_traits<char32_t>::int_type to_int_type(const std::char_traits<char32_t>::char_type &__c) noexcept         {
            return std::char_traits<char32_t>::int_type(__c);
        }
        static constexpr bool eq_int_type(const std::char_traits<char32_t>::int_type &__c1, const std::char_traits<char32_t>::int_type &__c2) noexcept         {
            return __c1 == __c2;
        }
        static constexpr std::char_traits<char32_t>::int_type eof() noexcept         {
            return static_cast<std::char_traits<char32_t>::int_type>(-1);
        }
        static constexpr std::char_traits<char32_t>::int_type not_eof(const std::char_traits<char32_t>::int_type &__c) noexcept         {
            return eq_int_type(__c, eof()) ? 0 : __c;
        }
    };
}
extern "C" {
    struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
        char int_p_cs_precedes;
        char int_p_sep_by_space;
        char int_n_cs_precedes;
        char int_n_sep_by_space;
        char int_p_sign_posn;
        char int_n_sign_posn;
    };
    extern char *setlocale(int __category, const char *__locale) throw();
    extern struct lconv *localeconv() throw();
    extern locale_t newlocale(int __category_mask, const char *__locale, locale_t __base) throw();
    extern locale_t duplocale(locale_t __dataset) throw();
    extern void freelocale(locale_t __dataset) throw();
    extern locale_t uselocale(locale_t __dataset) throw();
}
namespace std {
    using ::lconv;
    using ::setlocale;
    using ::localeconv;
}
namespace __gnu_cxx {
    extern "C" locale_t __uselocale(locale_t) throw()
}
namespace std {
    typedef __locale_t __c_locale;
    inline int __convert_from_v(const std::__c_locale &__cloc __attribute__((unused)), char *__out, const int __size __attribute__((unused)), const char *__fmt, ...)     {
        std::__c_locale __old = __gnu_cxx::__uselocale(__cloc);
        __builtin_va_list __args;
        __builtin_va_start(__args, __fmt);
        const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);
        __builtin_va_end(__args);
        __gnu_cxx::__uselocale(__old);
        return __ret;
    }
}
extern "C" {
    enum  {
        _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
        _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
        _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
        _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
        _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
        _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
        _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
        _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
        _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
        _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
        _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
        _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
    };
    extern const unsigned short **__ctype_b_loc() throw() __attribute__((const));
    extern const __int32_t **__ctype_tolower_loc() throw() __attribute__((const));
    extern const __int32_t **__ctype_toupper_loc() throw() __attribute__((const));
    extern int isalnum(int) throw();
    extern int isalpha(int) throw();
    extern int iscntrl(int) throw();
    extern int isdigit(int) throw();
    extern int islower(int) throw();
    extern int isgraph(int) throw();
    extern int isprint(int) throw();
    extern int ispunct(int) throw();
    extern int isspace(int) throw();
    extern int isupper(int) throw();
    extern int isxdigit(int) throw();
    extern int tolower(int __c) throw();
    extern int toupper(int __c) throw();
    extern int isblank(int) throw();
    extern int isctype(int __c, int __mask) throw();
    extern int isascii(int __c) throw();
    extern int toascii(int __c) throw();
    extern int _toupper(int) throw();
    extern int _tolower(int) throw();
    extern int isalnum_l(int, locale_t) throw();
    extern int isalpha_l(int, locale_t) throw();
    extern int iscntrl_l(int, locale_t) throw();
    extern int isdigit_l(int, locale_t) throw();
    extern int islower_l(int, locale_t) throw();
    extern int isgraph_l(int, locale_t) throw();
    extern int isprint_l(int, locale_t) throw();
    extern int ispunct_l(int, locale_t) throw();
    extern int isspace_l(int, locale_t) throw();
    extern int isupper_l(int, locale_t) throw();
    extern int isxdigit_l(int, locale_t) throw();
    extern int isblank_l(int, locale_t) throw();
    extern int __tolower_l(int __c, locale_t __l) throw();
    extern int tolower_l(int __c, locale_t __l) throw();
    extern int __toupper_l(int __c, locale_t __l) throw();
    extern int toupper_l(int __c, locale_t __l) throw();
}
namespace std {
    using ::isalnum;
    using ::isalpha;
    using ::iscntrl;
    using ::isdigit;
    using ::isgraph;
    using ::islower;
    using ::isprint;
    using ::ispunct;
    using ::isspace;
    using ::isupper;
    using ::isxdigit;
    using ::tolower;
    using ::toupper;
}
namespace std {
    using ::isblank;
}
namespace std {
    class locale;
    template <typename _Facet> bool has_facet(const std::locale &) throw();
    template <typename _Facet> const _Facet &use_facet(const std::locale &);
    template <typename _CharT> bool isspace(_CharT, const std::locale &);
    template <typename _CharT> bool isprint(_CharT, const std::locale &);
    template <typename _CharT> bool iscntrl(_CharT, const std::locale &);
    template <typename _CharT> bool isupper(_CharT, const std::locale &);
    template <typename _CharT> bool islower(_CharT, const std::locale &);
    template <typename _CharT> bool isalpha(_CharT, const std::locale &);
    template <typename _CharT> bool isdigit(_CharT, const std::locale &);
    template <typename _CharT> bool ispunct(_CharT, const std::locale &);
    template <typename _CharT> bool isxdigit(_CharT, const std::locale &);
    template <typename _CharT> bool isalnum(_CharT, const std::locale &);
    template <typename _CharT> bool isgraph(_CharT, const std::locale &);
    template <typename _CharT> bool isblank(_CharT, const std::locale &);
    template <typename _CharT> _CharT toupper(_CharT, const std::locale &);
    template <typename _CharT> _CharT tolower(_CharT, const std::locale &);
    class ctype_base;
    template <typename _CharT> class ctype;
    template<> class ctype<char>;
    template<> class ctype<wchar_t>;
    template <typename _CharT> class ctype_byname;
    class codecvt_base;
    template <typename _InternT, typename _ExternT, typename _StateT> class codecvt;
    template<> class codecvt<char, char, mbstate_t>;
    template<> class codecvt<wchar_t, char, mbstate_t>;
    template<> class codecvt<char16_t, char, mbstate_t>;
    template<> class codecvt<char32_t, char, mbstate_t>;
    template <typename _InternT, typename _ExternT, typename _StateT> class codecvt_byname;
    template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class num_get;
    template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class num_put;
    inline namespace __cxx11 {
        template <typename _CharT> class numpunct;
        template <typename _CharT> class numpunct_byname;
    }
    inline namespace __cxx11 {
        template <typename _CharT> class collate;
        template <typename _CharT> class collate_byname;
    }
    class time_base;
    inline namespace __cxx11 {
        template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class time_get;
        template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class time_get_byname;
    }
    template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class time_put;
    template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class time_put_byname;
    class money_base;
    inline namespace __cxx11 {
        template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class money_get;
        template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class money_put;
    }
    inline namespace __cxx11 {
        template <typename _CharT, bool _Intl = false> class moneypunct;
        template <typename _CharT, bool _Intl = false> class moneypunct_byname;
    }
    class messages_base;
    inline namespace __cxx11 {
        template <typename _CharT> class messages;
        template <typename _CharT> class messages_byname;
    }
}
typedef __time_t time_t;
struct timespec {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
};
typedef __pid_t pid_t;
struct sched_param {
    int sched_priority;
};
extern "C" {
    extern int clone(int (*__fn)(void *), void *__child_stack, int __flags, void *__arg, ...) throw();
    extern int unshare(int __flags) throw();
    extern int sched_getcpu() throw();
    extern int getcpu(unsigned int *, unsigned int *) throw();
    extern int setns(int __fd, int __nstype) throw();
}
typedef unsigned long __cpu_mask;
typedef struct {
    __cpu_mask __bits[16];
} cpu_set_t;
extern "C" {
    extern int __sched_cpucount(size_t __setsize, const cpu_set_t *__setp) throw();
    extern cpu_set_t *__sched_cpualloc(size_t __count) throw();
    extern void __sched_cpufree(cpu_set_t *__set) throw();
}
extern "C" {
    extern int sched_setparam(__pid_t __pid, const struct sched_param *__param) throw();
    extern int sched_getparam(__pid_t __pid, struct sched_param *__param) throw();
    extern int sched_setscheduler(__pid_t __pid, int __policy, const struct sched_param *__param) throw();
    extern int sched_getscheduler(__pid_t __pid) throw();
    extern int sched_yield() throw();
    extern int sched_get_priority_max(int __algorithm) throw();
    extern int sched_get_priority_min(int __algorithm) throw();
    extern int sched_rr_get_interval(__pid_t __pid, struct timespec *__t) throw();
    extern int sched_setaffinity(__pid_t __pid, size_t __cpusetsize, const cpu_set_t *__cpuset) throw();
    extern int sched_getaffinity(__pid_t __pid, size_t __cpusetsize, cpu_set_t *__cpuset) throw();
}
struct timeval {
    __time_t tv_sec;
    __suseconds_t tv_usec;
};
struct timex {
    unsigned int modes;
    __syscall_slong_t offset;
    __syscall_slong_t freq;
    __syscall_slong_t maxerror;
    __syscall_slong_t esterror;
    int status;
    __syscall_slong_t constant;
    __syscall_slong_t precision;
    __syscall_slong_t tolerance;
    struct timeval time;
    __syscall_slong_t tick;
    __syscall_slong_t ppsfreq;
    __syscall_slong_t jitter;
    int shift;
    __syscall_slong_t stabil;
    __syscall_slong_t jitcnt;
    __syscall_slong_t calcnt;
    __syscall_slong_t errcnt;
    __syscall_slong_t stbcnt;
    int tai;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
    int : 32;
};
extern "C" {
    extern int clock_adjtime(__clockid_t __clock_id, struct timex *__utx) throw();
}
typedef __clock_t clock_t;
struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long tm_gmtoff;
    const char *tm_zone;
};
typedef __clockid_t clockid_t;
typedef __timer_t timer_t;
struct itimerspec {
    struct timespec it_interval;
    struct timespec it_value;
};
struct sigevent;
extern "C" {
    extern clock_t clock() throw();
    extern time_t time(time_t *__timer) throw();
    extern double difftime(time_t __time1, time_t __time0) throw() __attribute__((const));
    extern time_t mktime(struct tm *__tp) throw();
    extern size_t strftime(char *__restrict __s, size_t __maxsize, const char *__restrict __format, const struct tm *__restrict __tp) throw();
    extern char *strptime(const char *__restrict __s, const char *__restrict __fmt, struct tm *__tp) throw();
    extern size_t strftime_l(char *__restrict __s, size_t __maxsize, const char *__restrict __format, const struct tm *__restrict __tp, locale_t __loc) throw();
    extern char *strptime_l(const char *__restrict __s, const char *__restrict __fmt, struct tm *__tp, locale_t __loc) throw();
    extern struct tm *gmtime(const time_t *__timer) throw();
    extern struct tm *localtime(const time_t *__timer) throw();
    extern struct tm *gmtime_r(const time_t *__restrict __timer, struct tm *__restrict __tp) throw();
    extern struct tm *localtime_r(const time_t *__restrict __timer, struct tm *__restrict __tp) throw();
    extern char *asctime(const struct tm *__tp) throw();
    extern char *ctime(const time_t *__timer) throw();
    extern char *asctime_r(const struct tm *__restrict __tp, char *__restrict __buf) throw();
    extern char *ctime_r(const time_t *__restrict __timer, char *__restrict __buf) throw();
    extern char *__tzname[2];
    extern int __daylight;
    extern long __timezone;
    extern char *tzname[2];
    extern void tzset() throw();
    extern int daylight;
    extern long timezone;
    extern time_t timegm(struct tm *__tp) throw();
    extern time_t timelocal(struct tm *__tp) throw();
    extern int dysize(int __year) throw() __attribute__((const));
    extern int nanosleep(const struct timespec *__requested_time, struct timespec *__remaining);
    extern int clock_getres(clockid_t __clock_id, struct timespec *__res) throw();
    extern int clock_gettime(clockid_t __clock_id, struct timespec *__tp) throw();
    extern int clock_settime(clockid_t __clock_id, const struct timespec *__tp) throw();
    extern int clock_nanosleep(clockid_t __clock_id, int __flags, const struct timespec *__req, struct timespec *__rem);
    extern int clock_getcpuclockid(pid_t __pid, clockid_t *__clock_id) throw();
    extern int timer_create(clockid_t __clock_id, struct sigevent *__restrict __evp, timer_t *__restrict __timerid) throw();
    extern int timer_delete(timer_t __timerid) throw();
    extern int timer_settime(timer_t __timerid, int __flags, const struct itimerspec *__restrict __value, struct itimerspec *__restrict __ovalue) throw();
    extern int timer_gettime(timer_t __timerid, struct itimerspec *__value) throw();
    extern int timer_getoverrun(timer_t __timerid) throw();
    extern int timespec_get(struct timespec *__ts, int __base) throw() __attribute__((nonnull(1)));
    extern int getdate_err;
    extern struct tm *getdate(const char *__string);
    extern int getdate_r(const char *__restrict __string, struct tm *__restrict __resbufp);
}
typedef struct __pthread_internal_list {
    struct __pthread_internal_list *__prev;
    struct __pthread_internal_list *__next;
} __pthread_list_t;
typedef struct __pthread_internal_slist {
    struct __pthread_internal_slist *__next;
} __pthread_slist_t;
struct __pthread_mutex_s {
    int __lock;
    unsigned int __count;
    int __owner;
    unsigned int __nusers;
    int __kind;
    short __spins;
    short __elision;
    __pthread_list_t __list;
};
struct __pthread_rwlock_arch_t {
    unsigned int __readers;
    unsigned int __writers;
    unsigned int __wrphase_futex;
    unsigned int __writers_futex;
    unsigned int __pad3;
    unsigned int __pad4;
    int __cur_writer;
    int __shared;
    signed char __rwelision;
    unsigned char __pad1[7];
    unsigned long __pad2;
    unsigned int __flags;
};
struct __pthread_cond_s {
    union {
        unsigned long long __wseq;
        struct {
            unsigned int __low;
            unsigned int __high;
        } __wseq32;
    };
    union {
        unsigned long long __g1_start;
        struct {
            unsigned int __low;
            unsigned int __high;
        } __g1_start32;
    };
    unsigned int __g_refs[2];
    unsigned int __g_size[2];
    unsigned int __g1_orig_size;
    unsigned int __wrefs;
    unsigned int __g_signals[2];
};
typedef unsigned long pthread_t;
typedef union {
    char __size[4];
    int __align;
} pthread_mutexattr_t;
typedef union {
    char __size[4];
    int __align;
} pthread_condattr_t;
typedef unsigned int pthread_key_t;
typedef int pthread_once_t;
union pthread_attr_t {
    char __size[56];
    long __align;
};
typedef union pthread_attr_t pthread_attr_t;
typedef union {
    struct __pthread_mutex_s __data;
    char __size[40];
    long __align;
} pthread_mutex_t;
typedef union {
    struct __pthread_cond_s __data;
    char __size[48];
    long long __align;
} pthread_cond_t;
typedef union {
    struct __pthread_rwlock_arch_t __data;
    char __size[56];
    long __align;
} pthread_rwlock_t;
typedef union {
    char __size[8];
    long __align;
} pthread_rwlockattr_t;
typedef volatile int pthread_spinlock_t;
typedef union {
    char __size[32];
    long __align;
} pthread_barrier_t;
typedef union {
    char __size[4];
    int __align;
} pthread_barrierattr_t;
typedef long __jmp_buf[8];
enum  {
    PTHREAD_CREATE_JOINABLE,
    PTHREAD_CREATE_DETACHED
};
enum  {
    PTHREAD_MUTEX_TIMED_NP,
    PTHREAD_MUTEX_RECURSIVE_NP,
    PTHREAD_MUTEX_ERRORCHECK_NP,
    PTHREAD_MUTEX_ADAPTIVE_NP,
    PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
    PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
    PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
    PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL,
    PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP
};
enum  {
    PTHREAD_MUTEX_STALLED,
    PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
    PTHREAD_MUTEX_ROBUST,
    PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};
enum  {
    PTHREAD_PRIO_NONE,
    PTHREAD_PRIO_INHERIT,
    PTHREAD_PRIO_PROTECT
};
enum  {
    PTHREAD_RWLOCK_PREFER_READER_NP,
    PTHREAD_RWLOCK_PREFER_WRITER_NP,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
    PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
enum  {
    PTHREAD_INHERIT_SCHED,
    PTHREAD_EXPLICIT_SCHED
};
enum  {
    PTHREAD_SCOPE_SYSTEM,
    PTHREAD_SCOPE_PROCESS
};
enum  {
    PTHREAD_PROCESS_PRIVATE,
    PTHREAD_PROCESS_SHARED
};
struct _pthread_cleanup_buffer {
    void (*__routine)(void *);
    void *__arg;
    int __canceltype;
    struct _pthread_cleanup_buffer *__prev;
};
enum  {
    PTHREAD_CANCEL_ENABLE,
    PTHREAD_CANCEL_DISABLE
};
enum  {
    PTHREAD_CANCEL_DEFERRED,
    PTHREAD_CANCEL_ASYNCHRONOUS
};
extern "C" {
    extern int pthread_create(pthread_t *__restrict __newthread, const pthread_attr_t *__restrict __attr, void *(*__start_routine)(void *), void *__restrict __arg) throw() __attribute__((nonnull(1, 3)));
    extern void pthread_exit(void *__retval);
    extern int pthread_join(pthread_t __th, void **__thread_return);
    extern int pthread_tryjoin_np(pthread_t __th, void **__thread_return) throw();
    extern int pthread_timedjoin_np(pthread_t __th, void **__thread_return, const struct timespec *__abstime);
    extern int pthread_clockjoin_np(pthread_t __th, void **__thread_return, clockid_t __clockid, const struct timespec *__abstime);
    extern int pthread_detach(pthread_t __th) throw();
    extern pthread_t pthread_self() throw() __attribute__((const));
    extern int pthread_equal(pthread_t __thread1, pthread_t __thread2) throw() __attribute__((const));
    extern int pthread_attr_init(pthread_attr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_attr_destroy(pthread_attr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_attr_getdetachstate(const pthread_attr_t *__attr, int *__detachstate) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setdetachstate(pthread_attr_t *__attr, int __detachstate) throw() __attribute__((nonnull(1)));
    extern int pthread_attr_getguardsize(const pthread_attr_t *__attr, size_t *__guardsize) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setguardsize(pthread_attr_t *__attr, size_t __guardsize) throw() __attribute__((nonnull(1)));
    extern int pthread_attr_getschedparam(const pthread_attr_t *__restrict __attr, struct sched_param *__restrict __param) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setschedparam(pthread_attr_t *__restrict __attr, const struct sched_param *__restrict __param) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_attr_getschedpolicy(const pthread_attr_t *__restrict __attr, int *__restrict __policy) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setschedpolicy(pthread_attr_t *__attr, int __policy) throw() __attribute__((nonnull(1)));
    extern int pthread_attr_getinheritsched(const pthread_attr_t *__restrict __attr, int *__restrict __inherit) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setinheritsched(pthread_attr_t *__attr, int __inherit) throw() __attribute__((nonnull(1)));
    extern int pthread_attr_getscope(const pthread_attr_t *__restrict __attr, int *__restrict __scope) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setscope(pthread_attr_t *__attr, int __scope) throw() __attribute__((nonnull(1)));
    extern int pthread_attr_getstackaddr(const pthread_attr_t *__restrict __attr, void **__restrict __stackaddr) throw() __attribute__((nonnull(1, 2))) __attribute__((deprecated("")));
    extern int pthread_attr_setstackaddr(pthread_attr_t *__attr, void *__stackaddr) throw() __attribute__((nonnull(1))) __attribute__((deprecated("")));
    extern int pthread_attr_getstacksize(const pthread_attr_t *__restrict __attr, size_t *__restrict __stacksize) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_attr_setstacksize(pthread_attr_t *__attr, size_t __stacksize) throw() __attribute__((nonnull(1)));
    extern int pthread_attr_getstack(const pthread_attr_t *__restrict __attr, void **__restrict __stackaddr, size_t *__restrict __stacksize) throw() __attribute__((nonnull(1, 2, 3)));
    extern int pthread_attr_setstack(pthread_attr_t *__attr, void *__stackaddr, size_t __stacksize) throw() __attribute__((nonnull(1)));
    extern int pthread_attr_setaffinity_np(pthread_attr_t *__attr, size_t __cpusetsize, const cpu_set_t *__cpuset) throw() __attribute__((nonnull(1, 3)));
    extern int pthread_attr_getaffinity_np(const pthread_attr_t *__attr, size_t __cpusetsize, cpu_set_t *__cpuset) throw() __attribute__((nonnull(1, 3)));
    extern int pthread_getattr_default_np(pthread_attr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_setattr_default_np(const pthread_attr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_getattr_np(pthread_t __th, pthread_attr_t *__attr) throw() __attribute__((nonnull(2)));
    extern int pthread_setschedparam(pthread_t __target_thread, int __policy, const struct sched_param *__param) throw() __attribute__((nonnull(3)));
    extern int pthread_getschedparam(pthread_t __target_thread, int *__restrict __policy, struct sched_param *__restrict __param) throw() __attribute__((nonnull(2, 3)));
    extern int pthread_setschedprio(pthread_t __target_thread, int __prio) throw();
    extern int pthread_getname_np(pthread_t __target_thread, char *__buf, size_t __buflen) throw() __attribute__((nonnull(2)));
    extern int pthread_setname_np(pthread_t __target_thread, const char *__name) throw() __attribute__((nonnull(2)));
    extern int pthread_getconcurrency() throw();
    extern int pthread_setconcurrency(int __level) throw();
    extern int pthread_yield() throw();
    extern int pthread_setaffinity_np(pthread_t __th, size_t __cpusetsize, const cpu_set_t *__cpuset) throw() __attribute__((nonnull(3)));
    extern int pthread_getaffinity_np(pthread_t __th, size_t __cpusetsize, cpu_set_t *__cpuset) throw() __attribute__((nonnull(3)));
    extern int pthread_once(pthread_once_t *__once_control, void (*__init_routine)()) __attribute__((nonnull(1, 2)));
    extern int pthread_setcancelstate(int __state, int *__oldstate);
    extern int pthread_setcanceltype(int __type, int *__oldtype);
    extern int pthread_cancel(pthread_t __th);
    extern void pthread_testcancel();
    typedef struct {
        struct {
            __jmp_buf __cancel_jmp_buf;
            int __mask_was_saved;
        } __cancel_jmp_buf[1];
        void *__pad[4];
    } __pthread_unwind_buf_t __attribute__((aligned));
    struct __pthread_cleanup_frame {
        void (*__cancel_routine)(void *);
        void *__cancel_arg;
        int __do_it;
        int __cancel_type;
    };
    class __pthread_cleanup_class {
        void (*__cancel_routine)(void *);
        void *__cancel_arg;
        int __do_it;
        int __cancel_type;
    public:
        __pthread_cleanup_class(void (*__fct)(void *), void *__arg) : __cancel_routine(__fct), __cancel_arg(__arg), __do_it(1)         {
        }
        ~__pthread_cleanup_class() noexcept         {
            if (this->__do_it)
                this->__cancel_routine(this->__cancel_arg);
        }
        void __setdoit(int __newval)         {
            this->__do_it = __newval;
        }
        void __defer()         {
            pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &this->__cancel_type);
        }
        void __restore() const         {
            pthread_setcanceltype(this->__cancel_type, 0);
        }
    };
    struct __jmp_buf_tag;
    extern int __sigsetjmp(struct __jmp_buf_tag *__env, int __savemask) throw();
    extern int pthread_mutex_init(pthread_mutex_t *__mutex, const pthread_mutexattr_t *__mutexattr) throw() __attribute__((nonnull(1)));
    extern int pthread_mutex_destroy(pthread_mutex_t *__mutex) throw() __attribute__((nonnull(1)));
    extern int pthread_mutex_trylock(pthread_mutex_t *__mutex) throw() __attribute__((nonnull(1)));
    extern int pthread_mutex_lock(pthread_mutex_t *__mutex) throw() __attribute__((nonnull(1)));
    extern int pthread_mutex_timedlock(pthread_mutex_t *__restrict __mutex, const struct timespec *__restrict __abstime) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_mutex_clocklock(pthread_mutex_t *__restrict __mutex, clockid_t __clockid, const struct timespec *__restrict __abstime) throw() __attribute__((nonnull(1, 3)));
    extern int pthread_mutex_unlock(pthread_mutex_t *__mutex) throw() __attribute__((nonnull(1)));
    extern int pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict __mutex, int *__restrict __prioceiling) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_mutex_setprioceiling(pthread_mutex_t *__restrict __mutex, int __prioceiling, int *__restrict __old_ceiling) throw() __attribute__((nonnull(1, 3)));
    extern int pthread_mutex_consistent(pthread_mutex_t *__mutex) throw() __attribute__((nonnull(1)));
    extern int pthread_mutex_consistent_np(pthread_mutex_t *__mutex) throw() __attribute__((nonnull(1)));
    extern int pthread_mutexattr_init(pthread_mutexattr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr, int __pshared) throw() __attribute__((nonnull(1)));
    extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict __attr, int *__restrict __kind) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_settype(pthread_mutexattr_t *__attr, int __kind) throw() __attribute__((nonnull(1)));
    extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict __attr, int *__restrict __protocol) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr, int __protocol) throw() __attribute__((nonnull(1)));
    extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict __attr, int *__restrict __prioceiling) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr, int __prioceiling) throw() __attribute__((nonnull(1)));
    extern int pthread_mutexattr_getrobust(const pthread_mutexattr_t *__attr, int *__robustness) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_getrobust_np(const pthread_mutexattr_t *__attr, int *__robustness) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_mutexattr_setrobust(pthread_mutexattr_t *__attr, int __robustness) throw() __attribute__((nonnull(1)));
    extern int pthread_mutexattr_setrobust_np(pthread_mutexattr_t *__attr, int __robustness) throw() __attribute__((nonnull(1)));
    extern int pthread_rwlock_init(pthread_rwlock_t *__restrict __rwlock, const pthread_rwlockattr_t *__restrict __attr) throw() __attribute__((nonnull(1)));
    extern int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock) throw() __attribute__((nonnull(1)));
    extern int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock) throw() __attribute__((nonnull(1)));
    extern int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock) throw() __attribute__((nonnull(1)));
    extern int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict __rwlock, const struct timespec *__restrict __abstime) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_rwlock_clockrdlock(pthread_rwlock_t *__restrict __rwlock, clockid_t __clockid, const struct timespec *__restrict __abstime) throw() __attribute__((nonnull(1, 3)));
    extern int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock) throw() __attribute__((nonnull(1)));
    extern int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock) throw() __attribute__((nonnull(1)));
    extern int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict __rwlock, const struct timespec *__restrict __abstime) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_rwlock_clockwrlock(pthread_rwlock_t *__restrict __rwlock, clockid_t __clockid, const struct timespec *__restrict __abstime) throw() __attribute__((nonnull(1, 3)));
    extern int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock) throw() __attribute__((nonnull(1)));
    extern int pthread_rwlockattr_init(pthread_rwlockattr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr, int __pshared) throw() __attribute__((nonnull(1)));
    extern int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t *__restrict __attr, int *__restrict __pref) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr, int __pref) throw() __attribute__((nonnull(1)));
    extern int pthread_cond_init(pthread_cond_t *__restrict __cond, const pthread_condattr_t *__restrict __cond_attr) throw() __attribute__((nonnull(1)));
    extern int pthread_cond_destroy(pthread_cond_t *__cond) throw() __attribute__((nonnull(1)));
    extern int pthread_cond_signal(pthread_cond_t *__cond) throw() __attribute__((nonnull(1)));
    extern int pthread_cond_broadcast(pthread_cond_t *__cond) throw() __attribute__((nonnull(1)));
    extern int pthread_cond_wait(pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex) __attribute__((nonnull(1, 2)));
    extern int pthread_cond_timedwait(pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex, const struct timespec *__restrict __abstime) __attribute__((nonnull(1, 2, 3)));
    extern int pthread_cond_clockwait(pthread_cond_t *__restrict __cond, pthread_mutex_t *__restrict __mutex, __clockid_t __clock_id, const struct timespec *__restrict __abstime) __attribute__((nonnull(1, 2, 4)));
    extern int pthread_condattr_init(pthread_condattr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_condattr_destroy(pthread_condattr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_condattr_getpshared(const pthread_condattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_condattr_setpshared(pthread_condattr_t *__attr, int __pshared) throw() __attribute__((nonnull(1)));
    extern int pthread_condattr_getclock(const pthread_condattr_t *__restrict __attr, __clockid_t *__restrict __clock_id) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_condattr_setclock(pthread_condattr_t *__attr, __clockid_t __clock_id) throw() __attribute__((nonnull(1)));
    extern int pthread_spin_init(pthread_spinlock_t *__lock, int __pshared) throw() __attribute__((nonnull(1)));
    extern int pthread_spin_destroy(pthread_spinlock_t *__lock) throw() __attribute__((nonnull(1)));
    extern int pthread_spin_lock(pthread_spinlock_t *__lock) throw() __attribute__((nonnull(1)));
    extern int pthread_spin_trylock(pthread_spinlock_t *__lock) throw() __attribute__((nonnull(1)));
    extern int pthread_spin_unlock(pthread_spinlock_t *__lock) throw() __attribute__((nonnull(1)));
    extern int pthread_barrier_init(pthread_barrier_t *__restrict __barrier, const pthread_barrierattr_t *__restrict __attr, unsigned int __count) throw() __attribute__((nonnull(1)));
    extern int pthread_barrier_destroy(pthread_barrier_t *__barrier) throw() __attribute__((nonnull(1)));
    extern int pthread_barrier_wait(pthread_barrier_t *__barrier) throw() __attribute__((nonnull(1)));
    extern int pthread_barrierattr_init(pthread_barrierattr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_barrierattr_destroy(pthread_barrierattr_t *__attr) throw() __attribute__((nonnull(1)));
    extern int pthread_barrierattr_getpshared(const pthread_barrierattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((nonnull(1, 2)));
    extern int pthread_barrierattr_setpshared(pthread_barrierattr_t *__attr, int __pshared) throw() __attribute__((nonnull(1)));
    extern int pthread_key_create(pthread_key_t *__key, void (*__destr_function)(void *)) throw() __attribute__((nonnull(1)));
    extern int pthread_key_delete(pthread_key_t __key) throw();
    extern void *pthread_getspecific(pthread_key_t __key) throw();
    extern int pthread_setspecific(pthread_key_t __key, const void *__pointer) throw();
    extern int pthread_getcpuclockid(pthread_t __thread_id, __clockid_t *__clock_id) throw() __attribute__((nonnull(2)));
    extern int pthread_atfork(void (*__prepare)(), void (*__parent)(), void (*__child)()) throw();
}
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
static int __gthrw_pthread_once(pthread_once_t *, void (*)()) __attribute__((alias("pthread_once"))) __attribute__((weakref("")))
static void *__gthrw_pthread_getspecific(pthread_key_t) throw() __attribute__((alias("pthread_getspecific"))) __attribute__((weakref("")))
static int __gthrw_pthread_setspecific(pthread_key_t, const void *) throw() __attribute__((alias("pthread_setspecific"))) __attribute__((weakref("")))
static int __gthrw_pthread_create(pthread_t *__restrict, const pthread_attr_t *__restrict, void *(*)(void *), void *__restrict) throw() __attribute__((alias("pthread_create"))) __attribute__((weakref("")))
static int __gthrw_pthread_join(pthread_t, void **) __attribute__((alias("pthread_join"))) __attribute__((weakref("")))
static int __gthrw_pthread_equal(pthread_t, pthread_t) throw() __attribute__((alias("pthread_equal"))) __attribute__((weakref("")))
static pthread_t __gthrw_pthread_self() throw() __attribute__((alias("pthread_self"))) __attribute__((weakref("")))
static int __gthrw_pthread_detach(pthread_t) throw() __attribute__((alias("pthread_detach"))) __attribute__((weakref("")))
static int __gthrw_pthread_cancel(pthread_t) __attribute__((alias("pthread_cancel"))) __attribute__((weakref("")))
static int __gthrw_sched_yield() throw() __attribute__((alias("sched_yield"))) __attribute__((weakref("")))
static int __gthrw_pthread_mutex_lock(pthread_mutex_t *) throw() __attribute__((alias("pthread_mutex_lock"))) __attribute__((weakref("")))
static int __gthrw_pthread_mutex_trylock(pthread_mutex_t *) throw() __attribute__((alias("pthread_mutex_trylock"))) __attribute__((weakref("")))
static int __gthrw_pthread_mutex_timedlock(pthread_mutex_t *__restrict, const struct timespec *__restrict) throw() __attribute__((alias("pthread_mutex_timedlock"))) __attribute__((weakref("")))
static int __gthrw_pthread_mutex_unlock(pthread_mutex_t *) throw() __attribute__((alias("pthread_mutex_unlock"))) __attribute__((weakref("")))
static int __gthrw_pthread_mutex_init(pthread_mutex_t *, const pthread_mutexattr_t *) throw() __attribute__((alias("pthread_mutex_init"))) __attribute__((weakref("")))
static int __gthrw_pthread_mutex_destroy(pthread_mutex_t *) throw() __attribute__((alias("pthread_mutex_destroy"))) __attribute__((weakref("")))
static int __gthrw_pthread_cond_init(pthread_cond_t *__restrict, const pthread_condattr_t *__restrict) throw() __attribute__((alias("pthread_cond_init"))) __attribute__((weakref("")))
static int __gthrw_pthread_cond_broadcast(pthread_cond_t *) throw() __attribute__((alias("pthread_cond_broadcast"))) __attribute__((weakref("")))
static int __gthrw_pthread_cond_signal(pthread_cond_t *) throw() __attribute__((alias("pthread_cond_signal"))) __attribute__((weakref("")))
static int __gthrw_pthread_cond_wait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict) __attribute__((alias("pthread_cond_wait"))) __attribute__((weakref("")))
static int __gthrw_pthread_cond_timedwait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict, const struct timespec *__restrict) __attribute__((alias("pthread_cond_timedwait"))) __attribute__((weakref("")))
static int __gthrw_pthread_cond_destroy(pthread_cond_t *) throw() __attribute__((alias("pthread_cond_destroy"))) __attribute__((weakref("")))
static int __gthrw_pthread_key_create(pthread_key_t *, void (*)(void *)) throw() __attribute__((alias("pthread_key_create"))) __attribute__((weakref("")))
static int __gthrw_pthread_key_delete(pthread_key_t) throw() __attribute__((alias("pthread_key_delete"))) __attribute__((weakref("")))
static int __gthrw_pthread_mutexattr_init(pthread_mutexattr_t *) throw() __attribute__((alias("pthread_mutexattr_init"))) __attribute__((weakref("")))
static int __gthrw_pthread_mutexattr_settype(pthread_mutexattr_t *, int) throw() __attribute__((alias("pthread_mutexattr_settype"))) __attribute__((weakref("")))
static int __gthrw_pthread_mutexattr_destroy(pthread_mutexattr_t *) throw() __attribute__((alias("pthread_mutexattr_destroy"))) __attribute__((weakref("")))
static int __gthrw___pthread_key_create(pthread_key_t *, void (*)(void *)) throw() __attribute__((alias("__pthread_key_create"))) __attribute__((weakref("")))
static inline int __gthread_active_p() {
    static void *const __gthread_active_ptr = __extension__ (void *)&__gthrw___pthread_key_create;
    return __gthread_active_ptr != 0;
}
static inline int __gthread_create(__gthread_t *__threadid, void *(*__func)(void *), void *__args) {
    return __gthrw_pthread_create(__threadid, __null, __func, __args);
}
static inline int __gthread_join(__gthread_t __threadid, void **__value_ptr) {
    return __gthrw_pthread_join(__threadid, __value_ptr);
}
static inline int __gthread_detach(__gthread_t __threadid) {
    return __gthrw_pthread_detach(__threadid);
}
static inline int __gthread_equal(__gthread_t __t1, __gthread_t __t2) {
    return __gthrw_pthread_equal(__t1, __t2);
}
static inline __gthread_t __gthread_self() {
    return __gthrw_pthread_self();
}
static inline int __gthread_yield() {
    return __gthrw_sched_yield();
}
static inline int __gthread_once(__gthread_once_t *__once, void (*__func)()) {
    if (__gthread_active_p())
        return __gthrw_pthread_once(__once, __func);
    else
        return -1;
}
static inline int __gthread_key_create(__gthread_key_t *__key, void (*__dtor)(void *)) {
    return __gthrw_pthread_key_create(__key, __dtor);
}
static inline int __gthread_key_delete(__gthread_key_t __key) {
    return __gthrw_pthread_key_delete(__key);
}
static inline void *__gthread_getspecific(__gthread_key_t __key) {
    return __gthrw_pthread_getspecific(__key);
}
static inline int __gthread_setspecific(__gthread_key_t __key, const void *__ptr) {
    return __gthrw_pthread_setspecific(__key, __ptr);
}
static inline void __gthread_mutex_init_function(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        __gthrw_pthread_mutex_init(__mutex, __null);
}
static inline int __gthread_mutex_destroy(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return __gthrw_pthread_mutex_destroy(__mutex);
    else
        return 0;
}
static inline int __gthread_mutex_lock(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return __gthrw_pthread_mutex_lock(__mutex);
    else
        return 0;
}
static inline int __gthread_mutex_trylock(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return __gthrw_pthread_mutex_trylock(__mutex);
    else
        return 0;
}
static inline int __gthread_mutex_timedlock(__gthread_mutex_t *__mutex, const __gthread_time_t *__abs_timeout) {
    if (__gthread_active_p())
        return __gthrw_pthread_mutex_timedlock(__mutex, __abs_timeout);
    else
        return 0;
}
static inline int __gthread_mutex_unlock(__gthread_mutex_t *__mutex) {
    if (__gthread_active_p())
        return __gthrw_pthread_mutex_unlock(__mutex);
    else
        return 0;
}
static inline int __gthread_recursive_mutex_lock(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_lock(__mutex);
}
static inline int __gthread_recursive_mutex_trylock(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_trylock(__mutex);
}
static inline int __gthread_recursive_mutex_timedlock(__gthread_recursive_mutex_t *__mutex, const __gthread_time_t *__abs_timeout) {
    return __gthread_mutex_timedlock(__mutex, __abs_timeout);
}
static inline int __gthread_recursive_mutex_unlock(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_unlock(__mutex);
}
static inline int __gthread_recursive_mutex_destroy(__gthread_recursive_mutex_t *__mutex) {
    return __gthread_mutex_destroy(__mutex);
}
static inline int __gthread_cond_broadcast(__gthread_cond_t *__cond) {
    return __gthrw_pthread_cond_broadcast(__cond);
}
static inline int __gthread_cond_signal(__gthread_cond_t *__cond) {
    return __gthrw_pthread_cond_signal(__cond);
}
static inline int __gthread_cond_wait(__gthread_cond_t *__cond, __gthread_mutex_t *__mutex) {
    return __gthrw_pthread_cond_wait(__cond, __mutex);
}
static inline int __gthread_cond_timedwait(__gthread_cond_t *__cond, __gthread_mutex_t *__mutex, const __gthread_time_t *__abs_timeout) {
    return __gthrw_pthread_cond_timedwait(__cond, __mutex, __abs_timeout);
}
static inline int __gthread_cond_wait_recursive(__gthread_cond_t *__cond, __gthread_recursive_mutex_t *__mutex) {
    return __gthread_cond_wait(__cond, __mutex);
}
static inline int __gthread_cond_destroy(__gthread_cond_t *__cond) {
    return __gthrw_pthread_cond_destroy(__cond);
}
typedef int _Atomic_word;
namespace __gnu_cxx {
    static inline _Atomic_word __exchange_and_add(volatile _Atomic_word *__mem, int __val)     {
        return __atomic_fetch_add(__mem, __val, 4);
    }
    static inline void __atomic_add(volatile _Atomic_word *__mem, int __val)     {
        __atomic_fetch_add(__mem, __val, 4);
    }
    static inline _Atomic_word __exchange_and_add_single(_Atomic_word *__mem, int __val)     {
        _Atomic_word __result = *__mem;
        *__mem += __val;
        return __result;
    }
    static inline void __atomic_add_single(_Atomic_word *__mem, int __val)     {
        *__mem += __val;
    }
    static inline _Atomic_word __exchange_and_add_dispatch(_Atomic_word *__mem, int __val) __attribute__((unused))     {
        if (__gthread_active_p())
            return __exchange_and_add(__mem, __val);
        else
            return __exchange_and_add_single(__mem, __val);
    }
    static inline void __atomic_add_dispatch(_Atomic_word *__mem, int __val) __attribute__((unused))     {
        if (__gthread_active_p())
            __atomic_add(__mem, __val);
        else
            __atomic_add_single(__mem, __val);
    }
}
namespace __gnu_cxx {
    using std::size_t;
    using std::ptrdiff_t;
    template <typename _Tp> class new_allocator {
    public:
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef _Tp *pointer;
        typedef const _Tp *const_pointer;
        typedef _Tp &reference;
        typedef const _Tp &const_reference;
        typedef _Tp value_type;
        template <typename _Tp1> struct rebind {
            typedef new_allocator<_Tp1> other;
        };
        typedef std::true_type propagate_on_container_move_assignment;
        new_allocator<_Tp>() noexcept         {
        }
        new_allocator<_Tp>(const new_allocator<_Tp> &) noexcept         {
        }
        template <typename _Tp1> new_allocator<_Tp>(const new_allocator<_Tp1> &) noexcept         {
        }
        ~new_allocator<_Tp>() noexcept         {
        }
        __gnu_cxx::new_allocator::pointer address(__gnu_cxx::new_allocator::reference __x) const noexcept         {
            return std::__addressof(__x);
        }
        __gnu_cxx::new_allocator::const_pointer address(__gnu_cxx::new_allocator::const_reference __x) const noexcept         {
            return std::__addressof(__x);
        }
        __gnu_cxx::new_allocator::pointer allocate(__gnu_cxx::new_allocator::size_type __n, const void * = static_cast<const void *>(0))         {
            if (__n > this->max_size())
                std::__throw_bad_alloc();
            return static_cast<_Tp *>(::operator new(__n * sizeof(_Tp)));
        }
        void deallocate(__gnu_cxx::new_allocator::pointer __p, __gnu_cxx::new_allocator::size_type)         {
            ::operator delete(__p);
        }
        __gnu_cxx::new_allocator::size_type max_size() const noexcept         {
            return std::size_t(9223372036854775807L) / sizeof(_Tp);
        }
        template <typename _Up, typename ..._Args> void construct(_Up *__p, _Args &&...__args) noexcept(noexcept(::new ((void *)__p) _Up((std::forward<_Args>(__args)...)))construct(_Up *__p, _Args &&...__args) noexcept(noexcept(::new ((void *)__p) _Up((std::forward<_Args>(__args)...))))         {
            ::new ((void *)__p) _Up((std::forward<_Args>(__args)...));
        }
        template <typename _Up> void destroy(_Up *__p) noexcept(noexcept(__p->~_Up())destroy(_Up *__p) noexcept(noexcept(__p->~_Up()))         {
            __p->~_Up();
        }
        friend template <typename _Up> bool operator==(const new_allocator<_Tp> &, const new_allocator<_Up> &) noexcept         {
            return true;
        }
;
        friend template <typename _Up> bool operator!=(const new_allocator<_Tp> &, const new_allocator<_Up> &) noexcept         {
            return false;
        }
;
    };
template<> class new_allocator<char> {
    public:
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char *pointer;
        typedef const char *const_pointer;
        typedef char &reference;
        typedef const char &const_reference;
        typedef char value_type;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        new_allocator() noexcept         {
        }
        new_allocator(const __gnu_cxx::new_allocator<char> &) noexcept         {
        }
        template <typename _Tp1> new_allocator(const new_allocator<_Tp1> &) noexcept;
        template<> new_allocator<char>(const new_allocator<char> &) noexcept;
        ~new_allocator<char>() noexcept         {
        }
        __gnu_cxx::new_allocator<char>::pointer address(__gnu_cxx::new_allocator<char>::reference __x) const noexcept;
        __gnu_cxx::new_allocator<char>::const_pointer address(__gnu_cxx::new_allocator<char>::const_reference __x) const noexcept;
        __gnu_cxx::new_allocator<char>::pointer allocate(__gnu_cxx::new_allocator::size_type __n, const void *);
        void deallocate(__gnu_cxx::new_allocator<char>::pointer __p, __gnu_cxx::new_allocator::size_type)         {
            ::operator delete(__p);
        }
        __gnu_cxx::new_allocator::size_type max_size() const noexcept         {
            return std::size_t(9223372036854775807L) / sizeof(char);
        }
        template <typename _Up, typename ..._Args> void construct(_Up *__p, _Args &&...__args);
        template <typename _Up> void destroy(_Up *__p);
        friend template <typename _Up> bool operator==(const __gnu_cxx::new_allocator<char> &, const new_allocator<_Up> &) noexcept;
        friend template <typename _Up> bool operator!=(const __gnu_cxx::new_allocator<char> &, const new_allocator<_Up> &) noexcept;
    };
template<> class new_allocator<wchar_t> {
    public:
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef wchar_t *pointer;
        typedef const wchar_t *const_pointer;
        typedef wchar_t &reference;
        typedef const wchar_t &const_reference;
        typedef wchar_t value_type;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        new_allocator() noexcept         {
        }
        new_allocator(const __gnu_cxx::new_allocator<wchar_t> &) noexcept         {
        }
        template <typename _Tp1> new_allocator(const new_allocator<_Tp1> &) noexcept;
        template<> new_allocator<wchar_t>(const new_allocator<wchar_t> &) noexcept;
        ~new_allocator<wchar_t>() noexcept         {
        }
        __gnu_cxx::new_allocator<wchar_t>::pointer address(__gnu_cxx::new_allocator<wchar_t>::reference __x) const noexcept;
        __gnu_cxx::new_allocator<wchar_t>::const_pointer address(__gnu_cxx::new_allocator<wchar_t>::const_reference __x) const noexcept;
        __gnu_cxx::new_allocator<wchar_t>::pointer allocate(__gnu_cxx::new_allocator::size_type __n, const void *);
        void deallocate(__gnu_cxx::new_allocator<wchar_t>::pointer __p, __gnu_cxx::new_allocator::size_type)         {
            ::operator delete(__p);
        }
        __gnu_cxx::new_allocator::size_type max_size() const noexcept;
        template <typename _Up, typename ..._Args> void construct(_Up *__p, _Args &&...__args);
        template <typename _Up> void destroy(_Up *__p);
        friend template <typename _Up> bool operator==(const __gnu_cxx::new_allocator<wchar_t> &, const new_allocator<_Up> &) noexcept;
        friend template <typename _Up> bool operator!=(const __gnu_cxx::new_allocator<wchar_t> &, const new_allocator<_Up> &) noexcept;
    };
template<> class new_allocator<char16_t> {
    public:
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char16_t *pointer;
        typedef const char16_t *const_pointer;
        typedef char16_t &reference;
        typedef const char16_t &const_reference;
        typedef char16_t value_type;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        new_allocator() noexcept         {
        }
        new_allocator(const __gnu_cxx::new_allocator<char16_t> &) noexcept         {
        }
        template <typename _Tp1> new_allocator(const new_allocator<_Tp1> &) noexcept;
        template<> new_allocator<char16_t>(const new_allocator<char16_t> &) noexcept;
        ~new_allocator<char16_t>() noexcept         {
        }
        __gnu_cxx::new_allocator<char16_t>::pointer address(__gnu_cxx::new_allocator<char16_t>::reference __x) const noexcept;
        __gnu_cxx::new_allocator<char16_t>::const_pointer address(__gnu_cxx::new_allocator<char16_t>::const_reference __x) const noexcept;
        __gnu_cxx::new_allocator<char16_t>::pointer allocate(__gnu_cxx::new_allocator::size_type __n, const void * = static_cast<const void *>(0))         {
            if (__n > this->max_size())
                std::__throw_bad_alloc();
            return static_cast<char16_t *>(::operator new(__n * sizeof(char16_t)));
        }
        void deallocate(__gnu_cxx::new_allocator<char16_t>::pointer __p, __gnu_cxx::new_allocator::size_type)         {
            ::operator delete(__p);
        }
        __gnu_cxx::new_allocator::size_type max_size() const noexcept         {
            return std::size_t(9223372036854775807L) / sizeof(char16_t);
        }
        template <typename _Up, typename ..._Args> void construct(_Up *__p, _Args &&...__args);
        template <typename _Up> void destroy(_Up *__p);
        friend template <typename _Up> bool operator==(const __gnu_cxx::new_allocator<char16_t> &, const new_allocator<_Up> &) noexcept;
        friend template <typename _Up> bool operator!=(const __gnu_cxx::new_allocator<char16_t> &, const new_allocator<_Up> &) noexcept;
    };
template<> class new_allocator<char32_t> {
    public:
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char32_t *pointer;
        typedef const char32_t *const_pointer;
        typedef char32_t &reference;
        typedef const char32_t &const_reference;
        typedef char32_t value_type;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        new_allocator() noexcept         {
        }
        new_allocator(const __gnu_cxx::new_allocator<char32_t> &) noexcept         {
        }
        template <typename _Tp1> new_allocator(const new_allocator<_Tp1> &) noexcept;
        template<> new_allocator<char32_t>(const new_allocator<char32_t> &) noexcept;
        ~new_allocator<char32_t>() noexcept         {
        }
        __gnu_cxx::new_allocator<char32_t>::pointer address(__gnu_cxx::new_allocator<char32_t>::reference __x) const noexcept;
        __gnu_cxx::new_allocator<char32_t>::const_pointer address(__gnu_cxx::new_allocator<char32_t>::const_reference __x) const noexcept;
        __gnu_cxx::new_allocator<char32_t>::pointer allocate(__gnu_cxx::new_allocator::size_type __n, const void * = static_cast<const void *>(0))         {
            if (__n > this->max_size())
                std::__throw_bad_alloc();
            return static_cast<char32_t *>(::operator new(__n * sizeof(char32_t)));
        }
        void deallocate(__gnu_cxx::new_allocator<char32_t>::pointer __p, __gnu_cxx::new_allocator::size_type)         {
            ::operator delete(__p);
        }
        __gnu_cxx::new_allocator::size_type max_size() const noexcept         {
            return std::size_t(9223372036854775807L) / sizeof(char32_t);
        }
        template <typename _Up, typename ..._Args> void construct(_Up *__p, _Args &&...__args);
        template <typename _Up> void destroy(_Up *__p);
        friend template <typename _Up> bool operator==(const __gnu_cxx::new_allocator<char32_t> &, const new_allocator<_Up> &) noexcept;
        friend template <typename _Up> bool operator!=(const __gnu_cxx::new_allocator<char32_t> &, const new_allocator<_Up> &) noexcept;
    };
}
namespace std {
    template <typename _Tp> using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
namespace std {
    template<> class allocator<void> {
    public:
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef void *pointer;
        typedef const void *const_pointer;
        typedef void value_type;
        template <typename _Tp1> struct rebind {
            typedef allocator<_Tp1> other;
        };
        typedef std::true_type propagate_on_container_move_assignment;
        typedef std::true_type is_always_equal;
        template <typename _Up, typename ..._Args> void construct(_Up *__p, _Args &&...__args) noexcept(noexcept(::new ((void *)__p) _Up((std::forward<_Args>(__args)...)))construct(_Up *__p, _Args &&...__args) noexcept(noexcept(::new ((void *)__p) _Up((std::forward<_Args>(__args)...))))         {
            ::new ((void *)__p) _Up((std::forward<_Args>(__args)...));
        }
        template <typename _Up> void destroy(_Up *__p) noexcept(noexcept(__p->~_Up())destroy(_Up *__p) noexcept(noexcept(__p->~_Up()))         {
            __p->~_Up();
        }
    };
    template <typename _Tp> class allocator : public __allocator_base<_Tp> {
    public:
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef _Tp *pointer;
        typedef const _Tp *const_pointer;
        typedef _Tp &reference;
        typedef const _Tp &const_reference;
        typedef _Tp value_type;
        template <typename _Tp1> struct rebind {
            typedef allocator<_Tp1> other;
        };
        typedef std::true_type propagate_on_container_move_assignment;
        typedef std::true_type is_always_equal;
        allocator<type-parameter-0-0>() noexcept         {
        }
        allocator<type-parameter-0-0>(const allocator<type-parameter-0-0> &__a) noexcept : __allocator_base<_Tp>(__a)         {
        }
        allocator<type-parameter-0-0> &operator=(const allocator<type-parameter-0-0> &) = default
        template <typename _Tp1> allocator<type-parameter-0-0>(const allocator<_Tp1> &) noexcept         {
        }
        ~allocator<type-parameter-0-0>() noexcept         {
        }
        friend bool operator==(const allocator<type-parameter-0-0> &, const allocator<type-parameter-0-0> &) noexcept         {
            return true;
        }
;
        friend bool operator!=(const allocator<type-parameter-0-0> &, const allocator<type-parameter-0-0> &) noexcept         {
            return false;
        }
;
    };
template<> class allocator<char16_t> : public __allocator_base<char16_t> {
    public:
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char16_t *pointer;
        typedef const char16_t *const_pointer;
        typedef char16_t &reference;
        typedef const char16_t &const_reference;
        typedef char16_t value_type;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        typedef std::true_type is_always_equal;
        allocator() noexcept : __allocator_base<char16_t>()         {
        }
        allocator(const std::allocator<char16_t> &__a) noexcept : __allocator_base<char16_t>(__a)         {
        }
        std::allocator<char16_t> &operator=(const std::allocator<char16_t> &) = default
        template <typename _Tp1> allocator(const allocator<_Tp1> &) noexcept;
        template<> allocator<char16_t>(const allocator<char16_t> &) noexcept;
        ~allocator<char16_t>() noexcept         {
        }
        friend bool operator==(const std::allocator<char16_t> &, const std::allocator<char16_t> &) noexcept;
        friend bool operator!=(const std::allocator<char16_t> &, const std::allocator<char16_t> &) noexcept;
    };
template<> class allocator<char32_t> : public __allocator_base<char32_t> {
    public:
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char32_t *pointer;
        typedef const char32_t *const_pointer;
        typedef char32_t &reference;
        typedef const char32_t &const_reference;
        typedef char32_t value_type;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        typedef std::true_type is_always_equal;
        allocator() noexcept : __allocator_base<char32_t>()         {
        }
        allocator(const std::allocator<char32_t> &__a) noexcept : __allocator_base<char32_t>(__a)         {
        }
        std::allocator<char32_t> &operator=(const std::allocator<char32_t> &) = default
        template <typename _Tp1> allocator(const allocator<_Tp1> &) noexcept;
        template<> allocator<char32_t>(const allocator<char32_t> &) noexcept;
        ~allocator<char32_t>() noexcept         {
        }
        friend bool operator==(const std::allocator<char32_t> &, const std::allocator<char32_t> &) noexcept;
        friend bool operator!=(const std::allocator<char32_t> &, const std::allocator<char32_t> &) noexcept;
    };
    template <typename _T1, typename _T2> inline bool operator==(const allocator<_T1> &, const allocator<_T2> &) noexcept     {
        return true;
    }
    template <typename _T1, typename _T2> inline bool operator!=(const allocator<_T1> &, const allocator<_T2> &) noexcept     {
        return false;
    }
    template <typename _Tp> class allocator<const _Tp> {
    public:
        typedef _Tp value_type;
        template <typename _Up> allocator<const type-parameter-0-0>(const allocator<_Up> &)         {
        }
    };
    template <typename _Tp> class allocator<volatile _Tp> {
    public:
        typedef _Tp value_type;
        template <typename _Up> allocator<volatile type-parameter-0-0>(const allocator<_Up> &)         {
        }
    };
    template <typename _Tp> class allocator<const volatile _Tp> {
    public:
        typedef _Tp value_type;
        template <typename _Up> allocator<const volatile type-parameter-0-0>(const allocator<_Up> &)         {
        }
    };
    template<> class allocator<char> : public __allocator_base<char> {
    public:
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef char *pointer;
        typedef const char *const_pointer;
        typedef char &reference;
        typedef const char &const_reference;
        typedef char value_type;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        typedef std::true_type is_always_equal;
        allocator() noexcept : __allocator_base<char>()         {
        }
        allocator(const std::allocator<char> &__a) noexcept : __allocator_base<char>(__a)         {
        }
        std::allocator<char> &operator=(const std::allocator<char> &) = default
        template <typename _Tp1> allocator(const allocator<_Tp1> &) noexcept;
        template<> allocator<char>(const allocator<char> &) noexcept;
        ~allocator<char>() noexcept         {
        }
        friend bool operator==(const std::allocator<char> &, const std::allocator<char> &) noexcept;
        friend bool operator!=(const std::allocator<char> &, const std::allocator<char> &) noexcept;
    };
    template<> class allocator<wchar_t> : public __allocator_base<wchar_t> {
    public:
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef wchar_t *pointer;
        typedef const wchar_t *const_pointer;
        typedef wchar_t &reference;
        typedef const wchar_t &const_reference;
        typedef wchar_t value_type;
        template <typename _Tp1> struct rebind;
        typedef std::true_type propagate_on_container_move_assignment;
        typedef std::true_type is_always_equal;
        allocator() noexcept : __allocator_base<wchar_t>()         {
        }
        allocator(const std::allocator<wchar_t> &__a) noexcept : __allocator_base<wchar_t>(__a)         {
        }
        std::allocator<wchar_t> &operator=(const std::allocator<wchar_t> &) = default
        template <typename _Tp1> allocator(const allocator<_Tp1> &) noexcept;
        template<> allocator<wchar_t>(const allocator<wchar_t> &) noexcept;
        ~allocator<wchar_t>() noexcept         {
        }
        friend bool operator==(const std::allocator<wchar_t> &, const std::allocator<wchar_t> &) noexcept;
        friend bool operator!=(const std::allocator<wchar_t> &, const std::allocator<wchar_t> &) noexcept;
    };
    template <typename _Alloc, bool = __is_empty(_Alloc)> struct __alloc_swap {
        static void _S_do_it(_Alloc &, _Alloc &) noexcept         {
        }
    };
    template <typename _Alloc> struct __alloc_swap<_Alloc, false> {
        static void _S_do_it(_Alloc &__one, _Alloc &__two) noexcept         {
            if (__one != __two)
                swap(__one, __two);
        }
    };
    template <typename _Alloc, bool = __is_empty(_Alloc)> struct __alloc_neq {
        static bool _S_do_it(const _Alloc &, const _Alloc &)         {
            return false;
        }
    };
    template <typename _Alloc> struct __alloc_neq<_Alloc, false> {
        static bool _S_do_it(const _Alloc &__one, const _Alloc &__two)         {
            return __one != __two;
        }
    };
    template <typename _Tp, bool = __or_<is_copy_constructible<typename _Tp::value_type>, is_nothrow_move_constructible<typename _Tp::value_type> >::value> struct __shrink_to_fit_aux {
        static bool _S_do_it(_Tp &) noexcept         {
            return false;
        }
    };
    template <typename _Tp> struct __shrink_to_fit_aux<_Tp, true> {
        static bool _S_do_it(_Tp &__c) noexcept         {
            try {
                _Tp(__make_move_if_noexcept_iterator(__c.begin()), __make_move_if_noexcept_iterator(__c.end()), __c.get_allocator()).swap(__c);
                return true;
            } catch (...) {
                return false;
            }
        }
    };
}
namespace __cxxabiv1 {
    class __forced_unwind {
        virtual ~__forced_unwind() throw();
        virtual void __pure_dummy() = 0;
    };
}
namespace std {
    template <typename _CharT, typename _Traits> inline void __ostream_write(basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, std::streamsize __n)     {
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        const std::streamsize __put = __out.rdbuf()->sputn(__s, __n);
        if (__put != __n)
            __out.setstate(__ios_base::badbit);
    }
    template <typename _CharT, typename _Traits> inline void __ostream_fill(basic_ostream<_CharT, _Traits> &__out, std::streamsize __n)     {
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        const _CharT __c = __out.fill();
        for (; __n > 0; --__n) {
            const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
            if (_Traits::eq_int_type(__put, _Traits::eof())) {
                __out.setstate(__ios_base::badbit);
                break;
            }
        }
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &__ostream_insert(basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, std::streamsize __n)     {
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef typename __ostream_type::ios_base __ios_base;
        typename __ostream_type::sentry __cerb(__out);
        if (__cerb) {
            try {
                const std::streamsize __w = __out.width();
                if (__w > __n) {
                    const bool __left = ((__out.flags() & __ios_base::adjustfield) == __ios_base::left);
                    if (!__left)
                        __ostream_fill(__out, __w - __n);
                    if (__out.good())
                        __ostream_write(__out, __s, __n);
                    if (__left && __out.good())
                        __ostream_fill(__out, __w - __n);
                } else
                    __ostream_write(__out, __s, __n);
                __out.width(0);
            } catch (__cxxabiv1::__forced_unwind &) {
                __out._M_setstate(__ios_base::badbit);
                throw;
            } catch (...) {
                __out._M_setstate(__ios_base::badbit);
            }
        }
        return __out;
    }
}
namespace std {
    template <typename _Arg, typename _Result> struct unary_function {
        typedef _Arg argument_type;
        typedef _Result result_type;
    };
    template <typename _Arg1, typename _Arg2, typename _Result> struct binary_function {
        typedef _Arg1 first_argument_type;
        typedef _Arg2 second_argument_type;
        typedef _Result result_type;
    };
template<> struct binary_function<const volatile void *, const volatile void *, bool> {
        typedef const volatile void *first_argument_type;
        typedef const volatile void *second_argument_type;
        typedef bool result_type;
    };
template<> struct binary_function<const std::_V2::error_category *, const std::_V2::error_category *, bool> {
        typedef const std::_V2::error_category *first_argument_type;
        typedef const std::_V2::error_category *second_argument_type;
        typedef bool result_type;
    };
    struct __is_transparent;
    template <typename _Tp = void> struct plus;
    template <typename _Tp = void> struct minus;
    template <typename _Tp = void> struct multiplies;
    template <typename _Tp = void> struct divides;
    template <typename _Tp = void> struct modulus;
    template <typename _Tp = void> struct negate;
    template <typename _Tp = void> struct plus : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x + __y;
        }
    };
    template <typename _Tp = void> struct minus : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x - __y;
        }
    };
    template <typename _Tp = void> struct multiplies : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x * __y;
        }
    };
    template <typename _Tp = void> struct divides : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x / __y;
        }
    };
    template <typename _Tp = void> struct modulus : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x % __y;
        }
    };
    template <typename _Tp = void> struct negate : public unary_function<_Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x) const         {
            return - __x;
        }
    };
    template<> struct plus<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) + std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct minus<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) - std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct multiplies<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) * std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct divides<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) / std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct modulus<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) % std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct negate<void> {
        template <typename _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(noexcept(- std::forward<_Tp>(__t))operator()(_Tp &&__t) const noexcept(noexcept(- std::forward<_Tp>(__t))) -> decltype(- std::forward<_Tp>(__t))         {
            return - std::forward<_Tp>(__t);
        }
        typedef std::__is_transparent is_transparent;
    };
    template <typename _Tp = void> struct equal_to;
    template <typename _Tp = void> struct not_equal_to;
    template <typename _Tp = void> struct greater
template<> struct greater<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x > __y;
            return (unsigned long)__x > (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct less
template<> struct less<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    }
template<> struct less<const std::_V2::error_category *> : public binary_function<const std::_V2::error_category *, const std::_V2::error_category *, bool> {
        constexpr bool operator()(const std::_V2::error_category *__x, const std::_V2::error_category *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct greater_equal
template<> struct greater_equal<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x >= __y;
            return (unsigned long)__x >= (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct less_equal
template<> struct less_equal<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x <= __y;
            return (unsigned long)__x <= (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct equal_to : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x == __y;
        }
    };
    template <typename _Tp = void> struct not_equal_to : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x != __y;
        }
    };
    template <typename _Tp = void> struct greater : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x > __y;
        }
    };
template<> struct greater<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x > __y;
            return (unsigned long)__x > (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct less : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x < __y;
        }
    };
template<> struct less<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    };
template<> struct less<const std::_V2::error_category *> : public binary_function<const std::_V2::error_category *, const std::_V2::error_category *, bool> {
        constexpr bool operator()(const std::_V2::error_category *__x, const std::_V2::error_category *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct greater_equal : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x >= __y;
        }
    };
template<> struct greater_equal<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x >= __y;
            return (unsigned long)__x >= (unsigned long)__y;
        }
    };
    template <typename _Tp = void> struct less_equal : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x <= __y;
        }
    };
template<> struct less_equal<const volatile void *> : public binary_function<const volatile void *, const volatile void *, bool> {
        constexpr bool operator()(const volatile void *__x, const volatile void *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x <= __y;
            return (unsigned long)__x <= (unsigned long)__y;
        }
    };
    template <typename _Tp> struct greater<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
        constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x > __y;
            return (unsigned long)__x > (unsigned long)__y;
        }
    };
    template <typename _Tp> struct less<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
        constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x < __y;
            return (unsigned long)__x < (unsigned long)__y;
        }
    };
    template <typename _Tp> struct greater_equal<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
        constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x >= __y;
            return (unsigned long)__x >= (unsigned long)__y;
        }
    };
    template <typename _Tp> struct less_equal<_Tp *> : public binary_function<_Tp *, _Tp *, bool> {
        constexpr bool operator()(_Tp *__x, _Tp *__y) const noexcept         {
            if (__builtin_is_constant_evaluated())
                return __x <= __y;
            return (unsigned long)__x <= (unsigned long)__y;
        }
    };
    template<> struct equal_to<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) == std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct not_equal_to<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) != std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct greater<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))         {
            return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u), __ptr_cmp<_Tp, _Up>({}));
        }
        template <typename _Tp, typename _Up> constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept         {
            return greater<common_type_t<_Tp *, _Up *> >({})(__t, __u);
        }
        typedef std::__is_transparent is_transparent;
    private:
        template <typename _Tp, typename _Up> static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, std::false_type)         {
            return std::forward<_Tp>(__t) > std::forward<_Up>(__u);
        }
        template <typename _Tp, typename _Up> static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, std::true_type) noexcept         {
            return greater<const volatile void *>{}(static_cast<const volatile void *>(std::forward<_Tp>(__t)), static_cast<const volatile void *>(std::forward<_Up>(__u)));
        }
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded2 : std::true_type {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded2<_Tp, _Up, __void_t<decltype(std::declval<_Tp>().operator>(std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded : __not_overloaded2<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded<_Tp, _Up, __void_t<decltype(operator>(std::declval<_Tp>(), std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up> using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>, is_convertible<_Tp, const volatile void *>, is_convertible<_Up, const volatile void *> >;
    };
    template<> struct less<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))         {
            return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u), __ptr_cmp<_Tp, _Up>({}));
        }
        template <typename _Tp, typename _Up> constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept         {
            return less<common_type_t<_Tp *, _Up *> >({})(__t, __u);
        }
        typedef std::__is_transparent is_transparent;
    private:
        template <typename _Tp, typename _Up> static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, std::false_type)         {
            return std::forward<_Tp>(__t) < std::forward<_Up>(__u);
        }
        template <typename _Tp, typename _Up> static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, std::true_type) noexcept         {
            return less<const volatile void *>{}(static_cast<const volatile void *>(std::forward<_Tp>(__t)), static_cast<const volatile void *>(std::forward<_Up>(__u)));
        }
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded2 : std::true_type {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded2<_Tp, _Up, __void_t<decltype(std::declval<_Tp>().operator<(std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded : __not_overloaded2<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded<_Tp, _Up, __void_t<decltype(operator<(std::declval<_Tp>(), std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up> using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>, is_convertible<_Tp, const volatile void *>, is_convertible<_Up, const volatile void *> >;
    };
    template<> struct greater_equal<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))         {
            return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u), __ptr_cmp<_Tp, _Up>({}));
        }
        template <typename _Tp, typename _Up> constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept         {
            return greater_equal<common_type_t<_Tp *, _Up *> >({})(__t, __u);
        }
        typedef std::__is_transparent is_transparent;
    private:
        template <typename _Tp, typename _Up> static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, std::false_type)         {
            return std::forward<_Tp>(__t) >= std::forward<_Up>(__u);
        }
        template <typename _Tp, typename _Up> static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, std::true_type) noexcept         {
            return greater_equal<const volatile void *>{}(static_cast<const volatile void *>(std::forward<_Tp>(__t)), static_cast<const volatile void *>(std::forward<_Up>(__u)));
        }
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded2 : std::true_type {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded2<_Tp, _Up, __void_t<decltype(std::declval<_Tp>().operator>=(std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded : __not_overloaded2<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded<_Tp, _Up, __void_t<decltype(operator>=(std::declval<_Tp>(), std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up> using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>, is_convertible<_Tp, const volatile void *>, is_convertible<_Up, const volatile void *> >;
    };
    template<> struct less_equal<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))         {
            return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u), __ptr_cmp<_Tp, _Up>({}));
        }
        template <typename _Tp, typename _Up> constexpr bool operator()(_Tp *__t, _Up *__u) const noexcept         {
            return less_equal<common_type_t<_Tp *, _Up *> >({})(__t, __u);
        }
        typedef std::__is_transparent is_transparent;
    private:
        template <typename _Tp, typename _Up> static constexpr decltype(auto) _S_cmp(_Tp &&__t, _Up &&__u, std::false_type)         {
            return std::forward<_Tp>(__t) <= std::forward<_Up>(__u);
        }
        template <typename _Tp, typename _Up> static constexpr bool _S_cmp(_Tp &&__t, _Up &&__u, std::true_type) noexcept         {
            return less_equal<const volatile void *>{}(static_cast<const volatile void *>(std::forward<_Tp>(__t)), static_cast<const volatile void *>(std::forward<_Up>(__u)));
        }
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded2 : std::true_type {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded2<_Tp, _Up, __void_t<decltype(std::declval<_Tp>().operator<=(std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up, typename = void> struct __not_overloaded : __not_overloaded2<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __not_overloaded<_Tp, _Up, __void_t<decltype(operator<=(std::declval<_Tp>(), std::declval<_Up>()))>> : std::false_type {
        };
        template <typename _Tp, typename _Up> using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>, is_convertible<_Tp, const volatile void *>, is_convertible<_Up, const volatile void *> >;
    };
    template <typename _Tp = void> struct logical_and;
    template <typename _Tp = void> struct logical_or;
    template <typename _Tp = void> struct logical_not;
    template <typename _Tp = void> struct logical_and : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x && __y;
        }
    };
    template <typename _Tp = void> struct logical_or : public binary_function<_Tp, _Tp, bool> {
        constexpr bool operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x || __y;
        }
    };
    template <typename _Tp = void> struct logical_not : public unary_function<_Tp, bool> {
        constexpr bool operator()(const _Tp &__x) const         {
            return !__x;
        }
    };
    template<> struct logical_and<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) && std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct logical_or<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) || std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct logical_not<void> {
        template <typename _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(noexcept(!std::forward<_Tp>(__t))operator()(_Tp &&__t) const noexcept(noexcept(!std::forward<_Tp>(__t))) -> decltype(!std::forward<_Tp>(__t))         {
            return !std::forward<_Tp>(__t);
        }
        typedef std::__is_transparent is_transparent;
    };
    template <typename _Tp = void> struct bit_and;
    template <typename _Tp = void> struct bit_or;
    template <typename _Tp = void> struct bit_xor;
    template <typename _Tp = void> struct bit_not;
    template <typename _Tp = void> struct bit_and : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x & __y;
        }
    };
    template <typename _Tp = void> struct bit_or : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x | __y;
        }
    };
    template <typename _Tp = void> struct bit_xor : public binary_function<_Tp, _Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x, const _Tp &__y) const         {
            return __x ^ __y;
        }
    };
    template <typename _Tp = void> struct bit_not : public unary_function<_Tp, _Tp> {
        constexpr _Tp operator()(const _Tp &__x) const         {
            return ~__x;
        }
    };
    template<> struct bit_and<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) & std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct bit_or<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) | std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct bit_xor<void> {
        template <typename _Tp, typename _Up> constexpr auto operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))operator()(_Tp &&__t, _Up &&__u) const noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))) -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))         {
            return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u);
        }
        typedef std::__is_transparent is_transparent;
    };
    template<> struct bit_not<void> {
        template <typename _Tp> constexpr auto operator()(_Tp &&__t) const noexcept(noexcept(~std::forward<_Tp>(__t))operator()(_Tp &&__t) const noexcept(noexcept(~std::forward<_Tp>(__t))) -> decltype(~std::forward<_Tp>(__t))         {
            return ~std::forward<_Tp>(__t);
        }
        typedef std::__is_transparent is_transparent;
    };
    template <typename _Predicate> class unary_negate : public unary_function<typename _Predicate::argument_type, bool> {
    protected:
        _Predicate _M_pred;
    public:
        constexpr explicit unary_negate<_Predicate>(const _Predicate &__x) : _M_pred(__x)         {
        }
        constexpr bool operator()(const typename _Predicate::argument_type &__x) const         {
            return !this->_M_pred(__x);
        }
    };
    template <typename _Predicate> inline constexpr unary_negate<_Predicate> not1(const _Predicate &__pred)     {
        return unary_negate<_Predicate>(__pred);
    }
    template <typename _Predicate> class binary_negate : public binary_function<typename _Predicate::first_argument_type, typename _Predicate::second_argument_type, bool> {
    protected:
        _Predicate _M_pred;
    public:
        constexpr explicit binary_negate<_Predicate>(const _Predicate &__x) : _M_pred(__x)         {
        }
        constexpr bool operator()(const typename _Predicate::first_argument_type &__x, const typename _Predicate::second_argument_type &__y) const         {
            return !this->_M_pred(__x, __y);
        }
    };
    template <typename _Predicate> inline constexpr binary_negate<_Predicate> not2(const _Predicate &__pred)     {
        return binary_negate<_Predicate>(__pred);
    }
    template <typename _Arg, typename _Result> class pointer_to_unary_function : public unary_function<_Arg, _Result> {
    protected:
        _Result (*_M_ptr)(_Arg);
    public:
        pointer_to_unary_function<_Arg, _Result>()         {
        }
        explicit pointer_to_unary_function<_Arg, _Result>(_Result (*__x)(_Arg)) : _M_ptr(__x)         {
        }
        _Result operator()(_Arg __x) const         {
            return this->_M_ptr(__x);
        }
    };
    template <typename _Arg, typename _Result> inline pointer_to_unary_function<_Arg, _Result> ptr_fun(_Result (*__x)(_Arg))     {
        return pointer_to_unary_function<_Arg, _Result>(__x);
    }
    template <typename _Arg1, typename _Arg2, typename _Result> class pointer_to_binary_function : public binary_function<_Arg1, _Arg2, _Result> {
    protected:
        _Result (*_M_ptr)(_Arg1, _Arg2);
    public:
        pointer_to_binary_function<_Arg1, _Arg2, _Result>()         {
        }
        explicit pointer_to_binary_function<_Arg1, _Arg2, _Result>(_Result (*__x)(_Arg1, _Arg2)) : _M_ptr(__x)         {
        }
        _Result operator()(_Arg1 __x, _Arg2 __y) const         {
            return this->_M_ptr(__x, __y);
        }
    };
    template <typename _Arg1, typename _Arg2, typename _Result> inline pointer_to_binary_function<_Arg1, _Arg2, _Result> ptr_fun(_Result (*__x)(_Arg1, _Arg2))     {
        return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x);
    }
    template <typename _Tp> struct _Identity : public unary_function<_Tp, _Tp> {
        _Tp &operator()(_Tp &__x) const         {
            return __x;
        }
        const _Tp &operator()(const _Tp &__x) const         {
            return __x;
        }
    };
    template <typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> {
    };
    template <typename _Pair> struct _Select1st : public unary_function<_Pair, typename _Pair::first_type> {
        typename _Pair::first_type &operator()(_Pair &__x) const         {
            return __x.first;
        }
        const typename _Pair::first_type &operator()(const _Pair &__x) const         {
            return __x.first;
        }
        template <typename _Pair2> typename _Pair2::first_type &operator()(_Pair2 &__x) const         {
            return __x.first;
        }
        template <typename _Pair2> const typename _Pair2::first_type &operator()(const _Pair2 &__x) const         {
            return __x.first;
        }
    };
    template <typename _Pair> struct _Select2nd : public unary_function<_Pair, typename _Pair::second_type> {
        typename _Pair::second_type &operator()(_Pair &__x) const         {
            return __x.second;
        }
        const typename _Pair::second_type &operator()(const _Pair &__x) const         {
            return __x.second;
        }
    };
    template <typename _Ret, typename _Tp> class mem_fun_t : public unary_function<_Tp *, _Ret> {
    public:
        explicit mem_fun_t<_Ret, _Tp>(_Ret (_Tp::*__pf)()) : _M_f(__pf)         {
        }
        _Ret operator()(_Tp *__p) const         {
            return (__p ->* this->_M_f)();
        }
    private:
        _Ret (_Tp::*_M_f)();
    };
    template <typename _Ret, typename _Tp> class const_mem_fun_t : public unary_function<const _Tp *, _Ret> {
    public:
        explicit const_mem_fun_t<_Ret, _Tp>(_Ret (_Tp::*__pf)() const) : _M_f(__pf)         {
        }
        _Ret operator()(const _Tp *__p) const         {
            return (__p ->* this->_M_f)();
        }
    private:
        _Ret (_Tp::*_M_f)() const;
    };
    template <typename _Ret, typename _Tp> class mem_fun_ref_t : public unary_function<_Tp, _Ret> {
    public:
        explicit mem_fun_ref_t<_Ret, _Tp>(_Ret (_Tp::*__pf)()) : _M_f(__pf)         {
        }
        _Ret operator()(_Tp &__r) const         {
            return (__r .* this->_M_f)();
        }
    private:
        _Ret (_Tp::*_M_f)();
    };
    template <typename _Ret, typename _Tp> class const_mem_fun_ref_t : public unary_function<_Tp, _Ret> {
    public:
        explicit const_mem_fun_ref_t<_Ret, _Tp>(_Ret (_Tp::*__pf)() const) : _M_f(__pf)         {
        }
        _Ret operator()(const _Tp &__r) const         {
            return (__r .* this->_M_f)();
        }
    private:
        _Ret (_Tp::*_M_f)() const;
    };
    template <typename _Ret, typename _Tp, typename _Arg> class mem_fun1_t : public binary_function<_Tp *, _Arg, _Ret> {
    public:
        explicit mem_fun1_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf)         {
        }
        _Ret operator()(_Tp *__p, _Arg __x) const         {
            return (__p ->* this->_M_f)(__x);
        }
    private:
        _Ret (_Tp::*_M_f)(_Arg);
    };
    template <typename _Ret, typename _Tp, typename _Arg> class const_mem_fun1_t : public binary_function<const _Tp *, _Arg, _Ret> {
    public:
        explicit const_mem_fun1_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf)         {
        }
        _Ret operator()(const _Tp *__p, _Arg __x) const         {
            return (__p ->* this->_M_f)(__x);
        }
    private:
        _Ret (_Tp::*_M_f)(_Arg) const;
    };
    template <typename _Ret, typename _Tp, typename _Arg> class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret> {
    public:
        explicit mem_fun1_ref_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg)) : _M_f(__pf)         {
        }
        _Ret operator()(_Tp &__r, _Arg __x) const         {
            return (__r .* this->_M_f)(__x);
        }
    private:
        _Ret (_Tp::*_M_f)(_Arg);
    };
    template <typename _Ret, typename _Tp, typename _Arg> class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret> {
    public:
        explicit const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(_Ret (_Tp::*__pf)(_Arg) const) : _M_f(__pf)         {
        }
        _Ret operator()(const _Tp &__r, _Arg __x) const         {
            return (__r .* this->_M_f)(__x);
        }
    private:
        _Ret (_Tp::*_M_f)(_Arg) const;
    };
    template <typename _Ret, typename _Tp> inline mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)())     {
        return mem_fun_t<_Ret, _Tp>(__f);
    }
    template <typename _Ret, typename _Tp> inline const_mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)() const)     {
        return const_mem_fun_t<_Ret, _Tp>(__f);
    }
    template <typename _Ret, typename _Tp> inline mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)())     {
        return mem_fun_ref_t<_Ret, _Tp>(__f);
    }
    template <typename _Ret, typename _Tp> inline const_mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)() const)     {
        return const_mem_fun_ref_t<_Ret, _Tp>(__f);
    }
    template <typename _Ret, typename _Tp, typename _Arg> inline mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg))     {
        return mem_fun1_t<_Ret, _Tp, _Arg>(__f);
    }
    template <typename _Ret, typename _Tp, typename _Arg> inline const_mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg) const)     {
        return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f);
    }
    template <typename _Ret, typename _Tp, typename _Arg> inline mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg))     {
        return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
    }
    template <typename _Ret, typename _Tp, typename _Arg> inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)     {
        return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
    }
}
namespace std {
    template <typename _Operation> class __attribute__((deprecated(""))) binder1st : public unary_function<typename _Operation::second_argument_type, typename _Operation::result_type> {
    protected:
        _Operation op;
        typename _Operation::first_argument_type value;
    public:
        binder1st<_Operation>(const _Operation &__x, const typename _Operation::first_argument_type &__y) : op(__x), value(__y)         {
        }
        typename _Operation::result_type operator()(const typename _Operation::second_argument_type &__x) const         {
            return this->op(this->value, __x);
        }
        typename _Operation::result_type operator()(typename _Operation::second_argument_type &__x) const         {
            return this->op(this->value, __x);
        }
    };
    template <typename _Operation, typename _Tp> inline binder1st<_Operation> bind1st(const _Operation &__fn, const _Tp &__x)     {
        typedef typename _Operation::first_argument_type _Arg1_type;
        return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }
    template <typename _Operation> class __attribute__((deprecated(""))) binder2nd : public unary_function<typename _Operation::first_argument_type, typename _Operation::result_type> {
    protected:
        _Operation op;
        typename _Operation::second_argument_type value;
    public:
        binder2nd<_Operation>(const _Operation &__x, const typename _Operation::second_argument_type &__y) : op(__x), value(__y)         {
        }
        typename _Operation::result_type operator()(const typename _Operation::first_argument_type &__x) const         {
            return this->op(__x, this->value);
        }
        typename _Operation::result_type operator()(typename _Operation::first_argument_type &__x) const         {
            return this->op(__x, this->value);
        }
    };
    template <typename _Operation, typename _Tp> inline binder2nd<_Operation> bind2nd(const _Operation &__fn, const _Tp &__x)     {
        typedef typename _Operation::second_argument_type _Arg2_type;
        return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }
}
namespace std {
    template <class _E> class initializer_list {
    public:
        typedef _E value_type;
        typedef const _E &reference;
        typedef const _E &const_reference;
        typedef std::size_t size_type;
        typedef const _E *iterator;
        typedef const _E *const_iterator;
    private:
        std::initializer_list::iterator _M_array;
        std::initializer_list::size_type _M_len;
        constexpr initializer_list<_E>(std::initializer_list::const_iterator __a, std::initializer_list::size_type __l) : _M_array(__a), _M_len(__l)         {
        }
    public:
        constexpr initializer_list<_E>() noexcept : _M_array(0), _M_len(0)         {
        }
        constexpr std::initializer_list::size_type size() const noexcept         {
            return this->_M_len;
        }
        constexpr std::initializer_list::const_iterator begin() const noexcept         {
            return this->_M_array;
        }
        constexpr std::initializer_list::const_iterator end() const noexcept         {
            return this->begin() + this->size();
        }
    };
template<> class initializer_list<char> {
    public:
        typedef char value_type;
        typedef const char &reference;
        typedef const char &const_reference;
        typedef std::size_t size_type;
        typedef const char *iterator;
        typedef const char *const_iterator;
    private:
        std::initializer_list<char>::iterator _M_array;
        std::initializer_list::size_type _M_len;
        constexpr initializer_list(std::initializer_list<char>::const_iterator __a, std::initializer_list::size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr std::initializer_list::size_type size() const noexcept;
        constexpr std::initializer_list<char>::const_iterator begin() const noexcept;
        constexpr std::initializer_list<char>::const_iterator end() const noexcept;
    };
template<> class initializer_list<wchar_t> {
    public:
        typedef wchar_t value_type;
        typedef const wchar_t &reference;
        typedef const wchar_t &const_reference;
        typedef std::size_t size_type;
        typedef const wchar_t *iterator;
        typedef const wchar_t *const_iterator;
    private:
        std::initializer_list<wchar_t>::iterator _M_array;
        std::initializer_list::size_type _M_len;
        constexpr initializer_list(std::initializer_list<wchar_t>::const_iterator __a, std::initializer_list::size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr std::initializer_list::size_type size() const noexcept;
        constexpr std::initializer_list<wchar_t>::const_iterator begin() const noexcept;
        constexpr std::initializer_list<wchar_t>::const_iterator end() const noexcept;
    };
template<> class initializer_list<char16_t> {
    public:
        typedef char16_t value_type;
        typedef const char16_t &reference;
        typedef const char16_t &const_reference;
        typedef std::size_t size_type;
        typedef const char16_t *iterator;
        typedef const char16_t *const_iterator;
    private:
        std::initializer_list<char16_t>::iterator _M_array;
        std::initializer_list::size_type _M_len;
        constexpr initializer_list(std::initializer_list<char16_t>::const_iterator __a, std::initializer_list::size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr std::initializer_list::size_type size() const noexcept;
        constexpr std::initializer_list<char16_t>::const_iterator begin() const noexcept;
        constexpr std::initializer_list<char16_t>::const_iterator end() const noexcept;
    };
template<> class initializer_list<char32_t> {
    public:
        typedef char32_t value_type;
        typedef const char32_t &reference;
        typedef const char32_t &const_reference;
        typedef std::size_t size_type;
        typedef const char32_t *iterator;
        typedef const char32_t *const_iterator;
    private:
        std::initializer_list<char32_t>::iterator _M_array;
        std::initializer_list::size_type _M_len;
        constexpr initializer_list(std::initializer_list<char32_t>::const_iterator __a, std::initializer_list::size_type __l);
    public:
        constexpr initializer_list() noexcept;
        constexpr std::initializer_list::size_type size() const noexcept;
        constexpr std::initializer_list<char32_t>::const_iterator begin() const noexcept;
        constexpr std::initializer_list<char32_t>::const_iterator end() const noexcept;
    };
    template <class _Tp> constexpr const _Tp *begin(initializer_list<_Tp> __ils) noexcept     {
        return __ils.begin();
    }
    template <class _Tp> constexpr const _Tp *end(initializer_list<_Tp> __ils) noexcept     {
        return __ils.end();
    }
}
namespace std {
    template <typename _Container> inline auto begin(_Container &__cont) -> decltype(__cont.begin())     {
        return __cont.begin();
    }
    template <typename _Container> inline auto begin(const _Container &__cont) -> decltype(__cont.begin())     {
        return __cont.begin();
    }
    template <typename _Container> inline auto end(_Container &__cont) -> decltype(__cont.end())     {
        return __cont.end();
    }
    template <typename _Container> inline auto end(const _Container &__cont) -> decltype(__cont.end())     {
        return __cont.end();
    }
    template <typename _Tp, std::size_t _Nm> inline constexpr _Tp *begin(_Tp (&__arr)[_Nm])     {
        return __arr;
    }
    template <typename _Tp, std::size_t _Nm> inline constexpr _Tp *end(_Tp (&__arr)[_Nm])     {
        return __arr + _Nm;
    }
    template <typename _Tp> class valarray;
    template <typename _Tp> _Tp *begin(valarray<_Tp> &);
    template <typename _Tp> const _Tp *begin(const valarray<_Tp> &);
    template <typename _Tp> _Tp *end(valarray<_Tp> &);
    template <typename _Tp> const _Tp *end(const valarray<_Tp> &);
    template <typename _Container> inline constexpr auto cbegin(const _Container &__cont) noexcept(noexcept(std::begin(__cont))cbegin(const _Container &__cont) noexcept(noexcept(std::begin(__cont))) -> decltype(std::begin(__cont))     {
        return std::begin(__cont);
    }
    template <typename _Container> inline constexpr auto cend(const _Container &__cont) noexcept(noexcept(std::end(__cont))cend(const _Container &__cont) noexcept(noexcept(std::end(__cont))) -> decltype(std::end(__cont))     {
        return std::end(__cont);
    }
    template <typename _Container> inline auto rbegin(_Container &__cont) -> decltype(__cont.rbegin())     {
        return __cont.rbegin();
    }
    template <typename _Container> inline auto rbegin(const _Container &__cont) -> decltype(__cont.rbegin())     {
        return __cont.rbegin();
    }
    template <typename _Container> inline auto rend(_Container &__cont) -> decltype(__cont.rend())     {
        return __cont.rend();
    }
    template <typename _Container> inline auto rend(const _Container &__cont) -> decltype(__cont.rend())     {
        return __cont.rend();
    }
    template <typename _Tp, std::size_t _Nm> inline reverse_iterator<_Tp *> rbegin(_Tp (&__arr)[_Nm])     {
        return reverse_iterator<_Tp *>(__arr + _Nm);
    }
    template <typename _Tp, std::size_t _Nm> inline reverse_iterator<_Tp *> rend(_Tp (&__arr)[_Nm])     {
        return reverse_iterator<_Tp *>(__arr);
    }
    template <typename _Tp> inline reverse_iterator<const _Tp *> rbegin(initializer_list<_Tp> __il)     {
        return reverse_iterator<const _Tp *>(__il.end());
    }
    template <typename _Tp> inline reverse_iterator<const _Tp *> rend(initializer_list<_Tp> __il)     {
        return reverse_iterator<const _Tp *>(__il.begin());
    }
    template <typename _Container> inline auto crbegin(const _Container &__cont) -> decltype(std::rbegin(__cont))     {
        return std::rbegin(__cont);
    }
    template <typename _Container> inline auto crend(const _Container &__cont) -> decltype(std::rend(__cont))     {
        return std::rend(__cont);
    }
}
namespace std {
    struct __allocator_traits_base {
        template <typename _Tp, typename _Up, typename = void> struct __rebind : __replace_first_arg<_Tp, _Up> {
        };
        template <typename _Tp, typename _Up> struct __rebind<_Tp, _Up, __void_t<typename _Tp::template _Tp::rebind<_Up>::other>> {
            using type = typename _Tp::template _Tp::rebind<_Up>::other;
        };
    protected:
        template <typename _Tp> using __pointer = typename _Tp::pointer;
        template <typename _Tp> using __c_pointer = typename _Tp::const_pointer;
        template <typename _Tp> using __v_pointer = typename _Tp::void_pointer;
        template <typename _Tp> using __cv_pointer = typename _Tp::const_void_pointer;
        template <typename _Tp> using __pocca = typename _Tp::propagate_on_container_copy_assignment;
        template <typename _Tp> using __pocma = typename _Tp::propagate_on_container_move_assignment;
        template <typename _Tp> using __pocs = typename _Tp::propagate_on_container_swap;
        template <typename _Tp> using __equal = typename _Tp::is_always_equal;
    };
    template <typename _Alloc, typename _Up> using __alloc_rebind = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;
    template <typename _Alloc> struct allocator_traits : std::__allocator_traits_base {
        typedef _Alloc allocator_type;
        typedef typename _Alloc::value_type value_type;
        using pointer = __detected_or_t<std::allocator_traits::value_type *, __pointer, _Alloc>;
    private:
        template <template <typename> class _Func, typename _Tp, typename = void> struct _Ptr {
            using type = typename pointer_traits<pointer>::rebind<_Tp>;
        };
        template <template <typename> class _Func, typename _Tp> struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc> >> {
            using type = _Func<_Alloc>;
        };
        template <typename _A2, typename _PtrT, typename = void> struct _Diff {
            using type = typename pointer_traits<_PtrT>::difference_type;
        };
        template <typename _A2, typename _PtrT> struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>> {
            using type = typename _A2::difference_type;
        };
        template <typename _A2, typename _DiffT, typename = void> struct _Size : make_unsigned<_DiffT> {
        };
        template <typename _A2, typename _DiffT> struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>> {
            using type = typename _A2::size_type;
        };
    public:
        using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;
        using void_pointer = typename _Ptr<__v_pointer, void>::type;
        using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;
        using difference_type = typename _Diff<_Alloc, pointer>::type;
        using size_type = typename _Size<_Alloc, difference_type>::type;
        using propagate_on_container_copy_assignment = __detected_or_t<std::false_type, __pocca, _Alloc>;
        using propagate_on_container_move_assignment = __detected_or_t<std::false_type, __pocma, _Alloc>;
        using propagate_on_container_swap = __detected_or_t<std::false_type, __pocs, _Alloc>;
        using is_always_equal = __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;
        template <typename _Tp> using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
        template <typename _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp> >;
    private:
        template <typename _Alloc2> static auto _S_allocate(_Alloc2 &__a, std::allocator_traits::size_type __n, std::allocator_traits::const_void_pointer __hint, int) -> decltype(__a.allocate(__n, __hint))         {
            return __a.allocate(__n, __hint);
        }
        template <typename _Alloc2> static std::allocator_traits::pointer _S_allocate(_Alloc2 &__a, std::allocator_traits::size_type __n, std::allocator_traits::const_void_pointer, ...)         {
            return __a.allocate(__n);
        }
        template <typename _Tp, typename ..._Args> struct __construct_helper {
            template <typename _Alloc2, typename = decltype(std::declval<_Alloc2 *>()->construct(std::declval<_Tp *>(), std::declval<_Args>()...))> static std::true_type __test(int);
            template <typename> static std::false_type __test(...);
            using type = decltype(__test<_Alloc>(0));
        };
        template <typename _Tp, typename ..._Args> using __has_construct = typename __construct_helper<_Tp, _Args...>::type;
        template <typename _Tp, typename ..._Args> static _Require<__has_construct<_Tp, _Args...> > _S_construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...))_S_construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...)))         {
            __a.construct(__p, std::forward<_Args>(__args)...);
        }
        template <typename _Tp, typename ..._Args> static _Require<__and_<__not_<__has_construct<_Tp, _Args...> >, is_constructible<_Tp, _Args...> > > _S_construct(_Alloc &, _Tp *__p, _Args &&...__args) noexcept(noexcept(::new ((void *)__p) _Tp((std::forward<_Args>(__args)...)))_S_construct(_Alloc &, _Tp *__p, _Args &&...__args) noexcept(noexcept(::new ((void *)__p) _Tp((std::forward<_Args>(__args)...))))         {
            ::new ((void *)__p) _Tp((std::forward<_Args>(__args)...));
        }
        template <typename _Alloc2, typename _Tp> static auto _S_destroy(_Alloc2 &__a, _Tp *__p, int) noexcept(noexcept(__a.destroy(__p))_S_destroy(_Alloc2 &__a, _Tp *__p, int) noexcept(noexcept(__a.destroy(__p))) -> decltype(__a.destroy(__p))         {
            __a.destroy(__p);
        }
        template <typename _Alloc2, typename _Tp> static void _S_destroy(_Alloc2 &, _Tp *__p, ...) noexcept(noexcept(__p->~_Tp())_S_destroy(_Alloc2 &, _Tp *__p, ...) noexcept(noexcept(__p->~_Tp()))         {
            __p->~_Tp();
        }
        template <typename _Alloc2> static auto _S_max_size(_Alloc2 &__a, int) -> decltype(__a.max_size())         {
            return __a.max_size();
        }
        template <typename _Alloc2> static std::allocator_traits::size_type _S_max_size(_Alloc2 &, ...)         {
            return __gnu_cxx::__numeric_traits<size_type>::__max / sizeof(std::allocator_traits::value_type);
        }
        template <typename _Alloc2> static auto _S_select(_Alloc2 &__a, int) -> decltype(__a.select_on_container_copy_construction())         {
            return __a.select_on_container_copy_construction();
        }
        template <typename _Alloc2> static _Alloc2 _S_select(_Alloc2 &__a, ...)         {
            return __a;
        }
    public:
        static std::allocator_traits::pointer allocate(_Alloc &__a, std::allocator_traits::size_type __n)         {
            return __a.allocate(__n);
        }
        static std::allocator_traits::pointer allocate(_Alloc &__a, std::allocator_traits::size_type __n, std::allocator_traits::const_void_pointer __hint)         {
            return _S_allocate(__a, __n, __hint, 0);
        }
        static void deallocate(_Alloc &__a, std::allocator_traits::pointer __p, std::allocator_traits::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Tp, typename ..._Args> static auto construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(noexcept(_S_construct(__a, __p, std::forward<_Args>(__args)...))construct(_Alloc &__a, _Tp *__p, _Args &&...__args) noexcept(noexcept(_S_construct(__a, __p, std::forward<_Args>(__args)...))) -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))         {
            _S_construct(__a, __p, std::forward<_Args>(__args)...);
        }
        template <typename _Tp> static void destroy(_Alloc &__a, _Tp *__p) noexcept(noexcept(_S_destroy(__a, __p, 0))destroy(_Alloc &__a, _Tp *__p) noexcept(noexcept(_S_destroy(__a, __p, 0)))         {
            _S_destroy(__a, __p, 0);
        }
        static std::allocator_traits::size_type max_size(const _Alloc &__a) noexcept         {
            return _S_max_size(__a, 0);
        }
        static _Alloc select_on_container_copy_construction(const _Alloc &__rhs)         {
            return _S_select(__rhs, 0);
        }
    };
template<> struct allocator_traits<std::allocator<char>> {
        using allocator_type = allocator<char>;
        using value_type = char;
        using pointer = char *;
        using const_pointer = const char *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up> >;
        static std::allocator_traits<std::allocator<char> >::pointer allocate(std::allocator_traits<std::allocator<char> >::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0> >::size_type __n);
        static std::allocator_traits<std::allocator<char> >::pointer allocate(std::allocator_traits<std::allocator<char> >::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0> >::size_type __n, std::allocator_traits<allocator<type-parameter-0-0> >::const_void_pointer __hint);
        static void deallocate(std::allocator_traits<std::allocator<char> >::allocator_type &__a, std::allocator_traits<std::allocator<char> >::pointer __p, std::allocator_traits<allocator<type-parameter-0-0> >::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static void construct(std::allocator_traits<std::allocator<char> >::allocator_type &__a, _Up *__p, _Args &&...__args);
        template <typename _Up> static void destroy(std::allocator_traits<std::allocator<char> >::allocator_type &__a, _Up *__p);
        static std::allocator_traits<std::allocator<char> >::size_type max_size(const std::allocator_traits<std::allocator<char> >::allocator_type &__a) noexcept         {
            return __a.max_size();
        }
        static std::allocator_traits<std::allocator<char> >::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<char> >::allocator_type &__rhs)         {
            return __rhs;
        }
    };
template<> struct allocator_traits<std::allocator<wchar_t>> {
        using allocator_type = allocator<wchar_t>;
        using value_type = wchar_t;
        using pointer = wchar_t *;
        using const_pointer = const wchar_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up> >;
        static std::allocator_traits<std::allocator<wchar_t> >::pointer allocate(std::allocator_traits<std::allocator<wchar_t> >::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0> >::size_type __n);
        static std::allocator_traits<std::allocator<wchar_t> >::pointer allocate(std::allocator_traits<std::allocator<wchar_t> >::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0> >::size_type __n, std::allocator_traits<allocator<type-parameter-0-0> >::const_void_pointer __hint);
        static void deallocate(std::allocator_traits<std::allocator<wchar_t> >::allocator_type &__a, std::allocator_traits<std::allocator<wchar_t> >::pointer __p, std::allocator_traits<allocator<type-parameter-0-0> >::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static void construct(std::allocator_traits<std::allocator<wchar_t> >::allocator_type &__a, _Up *__p, _Args &&...__args);
        template <typename _Up> static void destroy(std::allocator_traits<std::allocator<wchar_t> >::allocator_type &__a, _Up *__p);
        static std::allocator_traits<std::allocator<wchar_t> >::size_type max_size(const std::allocator_traits<std::allocator<wchar_t> >::allocator_type &__a) noexcept;
        static std::allocator_traits<std::allocator<wchar_t> >::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<wchar_t> >::allocator_type &__rhs);
    };
template<> struct allocator_traits<std::allocator<char16_t>> {
        using allocator_type = allocator<char16_t>;
        using value_type = char16_t;
        using pointer = char16_t *;
        using const_pointer = const char16_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up> >;
        static std::allocator_traits<std::allocator<char16_t> >::pointer allocate(std::allocator_traits<std::allocator<char16_t> >::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0> >::size_type __n)         {
            return __a.allocate(__n);
        }
        static std::allocator_traits<std::allocator<char16_t> >::pointer allocate(std::allocator_traits<std::allocator<char16_t> >::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0> >::size_type __n, std::allocator_traits<allocator<type-parameter-0-0> >::const_void_pointer __hint);
        static void deallocate(std::allocator_traits<std::allocator<char16_t> >::allocator_type &__a, std::allocator_traits<std::allocator<char16_t> >::pointer __p, std::allocator_traits<allocator<type-parameter-0-0> >::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static void construct(std::allocator_traits<std::allocator<char16_t> >::allocator_type &__a, _Up *__p, _Args &&...__args);
        template <typename _Up> static void destroy(std::allocator_traits<std::allocator<char16_t> >::allocator_type &__a, _Up *__p);
        static std::allocator_traits<std::allocator<char16_t> >::size_type max_size(const std::allocator_traits<std::allocator<char16_t> >::allocator_type &__a) noexcept         {
            return __a.max_size();
        }
        static std::allocator_traits<std::allocator<char16_t> >::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<char16_t> >::allocator_type &__rhs);
    };
template<> struct allocator_traits<std::allocator<char32_t>> {
        using allocator_type = allocator<char32_t>;
        using value_type = char32_t;
        using pointer = char32_t *;
        using const_pointer = const char32_t *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up> >;
        static std::allocator_traits<std::allocator<char32_t> >::pointer allocate(std::allocator_traits<std::allocator<char32_t> >::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0> >::size_type __n)         {
            return __a.allocate(__n);
        }
        static std::allocator_traits<std::allocator<char32_t> >::pointer allocate(std::allocator_traits<std::allocator<char32_t> >::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0> >::size_type __n, std::allocator_traits<allocator<type-parameter-0-0> >::const_void_pointer __hint);
        static void deallocate(std::allocator_traits<std::allocator<char32_t> >::allocator_type &__a, std::allocator_traits<std::allocator<char32_t> >::pointer __p, std::allocator_traits<allocator<type-parameter-0-0> >::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static void construct(std::allocator_traits<std::allocator<char32_t> >::allocator_type &__a, _Up *__p, _Args &&...__args);
        template <typename _Up> static void destroy(std::allocator_traits<std::allocator<char32_t> >::allocator_type &__a, _Up *__p);
        static std::allocator_traits<std::allocator<char32_t> >::size_type max_size(const std::allocator_traits<std::allocator<char32_t> >::allocator_type &__a) noexcept         {
            return __a.max_size();
        }
        static std::allocator_traits<std::allocator<char32_t> >::allocator_type select_on_container_copy_construction(const std::allocator_traits<std::allocator<char32_t> >::allocator_type &__rhs);
    };
    template <typename _Tp> struct allocator_traits<allocator<_Tp>> {
        using allocator_type = allocator<_Tp>;
        using value_type = _Tp;
        using pointer = _Tp *;
        using const_pointer = const _Tp *;
        using void_pointer = void *;
        using const_void_pointer = const void *;
        using difference_type = std::ptrdiff_t;
        using size_type = std::size_t;
        using propagate_on_container_copy_assignment = std::false_type;
        using propagate_on_container_move_assignment = std::true_type;
        using propagate_on_container_swap = std::false_type;
        using is_always_equal = std::true_type;
        template <typename _Up> using rebind_alloc = allocator<_Up>;
        template <typename _Up> using rebind_traits = allocator_traits<allocator<_Up> >;
        static std::allocator_traits<allocator<type-parameter-0-0> >::pointer allocate(std::allocator_traits<allocator<type-parameter-0-0> >::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0> >::size_type __n)         {
            return __a.allocate(__n);
        }
        static std::allocator_traits<allocator<type-parameter-0-0> >::pointer allocate(std::allocator_traits<allocator<type-parameter-0-0> >::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0> >::size_type __n, std::allocator_traits<allocator<type-parameter-0-0> >::const_void_pointer __hint)         {
            return __a.allocate(__n, __hint);
        }
        static void deallocate(std::allocator_traits<allocator<type-parameter-0-0> >::allocator_type &__a, std::allocator_traits<allocator<type-parameter-0-0> >::pointer __p, std::allocator_traits<allocator<type-parameter-0-0> >::size_type __n)         {
            __a.deallocate(__p, __n);
        }
        template <typename _Up, typename ..._Args> static void construct(std::allocator_traits<allocator<type-parameter-0-0> >::allocator_type &__a, _Up *__p, _Args &&...__args) noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...))construct(std::allocator_traits<allocator<type-parameter-0-0> >::allocator_type &__a, _Up *__p, _Args &&...__args) noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...)))         {
            __a.construct(__p, std::forward<_Args>(__args)...);
        }
        template <typename _Up> static void destroy(std::allocator_traits<allocator<type-parameter-0-0> >::allocator_type &__a, _Up *__p) noexcept(noexcept(__a.destroy(__p))destroy(std::allocator_traits<allocator<type-parameter-0-0> >::allocator_type &__a, _Up *__p) noexcept(noexcept(__a.destroy(__p)))         {
            __a.destroy(__p);
        }
        static std::allocator_traits<allocator<type-parameter-0-0> >::size_type max_size(const std::allocator_traits<allocator<type-parameter-0-0> >::allocator_type &__a) noexcept         {
            return __a.max_size();
        }
        static std::allocator_traits<allocator<type-parameter-0-0> >::allocator_type select_on_container_copy_construction(const std::allocator_traits<allocator<type-parameter-0-0> >::allocator_type &__rhs)         {
            return __rhs;
        }
    };
    template <typename _Alloc> inline void __do_alloc_on_copy(_Alloc &__one, const _Alloc &__two, std::true_type)     {
        __one = __two;
    }
    template <typename _Alloc> inline void __do_alloc_on_copy(_Alloc &, const _Alloc &, std::false_type)     {
    }
    template <typename _Alloc> inline void __alloc_on_copy(_Alloc &__one, const _Alloc &__two)     {
        typedef allocator_traits<_Alloc> __traits;
        typedef typename __traits::propagate_on_container_copy_assignment __pocca;
        __do_alloc_on_copy(__one, __two, __pocca());
    }
    template <typename _Alloc> inline _Alloc __alloc_on_copy(const _Alloc &__a)     {
        typedef allocator_traits<_Alloc> __traits;
        return __traits::select_on_container_copy_construction(__a);
    }
    template <typename _Alloc> inline void __do_alloc_on_move(_Alloc &__one, _Alloc &__two, std::true_type)     {
        __one = std::move(__two);
    }
    template <typename _Alloc> inline void __do_alloc_on_move(_Alloc &, _Alloc &, std::false_type)     {
    }
    template <typename _Alloc> inline void __alloc_on_move(_Alloc &__one, _Alloc &__two)     {
        typedef allocator_traits<_Alloc> __traits;
        typedef typename __traits::propagate_on_container_move_assignment __pocma;
        __do_alloc_on_move(__one, __two, __pocma());
    }
    template <typename _Alloc> inline void __do_alloc_on_swap(_Alloc &__one, _Alloc &__two, std::true_type)     {
        using std::swap;
        swap(__one, __two);
    }
    template <typename _Alloc> inline void __do_alloc_on_swap(_Alloc &, _Alloc &, std::false_type)     {
    }
    template <typename _Alloc> inline void __alloc_on_swap(_Alloc &__one, _Alloc &__two)     {
        typedef allocator_traits<_Alloc> __traits;
        typedef typename __traits::propagate_on_container_swap __pocs;
        __do_alloc_on_swap(__one, __two, __pocs());
    }
    template <typename _Alloc, typename _Tp, typename _ValueT = __remove_cvref_t<typename _Alloc::value_type>, typename = void> struct __is_alloc_insertable_impl : std::false_type {
    };
    template <typename _Alloc, typename _Tp, typename _ValueT> struct __is_alloc_insertable_impl<_Alloc, _Tp, _ValueT, __void_t<decltype(allocator_traits<_Alloc>::construct(std::declval<_Alloc &>(), std::declval<_ValueT *>(), std::declval<_Tp>()))>> : std::true_type {
    };
    template <typename _Alloc> struct __is_copy_insertable : __is_alloc_insertable_impl<_Alloc, const typename _Alloc::value_type &>::type {
    };
    template <typename _Tp> struct __is_copy_insertable<allocator<_Tp>> : is_copy_constructible<_Tp> {
    };
    template <typename _Alloc> struct __is_move_insertable : __is_alloc_insertable_impl<_Alloc, typename _Alloc::value_type>::type {
    };
    template <typename _Tp> struct __is_move_insertable<allocator<_Tp>> : is_move_constructible<_Tp> {
    };
    template <typename _Alloc, typename = void> struct __is_allocator : std::false_type {
    };
    template <typename _Alloc> struct __is_allocator<_Alloc, __void_t<typename _Alloc::value_type, decltype(std::declval<_Alloc &>().allocate(std::size_t{}))>> : std::true_type {
    };
    template <typename _Alloc> using _RequireAllocator = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;
    template <typename _Alloc> using _RequireNotAllocator = typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;
}
namespace __gnu_cxx {
    template <typename _Alloc, typename = typename _Alloc::value_type> struct __alloc_traits : std::allocator_traits<_Alloc> {
        typedef _Alloc allocator_type;
        typedef std::allocator_traits<_Alloc> _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef __gnu_cxx::__alloc_traits::value_type &reference;
        typedef const __gnu_cxx::__alloc_traits::value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr> > >;
    public:
        template <typename _Ptr, typename ..._Args> static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type construct(_Alloc &__a, _Ptr __p, _Args &&...__args) noexcept(noexcept(_Base_type::construct(__a, std::__to_address(__p), std::forward<_Args>(__args)...))construct(_Alloc &__a, _Ptr __p, _Args &&...__args) noexcept(noexcept(_Base_type::construct(__a, std::__to_address(__p), std::forward<_Args>(__args)...)))         {
            _Base_type::construct(__a, std::__to_address(__p), std::forward<_Args>(__args)...);
        }
        template <typename _Ptr> static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type destroy(_Alloc &__a, _Ptr __p) noexcept(noexcept(_Base_type::destroy(__a, std::__to_address(__p)))destroy(_Alloc &__a, _Ptr __p) noexcept(noexcept(_Base_type::destroy(__a, std::__to_address(__p))))         {
            _Base_type::destroy(__a, std::__to_address(__p));
        }
        static _Alloc _S_select_on_copy(const _Alloc &__a)         {
            return _Base_type::select_on_container_copy_construction(__a);
        }
        static void _S_on_swap(_Alloc &__a, _Alloc &__b)         {
            std::__alloc_on_swap(__a, __b);
        }
        static constexpr bool _S_propagate_on_copy_assign()         {
            return _Base_type::propagate_on_container_copy_assignment::value;
        }
        static constexpr bool _S_propagate_on_move_assign()         {
            return _Base_type::propagate_on_container_move_assignment::value;
        }
        static constexpr bool _S_propagate_on_swap()         {
            return _Base_type::propagate_on_container_swap::value;
        }
        static constexpr bool _S_always_equal()         {
            return _Base_type::is_always_equal::value;
        }
        static constexpr bool _S_nothrow_move()         {
            return _S_propagate_on_move_assign() || _S_always_equal();
        }
        template <typename _Tp> struct rebind {
            typedef typename _Base_type::rebind_alloc<_Tp> other;
        };
    };
template<> struct __alloc_traits<std::allocator<char>, char> : std::allocator_traits<allocator<char> > {
        typedef std::allocator<char> allocator_type;
        typedef std::allocator_traits<allocator<char> > _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type &reference;
        typedef const __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr> > >;
    public:
        template <typename _Ptr, typename ..._Args> static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type construct(std::allocator<char> &__a, _Ptr __p, _Args &&...__args);
        template <typename _Ptr> static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type destroy(std::allocator<char> &__a, _Ptr __p);
        static std::allocator<char> _S_select_on_copy(const std::allocator<char> &__a)         {
            return _Base_type::select_on_container_copy_construction(__a);
        }
        static void _S_on_swap(std::allocator<char> &__a, std::allocator<char> &__b);
        static constexpr bool _S_propagate_on_copy_assign();
        static constexpr bool _S_propagate_on_move_assign();
        static constexpr bool _S_propagate_on_swap();
        static constexpr bool _S_always_equal();
        static constexpr bool _S_nothrow_move();
        template <typename _Tp> struct rebind
template<> struct rebind<char> {
            typedef typename _Base_type::rebind_alloc<char> other;
        };
    };
template<> struct __alloc_traits<std::allocator<wchar_t>, wchar_t> : std::allocator_traits<allocator<wchar_t> > {
        typedef std::allocator<wchar_t> allocator_type;
        typedef std::allocator_traits<allocator<wchar_t> > _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef __gnu_cxx::__alloc_traits<std::allocator<wchar_t>, wchar_t>::value_type &reference;
        typedef const __gnu_cxx::__alloc_traits<std::allocator<wchar_t>, wchar_t>::value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr> > >;
    public:
        template <typename _Ptr, typename ..._Args> static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type construct(std::allocator<wchar_t> &__a, _Ptr __p, _Args &&...__args);
        template <typename _Ptr> static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type destroy(std::allocator<wchar_t> &__a, _Ptr __p);
        static std::allocator<wchar_t> _S_select_on_copy(const std::allocator<wchar_t> &__a);
        static void _S_on_swap(std::allocator<wchar_t> &__a, std::allocator<wchar_t> &__b);
        static constexpr bool _S_propagate_on_copy_assign();
        static constexpr bool _S_propagate_on_move_assign();
        static constexpr bool _S_propagate_on_swap();
        static constexpr bool _S_always_equal();
        static constexpr bool _S_nothrow_move();
        template <typename _Tp> struct rebind
template<> struct rebind<wchar_t> {
            typedef typename _Base_type::rebind_alloc<wchar_t> other;
        };
    };
template<> struct __alloc_traits<std::allocator<char16_t>, char16_t> : std::allocator_traits<allocator<char16_t> > {
        typedef std::allocator<char16_t> allocator_type;
        typedef std::allocator_traits<allocator<char16_t> > _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef __gnu_cxx::__alloc_traits<std::allocator<char16_t>, char16_t>::value_type &reference;
        typedef const __gnu_cxx::__alloc_traits<std::allocator<char16_t>, char16_t>::value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr> > >;
    public:
        template <typename _Ptr, typename ..._Args> static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type construct(std::allocator<char16_t> &__a, _Ptr __p, _Args &&...__args);
        template <typename _Ptr> static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type destroy(std::allocator<char16_t> &__a, _Ptr __p);
        static std::allocator<char16_t> _S_select_on_copy(const std::allocator<char16_t> &__a);
        static void _S_on_swap(std::allocator<char16_t> &__a, std::allocator<char16_t> &__b);
        static constexpr bool _S_propagate_on_copy_assign();
        static constexpr bool _S_propagate_on_move_assign();
        static constexpr bool _S_propagate_on_swap();
        static constexpr bool _S_always_equal();
        static constexpr bool _S_nothrow_move();
        template <typename _Tp> struct rebind
template<> struct rebind<char16_t> {
            typedef typename _Base_type::rebind_alloc<char16_t> other;
        };
    };
template<> struct __alloc_traits<std::allocator<char32_t>, char32_t> : std::allocator_traits<allocator<char32_t> > {
        typedef std::allocator<char32_t> allocator_type;
        typedef std::allocator_traits<allocator<char32_t> > _Base_type;
        typedef typename _Base_type::value_type value_type;
        typedef typename _Base_type::pointer pointer;
        typedef typename _Base_type::const_pointer const_pointer;
        typedef typename _Base_type::size_type size_type;
        typedef typename _Base_type::difference_type difference_type;
        typedef __gnu_cxx::__alloc_traits<std::allocator<char32_t>, char32_t>::value_type &reference;
        typedef const __gnu_cxx::__alloc_traits<std::allocator<char32_t>, char32_t>::value_type &const_reference;
        using _Base_type::allocate;
        using _Base_type::deallocate;
        using _Base_type::construct;
        using _Base_type::destroy;
        using _Base_type::max_size;
    private:
        template <typename _Ptr> using __is_custom_pointer = std::__and_<std::is_same<pointer, _Ptr>, std::__not_<std::is_pointer<_Ptr> > >;
    public:
        template <typename _Ptr, typename ..._Args> static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type construct(std::allocator<char32_t> &__a, _Ptr __p, _Args &&...__args);
        template <typename _Ptr> static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type destroy(std::allocator<char32_t> &__a, _Ptr __p);
        static std::allocator<char32_t> _S_select_on_copy(const std::allocator<char32_t> &__a);
        static void _S_on_swap(std::allocator<char32_t> &__a, std::allocator<char32_t> &__b);
        static constexpr bool _S_propagate_on_copy_assign();
        static constexpr bool _S_propagate_on_move_assign();
        static constexpr bool _S_propagate_on_swap();
        static constexpr bool _S_always_equal();
        static constexpr bool _S_nothrow_move();
        template <typename _Tp> struct rebind
template<> struct rebind<char32_t> {
            typedef typename _Base_type::rebind_alloc<char32_t> other;
        };
    };
}
namespace std {
    inline namespace __cxx11 {
        template <typename _CharT, typename _Traits = char_traits<_CharT>, typename _Alloc = allocator<_CharT>> class basic_string {
            typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef _Traits traits_type;
            typedef typename _Traits::char_type value_type;
            typedef std::__cxx11::basic_string::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<_CharT, _Traits, _Alloc> > iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<_CharT, _Traits, _Alloc> > const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::__cxx11::basic_string::size_type npos = static_cast<std::__cxx11::basic_string::size_type>(-1);
        protected:
            typedef std::__cxx11::basic_string::const_iterator __const_iterator;
        private:
            struct _Alloc_hider : std::__cxx11::basic_string::allocator_type {
                _Alloc_hider(std::__cxx11::basic_string::pointer __dat, const _Alloc &__a) : std::__cxx11::basic_string::allocator_type(__a), _M_p(__dat)                 {
                }
                _Alloc_hider(std::__cxx11::basic_string::pointer __dat, _Alloc &&__a = _Alloc()) : std::__cxx11::basic_string::allocator_type(std::move(__a)), _M_p(__dat)                 {
                }
                std::__cxx11::basic_string::pointer _M_p;
            };
            std::__cxx11::basic_string::_Alloc_hider _M_dataplus;
            std::__cxx11::basic_string::size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(_CharT)
            };
            union {
                _CharT _M_local_buf[_S_local_capacity + 1];
                std::__cxx11::basic_string::size_type _M_allocated_capacity;
            };
            void _M_data(std::__cxx11::basic_string::pointer __p)             {
                this->_M_dataplus._M_p = __p;
            }
            void _M_length(std::__cxx11::basic_string::size_type __length)             {
                this->_M_string_length = __length;
            }
            std::__cxx11::basic_string::pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }
            std::__cxx11::basic_string::pointer _M_local_data()             {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            std::__cxx11::basic_string::const_pointer _M_local_data() const             {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            void _M_capacity(std::__cxx11::basic_string::size_type __capacity)             {
                this->_M_allocated_capacity = __capacity;
            }
            void _M_set_length(std::__cxx11::basic_string::size_type __n)             {
                this->_M_length(__n);
                traits_type::assign(_M_data()[__n], _CharT());
            }
            bool _M_is_local() const             {
                return _M_data() == _M_local_data();
            }
            std::__cxx11::basic_string::pointer _M_create(std::__cxx11::basic_string::size_type &, std::__cxx11::basic_string::size_type);
            void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            void _M_destroy(std::__cxx11::basic_string::size_type __size) throw()             {
                _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1);
            }
            template <typename _InIterator> void _M_construct_aux(_InIterator __beg, _InIterator __end, std::__false_type)             {
                typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
                _M_construct(__beg, __end, _Tag());
            }
            template <typename _Integer> void _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)             {
                this->_M_construct_aux_2(static_cast<std::__cxx11::basic_string::size_type>(__beg), __end);
            }
            void _M_construct_aux_2(std::__cxx11::basic_string::size_type __req, _CharT __c)             {
                _M_construct(__req, __c);
            }
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end)             {
                typedef typename std::__is_integer<_InIterator>::__type _Integral;
                _M_construct_aux(__beg, __end, _Integral());
            }
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            void _M_construct(std::__cxx11::basic_string::size_type __req, _CharT __c);
            std::__cxx11::basic_string::allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }
            const std::__cxx11::basic_string::allocator_type &_M_get_allocator() const             {
                return this->_M_dataplus;
            }
        private:
            std::__cxx11::basic_string::size_type _M_check(std::__cxx11::basic_string::size_type __pos, const char *__s) const             {
                if (__pos > this->size())
                    __throw_out_of_range_fmt(("%s: __pos (which is %zu) > this->size() (which is %zu)"), __s, __pos, this->size());
                return __pos;
            }
            void _M_check_length(std::__cxx11::basic_string::size_type __n1, std::__cxx11::basic_string::size_type __n2, const char *__s) const             {
                if (this->max_size() - (this->size() - __n1) < __n2)
                    __throw_length_error((__s));
            }
            std::__cxx11::basic_string::size_type _M_limit(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __off) const noexcept             {
                const bool __testoff = __off < this->size() - __pos;
                return __testoff ? __off : this->size() - __pos;
            }
            bool _M_disjunct(const _CharT *__s) const noexcept             {
                return (less<const _CharT *>()(__s, _M_data()) || less<const _CharT *>()(_M_data() + this->size(), __s));
            }
            static void _S_copy(_CharT *__d, const _CharT *__s, std::__cxx11::basic_string::size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static void _S_move(_CharT *__d, const _CharT *__s, std::__cxx11::basic_string::size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::move(__d, __s, __n);
            }
            static void _S_assign(_CharT *__d, std::__cxx11::basic_string::size_type __n, _CharT __c)             {
                if (__n == 1)
                    traits_type::assign(*__d, __c);
                else
                    traits_type::assign(__d, __n, __c);
            }
            template <class _Iterator> static void _S_copy_chars(_CharT *__p, _Iterator __k1, _Iterator __k2)             {
                for (; __k1 != __k2; ++__k1 , (void)++__p)
                    traits_type::assign(*__p, *__k1);
            }
            static void _S_copy_chars(_CharT *__p, std::__cxx11::basic_string::iterator __k1, std::__cxx11::basic_string::iterator __k2) noexcept             {
                _S_copy_chars(__p, __k1.base(), __k2.base());
            }
            static void _S_copy_chars(_CharT *__p, std::__cxx11::basic_string::const_iterator __k1, std::__cxx11::basic_string::const_iterator __k2) noexcept             {
                _S_copy_chars(__p, __k1.base(), __k2.base());
            }
            static void _S_copy_chars(_CharT *__p, _CharT *__k1, _CharT *__k2) noexcept             {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static void _S_copy_chars(_CharT *__p, const _CharT *__k1, const _CharT *__k2) noexcept             {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static int _S_compare(std::__cxx11::basic_string::size_type __n1, std::__cxx11::basic_string::size_type __n2) noexcept             {
                const std::__cxx11::basic_string::difference_type __d = std::__cxx11::basic_string::difference_type(__n1 - __n2);
                if (__d > __gnu_cxx::__numeric_traits<int>::__max)
                    return __gnu_cxx::__numeric_traits<int>::__max;
                else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
                    return __gnu_cxx::__numeric_traits<int>::__min;
                else
                    return int(__d);
            }
            void _M_assign(const basic_string<_CharT, _Traits, _Alloc> &);
            void _M_mutate(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __len1, const _CharT *__s, std::__cxx11::basic_string::size_type __len2);
            void _M_erase(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n);
        public:
            basic_string<_CharT, _Traits, _Alloc>() noexcept(is_nothrow_default_constructible<_Alloc>::valuebasic_string<_CharT, _Traits, _Alloc>() noexcept(is_nothrow_default_constructible<_Alloc>::value) : _M_dataplus(_M_local_data())             {
                this->_M_set_length(0);
            }
            explicit basic_string<_CharT, _Traits, _Alloc>(const _Alloc &__a) noexcept : _M_dataplus(_M_local_data(), __a)             {
                this->_M_set_length(0);
            }
            basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str) : _M_dataplus(_M_local_data(), _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))             {
                _M_construct(__str._M_data(), __str._M_data() + __str.length());
            }
            basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a)             {
                const _CharT *__start = __str._M_data() + __str._M_check(__pos, "basic_string::basic_string");
                _M_construct(__start, __start + __str._M_limit(__pos, npos));
            }
            basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) : _M_dataplus(_M_local_data())             {
                const _CharT *__start = __str._M_data() + __str._M_check(__pos, "basic_string::basic_string");
                _M_construct(__start, __start + __str._M_limit(__pos, __n));
            }
            basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n, const _Alloc &__a) : _M_dataplus(_M_local_data(), __a)             {
                const _CharT *__start = __str._M_data() + __str._M_check(__pos, "string::string");
                _M_construct(__start, __start + __str._M_limit(__pos, __n));
            }
            basic_string<_CharT, _Traits, _Alloc>(const _CharT *__s, std::__cxx11::basic_string::size_type __n, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a)             {
                _M_construct(__s, __s + __n);
            }
            basic_string<_CharT, _Traits, _Alloc>(const _CharT *__s, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a)             {
                _M_construct(__s, __s ? __s + traits_type::length(__s) : __s + npos);
            }
            basic_string<_CharT, _Traits, _Alloc>(std::__cxx11::basic_string::size_type __n, _CharT __c, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a)             {
                _M_construct(__n, __c);
            }
            basic_string<_CharT, _Traits, _Alloc>(basic_string<_CharT, _Traits, _Alloc> &&__str) noexcept : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))             {
                if (__str._M_is_local()) {
                    traits_type::copy(this->_M_local_buf, __str._M_local_buf, _S_local_capacity + 1);
                } else {
                    _M_data(__str._M_data());
                    this->_M_capacity(__str._M_allocated_capacity);
                }
                this->_M_length(__str.length());
                __str._M_data(__str._M_local_data());
                __str._M_set_length(0);
            }
            basic_string<_CharT, _Traits, _Alloc>(initializer_list<_CharT> __l, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a)             {
                _M_construct(__l.begin(), __l.end());
            }
            basic_string<_CharT, _Traits, _Alloc>(const basic_string<_CharT, _Traits, _Alloc> &__str, const _Alloc &__a) : _M_dataplus(_M_local_data(), __a)             {
                _M_construct(__str.begin(), __str.end());
            }
            basic_string<_CharT, _Traits, _Alloc>(basic_string<_CharT, _Traits, _Alloc> &&__str, const _Alloc &__a) noexcept(_Alloc_traits::_S_always_equal()basic_string<_CharT, _Traits, _Alloc>(basic_string<_CharT, _Traits, _Alloc> &&__str, const _Alloc &__a) noexcept(_Alloc_traits::_S_always_equal()) : _M_dataplus(_M_local_data(), __a)             {
                if (__str._M_is_local()) {
                    traits_type::copy(this->_M_local_buf, __str._M_local_buf, _S_local_capacity + 1);
                    this->_M_length(__str.length());
                    __str._M_set_length(0);
                } else if (_Alloc_traits::_S_always_equal() || __str.get_allocator() == __a) {
                    _M_data(__str._M_data());
                    this->_M_length(__str.length());
                    this->_M_capacity(__str._M_allocated_capacity);
                    __str._M_data(__str._M_local_buf);
                    __str._M_set_length(0);
                } else
                    _M_construct(__str.begin(), __str.end());
            }
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string<_CharT, _Traits, _Alloc>(_InputIterator __beg, _InputIterator __end, const _Alloc &__a = _Alloc()) : _M_dataplus(_M_local_data(), __a)             {
                _M_construct(__beg, __end);
            }
            ~basic_string<_CharT, _Traits, _Alloc>()             {
                this->_M_dispose();
            }
            basic_string<_CharT, _Traits, _Alloc> &operator=(const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                if (_Alloc_traits::_S_propagate_on_copy_assign()) {
                    if (!_Alloc_traits::_S_always_equal() && !this->_M_is_local() && _M_get_allocator() != __str._M_get_allocator()) {
                        if (__str.size() <= _S_local_capacity) {
                            this->_M_destroy(this->_M_allocated_capacity);
                            _M_data(_M_local_data());
                            this->_M_set_length(0);
                        } else {
                            const auto __len = __str.size();
                            auto __alloc = __str._M_get_allocator();
                            auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1);
                            this->_M_destroy(this->_M_allocated_capacity);
                            _M_data(__ptr);
                            this->_M_capacity(__len);
                            this->_M_set_length(__len);
                        }
                    }
                    std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
                }
                return this->assign(__str);
            }
            basic_string<_CharT, _Traits, _Alloc> &operator=(const _CharT *__s)             {
                return this->assign(__s);
            }
            basic_string<_CharT, _Traits, _Alloc> &operator=(_CharT __c)             {
                this->assign(1, __c);
                return *this;
            }
            basic_string<_CharT, _Traits, _Alloc> &operator=(basic_string<_CharT, _Traits, _Alloc> &&__str) noexcept(_Alloc_traits::_S_nothrow_move()operator=(basic_string<_CharT, _Traits, _Alloc> &&__str) noexcept(_Alloc_traits::_S_nothrow_move())             {
                if (!this->_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign() && !_Alloc_traits::_S_always_equal() && _M_get_allocator() != __str._M_get_allocator()) {
                    this->_M_destroy(this->_M_allocated_capacity);
                    _M_data(_M_local_data());
                    this->_M_set_length(0);
                }
                std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());
                if (__str._M_is_local()) {
                    if (__str.size())
                        this->_S_copy(_M_data(), __str._M_data(), __str.size());
                    this->_M_set_length(__str.size());
                } else if (_Alloc_traits::_S_propagate_on_move_assign() || _Alloc_traits::_S_always_equal() || _M_get_allocator() == __str._M_get_allocator()) {
                    std::__cxx11::basic_string::pointer __data = nullptr;
                    std::__cxx11::basic_string::size_type __capacity;
                    if (!this->_M_is_local()) {
                        if (_Alloc_traits::_S_always_equal()) {
                            __data = _M_data();
                            __capacity = this->_M_allocated_capacity;
                        } else
                            this->_M_destroy(this->_M_allocated_capacity);
                    }
                    _M_data(__str._M_data());
                    this->_M_length(__str.length());
                    this->_M_capacity(__str._M_allocated_capacity);
                    if (__data) {
                        __str._M_data(__data);
                        __str._M_capacity(__capacity);
                    } else
                        __str._M_data(__str._M_local_buf);
                } else
                    assign(__str);
                __str.clear();
                return *this;
            }
            basic_string<_CharT, _Traits, _Alloc> &operator=(initializer_list<_CharT> __l)             {
                this->assign(__l.begin(), __l.size());
                return *this;
            }
            std::__cxx11::basic_string::iterator begin() noexcept             {
                return std::__cxx11::basic_string::iterator(_M_data());
            }
            std::__cxx11::basic_string::const_iterator begin() const noexcept             {
                return std::__cxx11::basic_string::const_iterator(_M_data());
            }
            std::__cxx11::basic_string::iterator end() noexcept             {
                return std::__cxx11::basic_string::iterator(_M_data() + this->size());
            }
            std::__cxx11::basic_string::const_iterator end() const noexcept             {
                return std::__cxx11::basic_string::const_iterator(_M_data() + this->size());
            }
            std::__cxx11::basic_string::reverse_iterator rbegin() noexcept             {
                return std::__cxx11::basic_string::reverse_iterator(this->end());
            }
            std::__cxx11::basic_string::const_reverse_iterator rbegin() const noexcept             {
                return std::__cxx11::basic_string::const_reverse_iterator(this->end());
            }
            std::__cxx11::basic_string::reverse_iterator rend() noexcept             {
                return std::__cxx11::basic_string::reverse_iterator(this->begin());
            }
            std::__cxx11::basic_string::const_reverse_iterator rend() const noexcept             {
                return std::__cxx11::basic_string::const_reverse_iterator(this->begin());
            }
            std::__cxx11::basic_string::const_iterator cbegin() const noexcept             {
                return std::__cxx11::basic_string::const_iterator(this->_M_data());
            }
            std::__cxx11::basic_string::const_iterator cend() const noexcept             {
                return std::__cxx11::basic_string::const_iterator(this->_M_data() + this->size());
            }
            std::__cxx11::basic_string::const_reverse_iterator crbegin() const noexcept             {
                return std::__cxx11::basic_string::const_reverse_iterator(this->end());
            }
            std::__cxx11::basic_string::const_reverse_iterator crend() const noexcept             {
                return std::__cxx11::basic_string::const_reverse_iterator(this->begin());
            }
        public:
            std::__cxx11::basic_string::size_type size() const noexcept             {
                return this->_M_string_length;
            }
            std::__cxx11::basic_string::size_type length() const noexcept             {
                return this->_M_string_length;
            }
            std::__cxx11::basic_string::size_type max_size() const noexcept             {
                return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2;
            }
            void resize(std::__cxx11::basic_string::size_type __n, _CharT __c);
            void resize(std::__cxx11::basic_string::size_type __n)             {
                this->resize(__n, _CharT());
            }
            void shrink_to_fit() noexcept             {
                if (this->capacity() > this->size()) {
                    try {
                        this->reserve(0);
                    } catch (...) {
                    }
                }
            }
            std::__cxx11::basic_string::size_type capacity() const noexcept             {
                return this->_M_is_local() ? std::__cxx11::basic_string::size_type(_S_local_capacity) : this->_M_allocated_capacity;
            }
            void reserve(std::__cxx11::basic_string::size_type __res_arg = 0);
            void clear() noexcept             {
                this->_M_set_length(0);
            }
            bool empty() const noexcept             {
                return this->size() == 0;
            }
            std::__cxx11::basic_string::const_reference operator[](std::__cxx11::basic_string::size_type __pos) const noexcept             {
                ;
                return _M_data()[__pos];
            }
            std::__cxx11::basic_string::reference operator[](std::__cxx11::basic_string::size_type __pos)             {
                ;
                ;
                return _M_data()[__pos];
            }
            std::__cxx11::basic_string::const_reference at(std::__cxx11::basic_string::size_type __n) const             {
                if (__n >= this->size())
                    __throw_out_of_range_fmt(("basic_string::at: __n (which is %zu) >= this->size() (which is %zu)"), __n, this->size());
                return _M_data()[__n];
            }
            std::__cxx11::basic_string::reference at(std::__cxx11::basic_string::size_type __n)             {
                if (__n >= this->size())
                    __throw_out_of_range_fmt(("basic_string::at: __n (which is %zu) >= this->size() (which is %zu)"), __n, this->size());
                return _M_data()[__n];
            }
            std::__cxx11::basic_string::reference front() noexcept             {
                ;
                return operator[](0);
            }
            std::__cxx11::basic_string::const_reference front() const noexcept             {
                ;
                return operator[](0);
            }
            std::__cxx11::basic_string::reference back() noexcept             {
                ;
                return operator[](this->size() - 1);
            }
            std::__cxx11::basic_string::const_reference back() const noexcept             {
                ;
                return operator[](this->size() - 1);
            }
            basic_string<_CharT, _Traits, _Alloc> &operator+=(const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                return this->append(__str);
            }
            basic_string<_CharT, _Traits, _Alloc> &operator+=(const _CharT *__s)             {
                return this->append(__s);
            }
            basic_string<_CharT, _Traits, _Alloc> &operator+=(_CharT __c)             {
                this->push_back(__c);
                return *this;
            }
            basic_string<_CharT, _Traits, _Alloc> &operator+=(initializer_list<_CharT> __l)             {
                return this->append(__l.begin(), __l.size());
            }
            basic_string<_CharT, _Traits, _Alloc> &append(const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                return this->_M_append(__str._M_data(), __str.size());
            }
            basic_string<_CharT, _Traits, _Alloc> &append(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n = npos)             {
                return this->_M_append(__str._M_data() + __str._M_check(__pos, "basic_string::append"), __str._M_limit(__pos, __n));
            }
            basic_string<_CharT, _Traits, _Alloc> &append(const _CharT *__s, std::__cxx11::basic_string::size_type __n)             {
                ;
                this->_M_check_length(std::__cxx11::basic_string::size_type(0), __n, "basic_string::append");
                return this->_M_append(__s, __n);
            }
            basic_string<_CharT, _Traits, _Alloc> &append(const _CharT *__s)             {
                ;
                const std::__cxx11::basic_string::size_type __n = traits_type::length(__s);
                this->_M_check_length(std::__cxx11::basic_string::size_type(0), __n, "basic_string::append");
                return this->_M_append(__s, __n);
            }
            basic_string<_CharT, _Traits, _Alloc> &append(std::__cxx11::basic_string::size_type __n, _CharT __c)             {
                return this->_M_replace_aux(this->size(), std::__cxx11::basic_string::size_type(0), __n, __c);
            }
            basic_string<_CharT, _Traits, _Alloc> &append(initializer_list<_CharT> __l)             {
                return this->append(__l.begin(), __l.size());
            }
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string<_CharT, _Traits, _Alloc> &append(_InputIterator __first, _InputIterator __last)             {
                return this->replace(end(), end(), __first, __last);
            }
            void push_back(_CharT __c)             {
                const std::__cxx11::basic_string::size_type __size = this->size();
                if (__size + 1 > this->capacity())
                    this->_M_mutate(__size, std::__cxx11::basic_string::size_type(0), 0, std::__cxx11::basic_string::size_type(1));
                traits_type::assign(this->_M_data()[__size], __c);
                this->_M_set_length(__size + 1);
            }
            basic_string<_CharT, _Traits, _Alloc> &assign(const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                this->_M_assign(__str);
                return *this;
            }
            basic_string<_CharT, _Traits, _Alloc> &assign(basic_string<_CharT, _Traits, _Alloc> &&__str) noexcept(_Alloc_traits::_S_nothrow_move()assign(basic_string<_CharT, _Traits, _Alloc> &&__str) noexcept(_Alloc_traits::_S_nothrow_move())             {
                return *this = std::move(__str);
            }
            basic_string<_CharT, _Traits, _Alloc> &assign(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n = npos)             {
                return this->_M_replace(std::__cxx11::basic_string::size_type(0), this->size(), __str._M_data() + __str._M_check(__pos, "basic_string::assign"), __str._M_limit(__pos, __n));
            }
            basic_string<_CharT, _Traits, _Alloc> &assign(const _CharT *__s, std::__cxx11::basic_string::size_type __n)             {
                ;
                return this->_M_replace(std::__cxx11::basic_string::size_type(0), this->size(), __s, __n);
            }
            basic_string<_CharT, _Traits, _Alloc> &assign(const _CharT *__s)             {
                ;
                return this->_M_replace(std::__cxx11::basic_string::size_type(0), this->size(), __s, traits_type::length(__s));
            }
            basic_string<_CharT, _Traits, _Alloc> &assign(std::__cxx11::basic_string::size_type __n, _CharT __c)             {
                return this->_M_replace_aux(std::__cxx11::basic_string::size_type(0), this->size(), __n, __c);
            }
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string<_CharT, _Traits, _Alloc> &assign(_InputIterator __first, _InputIterator __last)             {
                return this->replace(begin(), end(), __first, __last);
            }
            basic_string<_CharT, _Traits, _Alloc> &assign(initializer_list<_CharT> __l)             {
                return this->assign(__l.begin(), __l.size());
            }
            std::__cxx11::basic_string::iterator insert(std::__cxx11::basic_string::const_iterator __p, std::__cxx11::basic_string::size_type __n, _CharT __c)             {
                ;
                const std::__cxx11::basic_string::size_type __pos = __p - begin();
                this->replace(__p, __p, __n, __c);
                return std::__cxx11::basic_string::iterator(this->_M_data() + __pos);
            }
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string::iterator insert(std::__cxx11::basic_string::const_iterator __p, _InputIterator __beg, _InputIterator __end)             {
                ;
                const std::__cxx11::basic_string::size_type __pos = __p - begin();
                this->replace(__p, __p, __beg, __end);
                return std::__cxx11::basic_string::iterator(this->_M_data() + __pos);
            }
            std::__cxx11::basic_string::iterator insert(std::__cxx11::basic_string::const_iterator __p, initializer_list<_CharT> __l)             {
                return this->insert(__p, __l.begin(), __l.end());
            }
            basic_string<_CharT, _Traits, _Alloc> &insert(std::__cxx11::basic_string::size_type __pos1, const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                return this->replace(__pos1, std::__cxx11::basic_string::size_type(0), __str._M_data(), __str.size());
            }
            basic_string<_CharT, _Traits, _Alloc> &insert(std::__cxx11::basic_string::size_type __pos1, const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos2, std::__cxx11::basic_string::size_type __n = npos)             {
                return this->replace(__pos1, std::__cxx11::basic_string::size_type(0), __str._M_data() + __str._M_check(__pos2, "basic_string::insert"), __str._M_limit(__pos2, __n));
            }
            basic_string<_CharT, _Traits, _Alloc> &insert(std::__cxx11::basic_string::size_type __pos, const _CharT *__s, std::__cxx11::basic_string::size_type __n)             {
                return this->replace(__pos, std::__cxx11::basic_string::size_type(0), __s, __n);
            }
            basic_string<_CharT, _Traits, _Alloc> &insert(std::__cxx11::basic_string::size_type __pos, const _CharT *__s)             {
                ;
                return this->replace(__pos, std::__cxx11::basic_string::size_type(0), __s, traits_type::length(__s));
            }
            basic_string<_CharT, _Traits, _Alloc> &insert(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n, _CharT __c)             {
                return this->_M_replace_aux(this->_M_check(__pos, "basic_string::insert"), std::__cxx11::basic_string::size_type(0), __n, __c);
            }
            std::__cxx11::basic_string::iterator insert(std::__cxx11::basic_string::__const_iterator __p, _CharT __c)             {
                ;
                const std::__cxx11::basic_string::size_type __pos = __p - begin();
                this->_M_replace_aux(__pos, std::__cxx11::basic_string::size_type(0), std::__cxx11::basic_string::size_type(1), __c);
                return std::__cxx11::basic_string::iterator(_M_data() + __pos);
            }
            basic_string<_CharT, _Traits, _Alloc> &erase(std::__cxx11::basic_string::size_type __pos = 0, std::__cxx11::basic_string::size_type __n = npos)             {
                this->_M_check(__pos, "basic_string::erase");
                if (__n == npos)
                    this->_M_set_length(__pos);
                else if (__n != 0)
                    this->_M_erase(__pos, this->_M_limit(__pos, __n));
                return *this;
            }
            std::__cxx11::basic_string::iterator erase(std::__cxx11::basic_string::__const_iterator __position)             {
                ;
                const std::__cxx11::basic_string::size_type __pos = __position - begin();
                this->_M_erase(__pos, std::__cxx11::basic_string::size_type(1));
                return std::__cxx11::basic_string::iterator(_M_data() + __pos);
            }
            std::__cxx11::basic_string::iterator erase(std::__cxx11::basic_string::__const_iterator __first, std::__cxx11::basic_string::__const_iterator __last)             {
                ;
                const std::__cxx11::basic_string::size_type __pos = __first - begin();
                if (__last == end())
                    this->_M_set_length(__pos);
                else
                    this->_M_erase(__pos, __last - __first);
                return std::__cxx11::basic_string::iterator(this->_M_data() + __pos);
            }
            void pop_back() noexcept             {
                ;
                this->_M_erase(this->size() - 1, 1);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n, const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                return this->replace(__pos, __n, __str._M_data(), __str.size());
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::size_type __pos1, std::__cxx11::basic_string::size_type __n1, const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos2, std::__cxx11::basic_string::size_type __n2 = npos)             {
                return this->replace(__pos1, __n1, __str._M_data() + __str._M_check(__pos2, "basic_string::replace"), __str._M_limit(__pos2, __n2));
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n1, const _CharT *__s, std::__cxx11::basic_string::size_type __n2)             {
                ;
                return this->_M_replace(this->_M_check(__pos, "basic_string::replace"), this->_M_limit(__pos, __n1), __s, __n2);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n1, const _CharT *__s)             {
                ;
                return this->replace(__pos, __n1, __s, traits_type::length(__s));
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n1, std::__cxx11::basic_string::size_type __n2, _CharT __c)             {
                return this->_M_replace_aux(this->_M_check(__pos, "basic_string::replace"), this->_M_limit(__pos, __n1), __n2, __c);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, const basic_string<_CharT, _Traits, _Alloc> &__str)             {
                return this->replace(__i1, __i2, __str._M_data(), __str.size());
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, const _CharT *__s, std::__cxx11::basic_string::size_type __n)             {
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, const _CharT *__s)             {
                ;
                return this->replace(__i1, __i2, __s, traits_type::length(__s));
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, std::__cxx11::basic_string::size_type __n, _CharT __c)             {
                ;
                return this->_M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
            }
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::const_iterator __i1, std::__cxx11::basic_string::const_iterator __i2, _InputIterator __k1, _InputIterator __k2)             {
                ;
                ;
                return this->_M_replace_dispatch(__i1, __i2, __k1, __k2, std::__false_type());
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, _CharT *__k1, _CharT *__k2)             {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1, __k2 - __k1);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, const _CharT *__k1, const _CharT *__k2)             {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1, __k2 - __k1);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, std::__cxx11::basic_string::iterator __k1, std::__cxx11::basic_string::iterator __k2)             {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1.base(), __k2 - __k1);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::__const_iterator __i1, std::__cxx11::basic_string::__const_iterator __i2, std::__cxx11::basic_string::const_iterator __k1, std::__cxx11::basic_string::const_iterator __k2)             {
                ;
                ;
                return this->replace(__i1 - begin(), __i2 - __i1, __k1.base(), __k2 - __k1);
            }
            basic_string<_CharT, _Traits, _Alloc> &replace(std::__cxx11::basic_string::const_iterator __i1, std::__cxx11::basic_string::const_iterator __i2, initializer_list<_CharT> __l)             {
                return this->replace(__i1, __i2, __l.begin(), __l.size());
            }
        private:
            template <class _Integer> basic_string<_CharT, _Traits, _Alloc> &_M_replace_dispatch(std::__cxx11::basic_string::const_iterator __i1, std::__cxx11::basic_string::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type)             {
                return this->_M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val);
            }
            template <class _InputIterator> basic_string<_CharT, _Traits, _Alloc> &_M_replace_dispatch(std::__cxx11::basic_string::const_iterator __i1, std::__cxx11::basic_string::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            basic_string<_CharT, _Traits, _Alloc> &_M_replace_aux(std::__cxx11::basic_string::size_type __pos1, std::__cxx11::basic_string::size_type __n1, std::__cxx11::basic_string::size_type __n2, _CharT __c);
            basic_string<_CharT, _Traits, _Alloc> &_M_replace(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __len1, const _CharT *__s, const std::__cxx11::basic_string::size_type __len2);
            basic_string<_CharT, _Traits, _Alloc> &_M_append(const _CharT *__s, std::__cxx11::basic_string::size_type __n);
        public:
            std::__cxx11::basic_string::size_type copy(_CharT *__s, std::__cxx11::basic_string::size_type __n, std::__cxx11::basic_string::size_type __pos = 0) const;
            void swap(basic_string<_CharT, _Traits, _Alloc> &__s) noexcept;
            const _CharT *c_str() const noexcept             {
                return _M_data();
            }
            const _CharT *data() const noexcept             {
                return _M_data();
            }
            std::__cxx11::basic_string::allocator_type get_allocator() const noexcept             {
                return _M_get_allocator();
            }
            std::__cxx11::basic_string::size_type find(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept;
            std::__cxx11::basic_string::size_type find(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos = 0) const noexcept             {
                return this->find(__str.data(), __pos, __str.size());
            }
            std::__cxx11::basic_string::size_type find(const _CharT *__s, std::__cxx11::basic_string::size_type __pos = 0) const noexcept             {
                ;
                return this->find(__s, __pos, traits_type::length(__s));
            }
            std::__cxx11::basic_string::size_type find(_CharT __c, std::__cxx11::basic_string::size_type __pos = 0) const noexcept;
            std::__cxx11::basic_string::size_type rfind(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos = npos) const noexcept             {
                return this->rfind(__str.data(), __pos, __str.size());
            }
            std::__cxx11::basic_string::size_type rfind(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept;
            std::__cxx11::basic_string::size_type rfind(const _CharT *__s, std::__cxx11::basic_string::size_type __pos = npos) const             {
                ;
                return this->rfind(__s, __pos, traits_type::length(__s));
            }
            std::__cxx11::basic_string::size_type rfind(_CharT __c, std::__cxx11::basic_string::size_type __pos = npos) const noexcept;
            std::__cxx11::basic_string::size_type find_first_of(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos = 0) const noexcept             {
                return this->find_first_of(__str.data(), __pos, __str.size());
            }
            std::__cxx11::basic_string::size_type find_first_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept;
            std::__cxx11::basic_string::size_type find_first_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos = 0) const noexcept             {
                ;
                return this->find_first_of(__s, __pos, traits_type::length(__s));
            }
            std::__cxx11::basic_string::size_type find_first_of(_CharT __c, std::__cxx11::basic_string::size_type __pos = 0) const noexcept             {
                return this->find(__c, __pos);
            }
            std::__cxx11::basic_string::size_type find_last_of(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos = npos) const noexcept             {
                return this->find_last_of(__str.data(), __pos, __str.size());
            }
            std::__cxx11::basic_string::size_type find_last_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept;
            std::__cxx11::basic_string::size_type find_last_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos = npos) const noexcept             {
                ;
                return this->find_last_of(__s, __pos, traits_type::length(__s));
            }
            std::__cxx11::basic_string::size_type find_last_of(_CharT __c, std::__cxx11::basic_string::size_type __pos = npos) const noexcept             {
                return this->rfind(__c, __pos);
            }
            std::__cxx11::basic_string::size_type find_first_not_of(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos = 0) const noexcept             {
                return this->find_first_not_of(__str.data(), __pos, __str.size());
            }
            std::__cxx11::basic_string::size_type find_first_not_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept;
            std::__cxx11::basic_string::size_type find_first_not_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos = 0) const noexcept             {
                ;
                return this->find_first_not_of(__s, __pos, traits_type::length(__s));
            }
            std::__cxx11::basic_string::size_type find_first_not_of(_CharT __c, std::__cxx11::basic_string::size_type __pos = 0) const noexcept;
            std::__cxx11::basic_string::size_type find_last_not_of(const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos = npos) const noexcept             {
                return this->find_last_not_of(__str.data(), __pos, __str.size());
            }
            std::__cxx11::basic_string::size_type find_last_not_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept;
            std::__cxx11::basic_string::size_type find_last_not_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos = npos) const noexcept             {
                ;
                return this->find_last_not_of(__s, __pos, traits_type::length(__s));
            }
            std::__cxx11::basic_string::size_type find_last_not_of(_CharT __c, std::__cxx11::basic_string::size_type __pos = npos) const noexcept;
            basic_string<_CharT, _Traits, _Alloc> substr(std::__cxx11::basic_string::size_type __pos = 0, std::__cxx11::basic_string::size_type __n = npos) const             {
                return basic_string<_CharT, _Traits, _Alloc>(*this, this->_M_check(__pos, "basic_string::substr"), __n);
            }
            int compare(const basic_string<_CharT, _Traits, _Alloc> &__str) const             {
                const std::__cxx11::basic_string::size_type __size = this->size();
                const std::__cxx11::basic_string::size_type __osize = __str.size();
                const std::__cxx11::basic_string::size_type __len = std::min(__size, __osize);
                int __r = traits_type::compare(_M_data(), __str.data(), __len);
                if (!__r)
                    __r = _S_compare(__size, __osize);
                return __r;
            }
            int compare(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n, const basic_string<_CharT, _Traits, _Alloc> &__str) const;
            int compare(std::__cxx11::basic_string::size_type __pos1, std::__cxx11::basic_string::size_type __n1, const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos2, std::__cxx11::basic_string::size_type __n2 = npos) const;
            int compare(const _CharT *__s) const noexcept;
            int compare(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n1, const _CharT *__s) const;
            int compare(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n1, const _CharT *__s, std::__cxx11::basic_string::size_type __n2) const;
            friend template <typename, typename, typename> class basic_stringbuf;
        };
template<> class basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char16_t> >::rebind<char16_t>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<char16_t> traits_type;
            typedef typename char_traits<char16_t>::char_type value_type;
            typedef std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> > > iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> > > const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type npos = static_cast<std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type>(-1);
        protected:
            typedef std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __const_iterator;
        private:
            struct _Alloc_hider : std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::allocator_type {
                std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::pointer _M_p;
            };
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::_Alloc_hider _M_dataplus;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(char16_t)
            };
            union {
                char16_t _M_local_buf[8];
                std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type _M_allocated_capacity;
            };
            void _M_data(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::pointer __p)             {
                this->_M_dataplus._M_p = __p;
            }
            void _M_length(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __length)             {
                this->_M_string_length = __length;
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::pointer _M_local_data()             {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_pointer _M_local_data() const             {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            void _M_capacity(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __capacity)             {
                this->_M_allocated_capacity = __capacity;
            }
            void _M_set_length(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n)             {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char16_t());
            }
            bool _M_is_local() const             {
                return this->_M_data() == this->_M_local_data();
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::pointer basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >::_M_create(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type &__capacity, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __old_capacity)             {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _Alloc_traits::allocate(this->_M_get_allocator(), __capacity + 1);
            }
            void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            void _M_destroy(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __size) throw()             {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> void _M_construct_aux(_InIterator __beg, _InIterator __end, std::__false_type);
            template<> void _M_construct_aux<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::__false_type)             {
                typedef typename iterator_traits<const char16_t *>::iterator_category _Tag;
                this->_M_construct(__beg, __end, _Tag());
            }
;
            template <typename _Integer> void _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type);
            void _M_construct_aux_2(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __req, char16_t __c);
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end);
            template<> void _M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end)             {
                typedef typename std::__is_integer<const char16_t *>::__type _Integral;
                this->_M_construct_aux(__beg, __end, _Integral());
            }
;
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> void _M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> void basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >::_M_construct<const char16_t *>(const char16_t *__beg, const char16_t *__end, std::forward_iterator_tag)             {
                if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                    std::__throw_logic_error(("basic_string::_M_construct null not valid"));
                std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __dnew = static_cast<std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type>(std::distance(__beg, __end));
                if (__dnew > std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type(0)));
                    this->_M_capacity(__dnew);
                }
                try {
                    this->_S_copy_chars(this->_M_data(), __beg, __end);
                } catch (...) {
                    this->_M_dispose();
                    throw;
                }
                this->_M_set_length(__dnew);
            }
;
            void _M_construct(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __req, char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }
            const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::allocator_type &_M_get_allocator() const             {
                return this->_M_dataplus;
            }
        private:
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type _M_check(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, const char *__s) const;
            void _M_check_length(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n2, const char *__s) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type _M_limit(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __off) const noexcept;
            bool _M_disjunct(const char16_t *__s) const noexcept;
            static void _S_copy(char16_t *__d, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static void _S_move(char16_t *__d, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            static void _S_assign(char16_t *__d, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, char16_t __c);
            template <class _Iterator> static void _S_copy_chars(char16_t *__p, _Iterator __k1, _Iterator __k2);
            template<> static void _S_copy_chars<const char16_t *>(char16_t *__p, const char16_t *__k1, const char16_t *__k2);
            static void _S_copy_chars(char16_t *__p, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator __k2) noexcept;
            static void _S_copy_chars(char16_t *__p, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __k2) noexcept;
            static void _S_copy_chars(char16_t *__p, char16_t *__k1, char16_t *__k2) noexcept;
            static void _S_copy_chars(char16_t *__p, const char16_t *__k1, const char16_t *__k2) noexcept             {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static int _S_compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n2) noexcept;
            void _M_assign(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &);
            void _M_mutate(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __len1, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __len2);
            void _M_erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
        public:
            basic_string();
            explicit basic_string(const std::allocator<char16_t> &__a) noexcept;
            basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str);
            basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, const std::allocator<char16_t> &__a);
            basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, const std::allocator<char16_t> &__a);
            basic_string(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, const std::allocator<char16_t> &__a = std::allocator<char16_t>()) : _M_dataplus(this->_M_local_data(), __a)             {
                this->_M_construct(__s, __s + __n);
            }
            basic_string(const char16_t *__s, const std::allocator<char16_t> &__a);
            basic_string(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, char16_t __c, const std::allocator<char16_t> &__a);
            basic_string(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &&__str) noexcept : _M_dataplus(this->_M_local_data(), std::move(__str._M_get_allocator()))             {
                if (__str._M_is_local()) {
                    traits_type::copy(this->_M_local_buf, __str._M_local_buf, _S_local_capacity + 1);
                } else {
                    this->_M_data(__str._M_data());
                    this->_M_capacity(__str._M_allocated_capacity);
                }
                this->_M_length(__str.length());
                __str._M_data(__str._M_local_data());
                __str._M_set_length(0);
            }
            basic_string(initializer_list<char16_t> __l, const std::allocator<char16_t> &__a);
            basic_string(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, const std::allocator<char16_t> &__a);
            basic_string(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &&__str, const std::allocator<char16_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char16_t> &__a);
            ~basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >() noexcept             {
                this->_M_dispose();
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &operator=(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &operator=(const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &operator=(char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &operator=(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &&__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &operator=(initializer_list<char16_t> __l);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator begin() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator begin() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator end() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator end() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::reverse_iterator rbegin() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_reverse_iterator rbegin() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::reverse_iterator rend() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_reverse_iterator rend() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator cbegin() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator cend() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_reverse_iterator crbegin() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_reverse_iterator crend() const noexcept;
        public:
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type size() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type length() const noexcept             {
                return this->_M_string_length;
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type max_size() const noexcept             {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            void resize(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, char16_t __c);
            void resize(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            void shrink_to_fit() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type capacity() const noexcept;
            void reserve(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __res_arg);
            void clear() noexcept;
            bool empty() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_reference operator[](std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::reference operator[](std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_reference at(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::reference at(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::reference front() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_reference front() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::reference back() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_reference back() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &operator+=(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &operator+=(const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &operator+=(char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &operator+=(initializer_list<char16_t> __l);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &append(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &append(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &append(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &append(const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &append(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &append(initializer_list<char16_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &append(_InputIterator __first, _InputIterator __last);
            void push_back(char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &assign(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &assign(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &&__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &assign(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &assign(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &assign(const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &assign(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &assign(_InputIterator __first, _InputIterator __last);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &assign(initializer_list<char16_t> __l);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __p, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __p, _InputIterator __beg, _InputIterator __end);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __p, initializer_list<char16_t> __l);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator insert(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __p, char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __position);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator erase(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __first, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __last);
            void pop_back() noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n1, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n1, const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n2, char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i2, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i2, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i2, const char16_t *__s);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, char16_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i2, char16_t *__k1, char16_t *__k2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i2, const char16_t *__k1, const char16_t *__k2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::iterator __k2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::__const_iterator __i2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __k1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __k2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __i2, initializer_list<char16_t> __l);
        private:
            template <class _Integer> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &_M_replace_dispatch(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &_M_replace_dispatch(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __i1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &_M_replace_aux(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n2, char16_t __c);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &_M_replace(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __len1, const char16_t *__s, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __len2);
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &_M_append(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n);
        public:
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type copy(char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const;
            void swap(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__s) noexcept;
            const char16_t *c_str() const noexcept;
            const char16_t *data() const noexcept             {
                return this->_M_data();
            }
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::allocator_type get_allocator() const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type rfind(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type rfind(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type rfind(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type rfind(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_first_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_first_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_first_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_first_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_last_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_last_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_last_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_last_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_first_not_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_first_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_first_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_first_not_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_last_not_of(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_last_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_last_not_of(const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type find_last_not_of(char16_t __c, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > substr(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n) const;
            int compare(const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str) const;
            int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str) const;
            int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos1, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n1, const std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > &__str, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos2, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n2) const;
            int compare(const char16_t *__s) const noexcept;
            int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n1, const char16_t *__s) const;
            int compare(std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __pos, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n1, const char16_t *__s, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >::size_type __n2) const;
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        };
template<> class basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t>> {
            typedef typename __gnu_cxx::__alloc_traits<allocator<char32_t> >::rebind<char32_t>::other _Char_alloc_type;
            typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
        public:
            typedef std::char_traits<char32_t> traits_type;
            typedef typename char_traits<char32_t>::char_type value_type;
            typedef std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::_Char_alloc_type allocator_type;
            typedef typename _Alloc_traits::size_type size_type;
            typedef typename _Alloc_traits::difference_type difference_type;
            typedef typename _Alloc_traits::reference reference;
            typedef typename _Alloc_traits::const_reference const_reference;
            typedef typename _Alloc_traits::pointer pointer;
            typedef typename _Alloc_traits::const_pointer const_pointer;
            typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> > > iterator;
            typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> > > const_iterator;
            typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
            typedef std::reverse_iterator<iterator> reverse_iterator;
            static const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type npos = static_cast<std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type>(-1);
        protected:
            typedef std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __const_iterator;
        private:
            struct _Alloc_hider : std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::allocator_type {
                std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::pointer _M_p;
            };
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::_Alloc_hider _M_dataplus;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type _M_string_length;
            enum  {
                _S_local_capacity = 15 / sizeof(char32_t)
            };
            union {
                char32_t _M_local_buf[4];
                std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type _M_allocated_capacity;
            };
            void _M_data(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::pointer __p)             {
                this->_M_dataplus._M_p = __p;
            }
            void _M_length(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __length)             {
                this->_M_string_length = __length;
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::pointer _M_data() const             {
                return this->_M_dataplus._M_p;
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::pointer _M_local_data()             {
                return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_pointer _M_local_data() const             {
                return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
            }
            void _M_capacity(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __capacity)             {
                this->_M_allocated_capacity = __capacity;
            }
            void _M_set_length(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n)             {
                this->_M_length(__n);
                traits_type::assign(this->_M_data()[__n], char32_t());
            }
            bool _M_is_local() const             {
                return this->_M_data() == this->_M_local_data();
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::pointer basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >::_M_create(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type &__capacity, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __old_capacity)             {
                if (__capacity > this->max_size())
                    std::__throw_length_error(("basic_string::_M_create"));
                if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
                    __capacity = 2 * __old_capacity;
                    if (__capacity > this->max_size())
                        __capacity = this->max_size();
                }
                return _Alloc_traits::allocate(this->_M_get_allocator(), __capacity + 1);
            }
            void _M_dispose()             {
                if (!this->_M_is_local())
                    this->_M_destroy(this->_M_allocated_capacity);
            }
            void _M_destroy(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __size) throw()             {
                _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
            }
            template <typename _InIterator> void _M_construct_aux(_InIterator __beg, _InIterator __end, std::__false_type);
            template<> void _M_construct_aux<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::__false_type)             {
                typedef typename iterator_traits<const char32_t *>::iterator_category _Tag;
                this->_M_construct(__beg, __end, _Tag());
            }
;
            template <typename _Integer> void _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type);
            void _M_construct_aux_2(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __req, char32_t __c);
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end);
            template<> void _M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end)             {
                typedef typename std::__is_integer<const char32_t *>::__type _Integral;
                this->_M_construct_aux(__beg, __end, _Integral());
            }
;
            template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
            template<> void _M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::input_iterator_tag);
            template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
            template<> void basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >::_M_construct<const char32_t *>(const char32_t *__beg, const char32_t *__end, std::forward_iterator_tag)             {
                if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                    std::__throw_logic_error(("basic_string::_M_construct null not valid"));
                std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __dnew = static_cast<std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type>(std::distance(__beg, __end));
                if (__dnew > std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type(_S_local_capacity)) {
                    this->_M_data(this->_M_create(__dnew, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type(0)));
                    this->_M_capacity(__dnew);
                }
                try {
                    this->_S_copy_chars(this->_M_data(), __beg, __end);
                } catch (...) {
                    this->_M_dispose();
                    throw;
                }
                this->_M_set_length(__dnew);
            }
;
            void _M_construct(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __req, char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::allocator_type &_M_get_allocator()             {
                return this->_M_dataplus;
            }
            const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::allocator_type &_M_get_allocator() const             {
                return this->_M_dataplus;
            }
        private:
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type _M_check(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, const char *__s) const;
            void _M_check_length(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n2, const char *__s) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type _M_limit(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __off) const noexcept;
            bool _M_disjunct(const char32_t *__s) const noexcept;
            static void _S_copy(char32_t *__d, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n)             {
                if (__n == 1)
                    traits_type::assign(*__d, *__s);
                else
                    traits_type::copy(__d, __s, __n);
            }
            static void _S_move(char32_t *__d, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            static void _S_assign(char32_t *__d, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, char32_t __c);
            template <class _Iterator> static void _S_copy_chars(char32_t *__p, _Iterator __k1, _Iterator __k2);
            template<> static void _S_copy_chars<const char32_t *>(char32_t *__p, const char32_t *__k1, const char32_t *__k2);
            static void _S_copy_chars(char32_t *__p, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator __k2) noexcept;
            static void _S_copy_chars(char32_t *__p, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __k2) noexcept;
            static void _S_copy_chars(char32_t *__p, char32_t *__k1, char32_t *__k2) noexcept;
            static void _S_copy_chars(char32_t *__p, const char32_t *__k1, const char32_t *__k2) noexcept             {
                _S_copy(__p, __k1, __k2 - __k1);
            }
            static int _S_compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n2) noexcept;
            void _M_assign(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &);
            void _M_mutate(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __len1, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __len2);
            void _M_erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
        public:
            basic_string();
            explicit basic_string(const std::allocator<char32_t> &__a) noexcept;
            basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str);
            basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, const std::allocator<char32_t> &__a);
            basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, const std::allocator<char32_t> &__a);
            basic_string(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, const std::allocator<char32_t> &__a = std::allocator<char32_t>()) : _M_dataplus(this->_M_local_data(), __a)             {
                this->_M_construct(__s, __s + __n);
            }
            basic_string(const char32_t *__s, const std::allocator<char32_t> &__a);
            basic_string(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, char32_t __c, const std::allocator<char32_t> &__a);
            basic_string(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &&__str) noexcept : _M_dataplus(this->_M_local_data(), std::move(__str._M_get_allocator()))             {
                if (__str._M_is_local()) {
                    traits_type::copy(this->_M_local_buf, __str._M_local_buf, _S_local_capacity + 1);
                } else {
                    this->_M_data(__str._M_data());
                    this->_M_capacity(__str._M_allocated_capacity);
                }
                this->_M_length(__str.length());
                __str._M_data(__str._M_local_data());
                __str._M_set_length(0);
            }
            basic_string(initializer_list<char32_t> __l, const std::allocator<char32_t> &__a);
            basic_string(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, const std::allocator<char32_t> &__a);
            basic_string(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &&__str, const std::allocator<char32_t> &__a);
            template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char32_t> &__a);
            ~basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >() noexcept             {
                this->_M_dispose();
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &operator=(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &operator=(const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &operator=(char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &operator=(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &&__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &operator=(initializer_list<char32_t> __l);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator begin() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator begin() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator end() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator end() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::reverse_iterator rbegin() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_reverse_iterator rbegin() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::reverse_iterator rend() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_reverse_iterator rend() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator cbegin() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator cend() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_reverse_iterator crbegin() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_reverse_iterator crend() const noexcept;
        public:
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type size() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type length() const noexcept             {
                return this->_M_string_length;
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type max_size() const noexcept             {
                return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
            }
            void resize(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, char32_t __c);
            void resize(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            void shrink_to_fit() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type capacity() const noexcept;
            void reserve(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __res_arg);
            void clear() noexcept;
            bool empty() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_reference operator[](std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::reference operator[](std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_reference at(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::reference at(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::reference front() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_reference front() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::reference back() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_reference back() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &operator+=(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &operator+=(const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &operator+=(char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &operator+=(initializer_list<char32_t> __l);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &append(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &append(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &append(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &append(const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &append(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &append(initializer_list<char32_t> __l);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &append(_InputIterator __first, _InputIterator __last);
            void push_back(char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &assign(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &assign(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &&__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &assign(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &assign(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &assign(const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &assign(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &assign(_InputIterator __first, _InputIterator __last);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &assign(initializer_list<char32_t> __l);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __p, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __p, _InputIterator __beg, _InputIterator __end);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __p, initializer_list<char32_t> __l);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator insert(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __p, char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __position);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator erase(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __first, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __last);
            void pop_back() noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n1, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n1, const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n2, char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i2, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i2, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i2, const char32_t *__s);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, char32_t __c);
            template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i2, char32_t *__k1, char32_t *__k2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i2, const char32_t *__k1, const char32_t *__k2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::iterator __k2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::__const_iterator __i2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __k1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __k2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __i2, initializer_list<char32_t> __l);
        private:
            template <class _Integer> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &_M_replace_dispatch(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
            template <class _InputIterator> std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &_M_replace_dispatch(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __i1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &_M_replace_aux(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n2, char32_t __c);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &_M_replace(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __len1, const char32_t *__s, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __len2);
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &_M_append(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n);
        public:
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type copy(char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const;
            void swap(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__s) noexcept;
            const char32_t *c_str() const noexcept;
            const char32_t *data() const noexcept             {
                return this->_M_data();
            }
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::allocator_type get_allocator() const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type rfind(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type rfind(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type rfind(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type rfind(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_first_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_first_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_first_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_first_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_last_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_last_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_last_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_last_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_first_not_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_first_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_first_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_first_not_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_last_not_of(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_last_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_last_not_of(const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type find_last_not_of(char32_t __c, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos) const noexcept;
            std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > substr(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n) const;
            int compare(const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str) const;
            int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str) const;
            int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos1, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n1, const std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > &__str, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos2, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n2) const;
            int compare(const char32_t *__s) const noexcept;
            int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n1, const char32_t *__s) const;
            int compare(std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __pos, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n1, const char32_t *__s, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >::size_type __n2) const;
            friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
        };
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
        __str.append(__rhs);
        return __str;
    }
    template<> basic_string<char, std::char_traits<char>, std::allocator<char> > operator+<char, std::char_traits<char>, std::allocator<char>>(const basic_string<char, std::char_traits<char>, std::allocator<char> > &__lhs, const basic_string<char, std::char_traits<char>, std::allocator<char> > &__rhs)    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> operator+(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs);
    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs);
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)     {
        basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
        __str.append(__rhs);
        return __str;
    }
    template<> inline basic_string<char, std::char_traits<char>, std::allocator<char> > operator+<char, std::char_traits<char>, std::allocator<char>>(const basic_string<char, std::char_traits<char>, std::allocator<char> > &__lhs, const char *__rhs)     {
        basic_string<char, std::char_traits<char>, std::allocator<char> > __str(__lhs);
        __str.append(__rhs);
        return __str;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, _CharT __rhs)     {
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __string_type::size_type __size_type;
        __string_type __str(__lhs);
        __str.append(__size_type(1), __rhs);
        return __str;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return std::move(__lhs.append(__rhs));
    }
    template<> inline basic_string<char, std::char_traits<char>, std::allocator<char> > operator+<char, std::char_traits<char>, std::allocator<char>>(basic_string<char, std::char_traits<char>, std::allocator<char> > &&__lhs, const basic_string<char, std::char_traits<char>, std::allocator<char> > &__rhs)    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, basic_string<_CharT, _Traits, _Alloc> &&__rhs)     {
        return std::move(__rhs.insert(0, __lhs));
    }
    template<> inline basic_string<char, std::char_traits<char>, std::allocator<char> > operator+<char, std::char_traits<char>, std::allocator<char>>(const basic_string<char, std::char_traits<char>, std::allocator<char> > &__lhs, basic_string<char, std::char_traits<char>, std::allocator<char> > &&__rhs)    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs, basic_string<_CharT, _Traits, _Alloc> &&__rhs)     {
        const auto __size = __lhs.size() + __rhs.size();
        const bool __cond = (__size > __lhs.capacity() && __size <= __rhs.capacity());
        return __cond ? std::move(__rhs.insert(0, __lhs)) : std::move(__lhs.append(__rhs));
    }
    template<> inline basic_string<char, std::char_traits<char>, std::allocator<char> > operator+<char, std::char_traits<char>, std::allocator<char>>(basic_string<char, std::char_traits<char>, std::allocator<char> > &&__lhs, basic_string<char, std::char_traits<char>, std::allocator<char> > &&__rhs)     {
        const auto __size = __lhs.size() + __rhs.size();
        const bool __cond = (__size > __lhs.capacity() && __size <= __rhs.capacity());
        return __cond ? std::move(__rhs.insert(0, __lhs)) : std::move(__lhs.append(__rhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(const _CharT *__lhs, basic_string<_CharT, _Traits, _Alloc> &&__rhs)     {
        return std::move(__rhs.insert(0, __lhs));
    }
    template<> inline basic_string<char, std::char_traits<char>, std::allocator<char> > operator+<char, std::char_traits<char>, std::allocator<char>>(const char *__lhs, basic_string<char, std::char_traits<char>, std::allocator<char> > &&__rhs)     {
        return std::move(__rhs.insert(0, __lhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(_CharT __lhs, basic_string<_CharT, _Traits, _Alloc> &&__rhs)     {
        return std::move(__rhs.insert(0, 1, __lhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs, const _CharT *__rhs)     {
        return std::move(__lhs.append(__rhs));
    }
    template<> inline basic_string<char, std::char_traits<char>, std::allocator<char> > operator+<char, std::char_traits<char>, std::allocator<char>>(basic_string<char, std::char_traits<char>, std::allocator<char> > &&__lhs, const char *__rhs)    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_string<_CharT, _Traits, _Alloc> operator+(basic_string<_CharT, _Traits, _Alloc> &&__lhs, _CharT __rhs)     {
        return std::move(__lhs.append(1, __rhs));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator==(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept     {
        return __lhs.compare(__rhs) == 0;
    }
    template <typename _CharT> inline typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type operator==(const basic_string<_CharT> &__lhs, const basic_string<_CharT> &__rhs) noexcept     {
        return (__lhs.size() == __rhs.size() && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(), __lhs.size()));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator==(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return __rhs.compare(__lhs) == 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator==(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)     {
        return __lhs.compare(__rhs) == 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator!=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept     {
        return !(__lhs == __rhs);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator!=(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return !(__lhs == __rhs);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator!=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)     {
        return !(__lhs == __rhs);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept     {
        return __lhs.compare(__rhs) < 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)     {
        return __lhs.compare(__rhs) < 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return __rhs.compare(__lhs) > 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept     {
        return __lhs.compare(__rhs) > 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)     {
        return __lhs.compare(__rhs) > 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return __rhs.compare(__lhs) < 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept     {
        return __lhs.compare(__rhs) <= 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)     {
        return __lhs.compare(__rhs) <= 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator<=(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return __rhs.compare(__lhs) >= 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept     {
        return __lhs.compare(__rhs) >= 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>=(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)     {
        return __lhs.compare(__rhs) >= 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline bool operator>=(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        return __rhs.compare(__lhs) <= 0;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline void swap(basic_string<_CharT, _Traits, _Alloc> &__lhs, basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept(noexcept(__lhs.swap(__rhs))swap(basic_string<_CharT, _Traits, _Alloc> &__lhs, basic_string<_CharT, _Traits, _Alloc> &__rhs) noexcept(noexcept(__lhs.swap(__rhs)))     {
        __lhs.swap(__rhs);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Alloc> &__str);
    template<> basic_istream<char> &operator>><char, std::char_traits<char>, std::allocator<char>>(basic_istream<char> &__is, basic_string<char> &__str);
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const basic_string<_CharT, _Traits, _Alloc> &__str)     {
        return __ostream_insert(__os, __str.data(), __str.size());
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim);
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__is, basic_string<_CharT, _Traits, _Alloc> &__str)     {
        return std::getline(__is, __str, __is.widen('\n'));
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &&__is, basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim)     {
        return std::getline(__is, __str, __delim);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> inline basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &&__is, basic_string<_CharT, _Traits, _Alloc> &__str)     {
        return std::getline(__is, __str);
    }
    template<> basic_istream<char> &getline<char, std::char_traits<char>, std::allocator<char>>(basic_istream<char> &__in, basic_string<char> &__str, char __delim);
    template<> basic_istream<wchar_t> &getline<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t>>(basic_istream<wchar_t> &__in, basic_string<wchar_t> &__str, wchar_t __delim);
}
extern "C" {
    typedef enum  {
        P_ALL,
        P_PID,
        P_PGID
    } idtype_t;
    typedef struct {
        int quot;
        int rem;
    } div_t;
    typedef struct {
        long quot;
        long rem;
    } ldiv_t;
    typedef struct {
        long long quot;
        long long rem;
    } lldiv_t;
    extern size_t __ctype_get_mb_cur_max() throw();
    extern double atof(const char *__nptr) throw() __attribute__((pure)) __attribute__((nonnull(1)));
    extern int atoi(const char *__nptr) throw() __attribute__((pure)) __attribute__((nonnull(1)));
    extern long atol(const char *__nptr) throw() __attribute__((pure)) __attribute__((nonnull(1)));
    extern long long atoll(const char *__nptr) throw() __attribute__((pure)) __attribute__((nonnull(1)));
    extern double strtod(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(1)));
    extern float strtof(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(1)));
    extern long double strtold(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(1)));
    extern _Float32 strtof32(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(1)));
    extern _Float64 strtof64(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(1)));
    extern _Float32x strtof32x(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(1)));
    extern _Float64x strtof64x(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((nonnull(1)));
    extern long strtol(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(1)));
    extern unsigned long strtoul(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(1)));
    extern long long strtoq(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(1)));
    extern unsigned long long strtouq(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(1)));
    extern long long strtoll(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(1)));
    extern unsigned long long strtoull(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((nonnull(1)));
    extern int strfromd(char *__dest, size_t __size, const char *__format, double __f) throw() __attribute__((nonnull(3)));
    extern int strfromf(char *__dest, size_t __size, const char *__format, float __f) throw() __attribute__((nonnull(3)));
    extern int strfroml(char *__dest, size_t __size, const char *__format, long double __f) throw() __attribute__((nonnull(3)));
    extern int strfromf32(char *__dest, size_t __size, const char *__format, _Float32 __f) throw() __attribute__((nonnull(3)));
    extern int strfromf64(char *__dest, size_t __size, const char *__format, _Float64 __f) throw() __attribute__((nonnull(3)));
    extern int strfromf32x(char *__dest, size_t __size, const char *__format, _Float32x __f) throw() __attribute__((nonnull(3)));
    extern int strfromf64x(char *__dest, size_t __size, const char *__format, _Float64x __f) throw() __attribute__((nonnull(3)));
    extern long strtol_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) throw() __attribute__((nonnull(1, 4)));
    extern unsigned long strtoul_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) throw() __attribute__((nonnull(1, 4)));
    extern long long strtoll_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) throw() __attribute__((nonnull(1, 4)));
    extern unsigned long long strtoull_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) throw() __attribute__((nonnull(1, 4)));
    extern double strtod_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) throw() __attribute__((nonnull(1, 3)));
    extern float strtof_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) throw() __attribute__((nonnull(1, 3)));
    extern long double strtold_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) throw() __attribute__((nonnull(1, 3)));
    extern _Float32 strtof32_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) throw() __attribute__((nonnull(1, 3)));
    extern _Float64 strtof64_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) throw() __attribute__((nonnull(1, 3)));
    extern _Float32x strtof32x_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) throw() __attribute__((nonnull(1, 3)));
    extern _Float64x strtof64x_l(const char *__restrict __nptr, char **__restrict __endptr, locale_t __loc) throw() __attribute__((nonnull(1, 3)));
    extern char *l64a(long __n) throw();
    extern long a64l(const char *__s) throw() __attribute__((pure)) __attribute__((nonnull(1)));
    extern "C" {
        typedef __u_char u_char;
        typedef __u_short u_short;
        typedef __u_int u_int;
        typedef __u_long u_long;
        typedef __quad_t quad_t;
        typedef __u_quad_t u_quad_t;
        typedef __fsid_t fsid_t;
        typedef __loff_t loff_t;
        typedef __ino_t ino_t;
        typedef __ino64_t ino64_t;
        typedef __dev_t dev_t;
        typedef __gid_t gid_t;
        typedef __mode_t mode_t;
        typedef __nlink_t nlink_t;
        typedef __uid_t uid_t;
        typedef __off_t off_t;
        typedef __off64_t off64_t;
        typedef __id_t id_t;
        typedef __ssize_t ssize_t;
        typedef __daddr_t daddr_t;
        typedef __caddr_t caddr_t;
        typedef __key_t key_t;
        typedef __useconds_t useconds_t;
        typedef __suseconds_t suseconds_t;
        typedef unsigned long ulong;
        typedef unsigned short ushort;
        typedef unsigned int uint;
        typedef __uint8_t u_int8_t;
        typedef __uint16_t u_int16_t;
        typedef __uint32_t u_int32_t;
        typedef __uint64_t u_int64_t;
        typedef int register_t __attribute__((mode(__word__)));
        static inline __uint16_t __bswap_16(__uint16_t __bsx)         {
            return ((__uint16_t)((((__bsx) >> 8) & 255) | (((__bsx) & 255) << 8)));
        }
        static inline __uint32_t __bswap_32(__uint32_t __bsx)         {
            return ((((__bsx) & 4278190080U) >> 24) | (((__bsx) & 16711680U) >> 8) | (((__bsx) & 65280U) << 8) | (((__bsx) & 255U) << 24));
        }
        static inline __uint64_t __bswap_64(__uint64_t __bsx)         {
            return ((((__bsx) & 18374686479671623680ULL) >> 56) | (((__bsx) & 71776119061217280ULL) >> 40) | (((__bsx) & 280375465082880ULL) >> 24) | (((__bsx) & 1095216660480ULL) >> 8) | (((__bsx) & 4278190080ULL) << 8) | (((__bsx) & 16711680ULL) << 24) | (((__bsx) & 65280ULL) << 40) | (((__bsx) & 255ULL) << 56));
        }
        static inline __uint16_t __uint16_identity(__uint16_t __x)         {
            return __x;
        }
        static inline __uint32_t __uint32_identity(__uint32_t __x)         {
            return __x;
        }
        static inline __uint64_t __uint64_identity(__uint64_t __x)         {
            return __x;
        }
        typedef struct {
            unsigned long __val[16];
        } __sigset_t;
        typedef __sigset_t sigset_t;
        typedef long __fd_mask;
        typedef struct {
            __fd_mask fds_bits[16];
        } fd_set;
        typedef __fd_mask fd_mask;
        extern "C" {
            extern int select(int __nfds, fd_set *__restrict __readfds, fd_set *__restrict __writefds, fd_set *__restrict __exceptfds, struct timeval *__restrict __timeout);
            extern int pselect(int __nfds, fd_set *__restrict __readfds, fd_set *__restrict __writefds, fd_set *__restrict __exceptfds, const struct timespec *__restrict __timeout, const __sigset_t *__restrict __sigmask);
        }
        typedef __blksize_t blksize_t;
        typedef __blkcnt_t blkcnt_t;
        typedef __fsblkcnt_t fsblkcnt_t;
        typedef __fsfilcnt_t fsfilcnt_t;
        typedef __blkcnt64_t blkcnt64_t;
        typedef __fsblkcnt64_t fsblkcnt64_t;
        typedef __fsfilcnt64_t fsfilcnt64_t;
    }
    extern long random() throw();
    extern void srandom(unsigned int __seed) throw();
    extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen) throw() __attribute__((nonnull(2)));
    extern char *setstate(char *__statebuf) throw() __attribute__((nonnull(1)));
    struct random_data {
        int32_t *fptr;
        int32_t *rptr;
        int32_t *state;
        int rand_type;
        int rand_deg;
        int rand_sep;
        int32_t *end_ptr;
    };
    extern int random_r(struct random_data *__restrict __buf, int32_t *__restrict __result) throw() __attribute__((nonnull(1, 2)));
    extern int srandom_r(unsigned int __seed, struct random_data *__buf) throw() __attribute__((nonnull(2)));
    extern int initstate_r(unsigned int __seed, char *__restrict __statebuf, size_t __statelen, struct random_data *__restrict __buf) throw() __attribute__((nonnull(2, 4)));
    extern int setstate_r(char *__restrict __statebuf, struct random_data *__restrict __buf) throw() __attribute__((nonnull(1, 2)));
    extern int rand() throw();
    extern void srand(unsigned int __seed) throw();
    extern int rand_r(unsigned int *__seed) throw();
    extern double drand48() throw();
    extern double erand48(unsigned short __xsubi[3]) throw() __attribute__((nonnull(1)));
    extern long lrand48() throw();
    extern long nrand48(unsigned short __xsubi[3]) throw() __attribute__((nonnull(1)));
    extern long mrand48() throw();
    extern long jrand48(unsigned short __xsubi[3]) throw() __attribute__((nonnull(1)));
    extern void srand48(long __seedval) throw();
    extern unsigned short *seed48(unsigned short __seed16v[3]) throw() __attribute__((nonnull(1)));
    extern void lcong48(unsigned short __param[7]) throw() __attribute__((nonnull(1)));
    struct drand48_data {
        unsigned short __x[3];
        unsigned short __old_x[3];
        unsigned short __c;
        unsigned short __init;
        unsigned long long __a;
    };
    extern int drand48_r(struct drand48_data *__restrict __buffer, double *__restrict __result) throw() __attribute__((nonnull(1, 2)));
    extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, double *__restrict __result) throw() __attribute__((nonnull(1, 2)));
    extern int lrand48_r(struct drand48_data *__restrict __buffer, long *__restrict __result) throw() __attribute__((nonnull(1, 2)));
    extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, long *__restrict __result) throw() __attribute__((nonnull(1, 2)));
    extern int mrand48_r(struct drand48_data *__restrict __buffer, long *__restrict __result) throw() __attribute__((nonnull(1, 2)));
    extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *__restrict __buffer, long *__restrict __result) throw() __attribute__((nonnull(1, 2)));
    extern int srand48_r(long __seedval, struct drand48_data *__buffer) throw() __attribute__((nonnull(2)));
    extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer) throw() __attribute__((nonnull(1, 2)));
    extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer) throw() __attribute__((nonnull(1, 2)));
    extern void *malloc(size_t __size) throw() __attribute__((malloc));
    extern void *calloc(size_t __nmemb, size_t __size) throw() __attribute__((malloc));
    extern void *realloc(void *__ptr, size_t __size) throw() __attribute__((warn_unused_result("")));
    extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size) throw() __attribute__((warn_unused_result("")));
    extern void free(void *__ptr) throw();
    extern "C" {
        extern void *alloca(size_t __size) throw();
    }
    extern void *valloc(size_t __size) throw() __attribute__((malloc));
    extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size) throw() __attribute__((nonnull(1)));
    extern void *aligned_alloc(size_t __alignment, size_t __size) throw() __attribute__((malloc));
    extern void abort() throw();
    extern int atexit(void (*__func)()) throw() __attribute__((nonnull(1)));
    extern "C++" int at_quick_exit(void (*__func)()) throw() asm("at_quick_exit") __attribute__((nonnull(1)))
    extern int on_exit(void (*__func)(int, void *), void *__arg) throw() __attribute__((nonnull(1)));
    extern void exit(int __status) throw();
    extern void quick_exit(int __status) throw();
    extern void _Exit(int __status) throw();
    extern char *getenv(const char *__name) throw() __attribute__((nonnull(1)));
    extern char *secure_getenv(const char *__name) throw() __attribute__((nonnull(1)));
    extern int putenv(char *__string) throw() __attribute__((nonnull(1)));
    extern int setenv(const char *__name, const char *__value, int __replace) throw() __attribute__((nonnull(2)));
    extern int unsetenv(const char *__name) throw() __attribute__((nonnull(1)));
    extern int clearenv() throw();
    extern char *mktemp(char *__template) throw() __attribute__((nonnull(1)));
    extern int mkstemp(char *__template) __attribute__((nonnull(1)));
    extern int mkstemp64(char *__template) __attribute__((nonnull(1)));
    extern int mkstemps(char *__template, int __suffixlen) __attribute__((nonnull(1)));
    extern int mkstemps64(char *__template, int __suffixlen) __attribute__((nonnull(1)));
    extern char *mkdtemp(char *__template) throw() __attribute__((nonnull(1)));
    extern int mkostemp(char *__template, int __flags) __attribute__((nonnull(1)));
    extern int mkostemp64(char *__template, int __flags) __attribute__((nonnull(1)));
    extern int mkostemps(char *__template, int __suffixlen, int __flags) __attribute__((nonnull(1)));
    extern int mkostemps64(char *__template, int __suffixlen, int __flags) __attribute__((nonnull(1)));
    extern int system(const char *__command);
    extern char *canonicalize_file_name(const char *__name) throw() __attribute__((nonnull(1)));
    extern char *realpath(const char *__restrict __name, char *__restrict __resolved) throw();
    typedef int (*__compar_fn_t)(const void *, const void *);
    typedef __compar_fn_t comparison_fn_t;
    typedef int (*__compar_d_fn_t)(const void *, const void *, void *);
    extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __attribute__((nonnull(1, 2, 5)));
    extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __attribute__((nonnull(1, 4)));
    extern void qsort_r(void *__base, size_t __nmemb, size_t __size, __compar_d_fn_t __compar, void *__arg) __attribute__((nonnull(1, 4)));
    extern int abs(int __x) throw() __attribute__((const));
    extern long labs(long __x) throw() __attribute__((const));
    extern long long llabs(long long __x) throw() __attribute__((const));
    extern div_t div(int __numer, int __denom) throw() __attribute__((const));
    extern ldiv_t ldiv(long __numer, long __denom) throw() __attribute__((const));
    extern lldiv_t lldiv(long long __numer, long long __denom) throw() __attribute__((const));
    extern char *ecvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((nonnull(3, 4)));
    extern char *fcvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((nonnull(3, 4)));
    extern char *gcvt(double __value, int __ndigit, char *__buf) throw() __attribute__((nonnull(3)));
    extern char *qecvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((nonnull(3, 4)));
    extern char *qfcvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((nonnull(3, 4)));
    extern char *qgcvt(long double __value, int __ndigit, char *__buf) throw() __attribute__((nonnull(3)));
    extern int ecvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) throw() __attribute__((nonnull(3, 4, 5)));
    extern int fcvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) throw() __attribute__((nonnull(3, 4, 5)));
    extern int qecvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) throw() __attribute__((nonnull(3, 4, 5)));
    extern int qfcvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, size_t __len) throw() __attribute__((nonnull(3, 4, 5)));
    extern int mblen(const char *__s, size_t __n) throw();
    extern int mbtowc(wchar_t *__restrict __pwc, const char *__restrict __s, size_t __n) throw();
    extern int wctomb(char *__s, wchar_t __wchar) throw();
    extern size_t mbstowcs(wchar_t *__restrict __pwcs, const char *__restrict __s, size_t __n) throw();
    extern size_t wcstombs(char *__restrict __s, const wchar_t *__restrict __pwcs, size_t __n) throw();
    extern int rpmatch(const char *__response) throw() __attribute__((nonnull(1)));
    extern int getsubopt(char **__restrict __optionp, char *const *__restrict __tokens, char **__restrict __valuep) throw() __attribute__((nonnull(1, 2, 3)));
    extern int posix_openpt(int __oflag);
    extern int grantpt(int __fd) throw();
    extern int unlockpt(int __fd) throw();
    extern char *ptsname(int __fd) throw();
    extern int ptsname_r(int __fd, char *__buf, size_t __buflen) throw() __attribute__((nonnull(2)));
    extern int getpt();
    extern int getloadavg(double __loadavg[], int __nelem) throw() __attribute__((nonnull(1)));
}
extern "C++" {
    namespace std {
        using ::abs;
        inline long abs(long __i)         {
            return __builtin_labs(__i);
        }
        inline long long abs(long long __x)         {
            return __builtin_llabs(__x);
        }
        inline constexpr double abs(double __x)         {
            return __builtin_fabs(__x);
        }
        inline constexpr float abs(float __x)         {
            return __builtin_fabsf(__x);
        }
        inline constexpr long double abs(long double __x)         {
            return __builtin_fabsl(__x);
        }
        inline constexpr __int128 abs(__int128 __x)         {
            return __x >= 0 ? __x : -__x;
        }
        inline constexpr __float128 abs(__float128 __x)         {
            return __x < 0 ? -__x : __x;
        }
    }
}
extern "C++" {
    namespace std {
        using ::div_t;
        using ::ldiv_t;
        using ::abort;
        using ::atexit;
        using ::at_quick_exit;
        using ::atof;
        using ::atoi;
        using ::atol;
        using ::bsearch;
        using ::calloc;
        using ::div;
        using ::exit;
        using ::free;
        using ::getenv;
        using ::labs;
        using ::ldiv;
        using ::malloc;
        using ::mblen;
        using ::mbstowcs;
        using ::mbtowc;
        using ::qsort;
        using ::quick_exit;
        using ::rand;
        using ::realloc;
        using ::srand;
        using ::strtod;
        using ::strtol;
        using ::strtoul;
        using ::system;
        using ::wcstombs;
        using ::wctomb;
        inline ldiv_t div(long __i, long __j)         {
            return ldiv(__i, __j);
        }
    }
    namespace __gnu_cxx {
        using ::lldiv_t;
        using ::_Exit;
        using ::llabs;
        inline lldiv_t div(long long __n, long long __d)         {
            lldiv_t __q;
            __q.quot = __n / __d;
            __q.rem = __n % __d;
            return __q;
        }
        using ::lldiv;
        using ::atoll;
        using ::strtoll;
        using ::strtoull;
        using ::strtof;
        using ::strtold;
    }
    namespace std {
        using ::__gnu_cxx::lldiv_t;
        using ::__gnu_cxx::_Exit;
        using ::__gnu_cxx::llabs;
        using ::__gnu_cxx::div;
        using ::__gnu_cxx::lldiv;
        using ::__gnu_cxx::atoll;
        using ::__gnu_cxx::strtof;
        using ::__gnu_cxx::strtoll;
        using ::__gnu_cxx::strtoull;
        using ::__gnu_cxx::strtold;
    }
}
extern "C" {
    typedef struct _G_fpos_t {
        __off_t __pos;
        __mbstate_t __state;
    } __fpos_t;
    typedef struct _G_fpos64_t {
        __off64_t __pos;
        __mbstate_t __state;
    } __fpos64_t;
    struct _IO_FILE;
    struct _IO_marker;
    struct _IO_codecvt;
    struct _IO_wide_data;
    typedef void _IO_lock_t;
    struct _IO_FILE {
        int _flags;
        char *_IO_read_ptr;
        char *_IO_read_end;
        char *_IO_read_base;
        char *_IO_write_base;
        char *_IO_write_ptr;
        char *_IO_write_end;
        char *_IO_buf_base;
        char *_IO_buf_end;
        char *_IO_save_base;
        char *_IO_backup_base;
        char *_IO_save_end;
        struct _IO_marker *_markers;
        struct _IO_FILE *_chain;
        int _fileno;
        int _flags2;
        __off_t _old_offset;
        unsigned short _cur_column;
        signed char _vtable_offset;
        char _shortbuf[1];
        _IO_lock_t *_lock;
        __off64_t _offset;
        struct _IO_codecvt *_codecvt;
        struct _IO_wide_data *_wide_data;
        struct _IO_FILE *_freeres_list;
        void *_freeres_buf;
        size_t __pad5;
        int _mode;
        char _unused2[20];
    };
    typedef __ssize_t (cookie_read_function_t)(void *, char *, size_t);
    typedef __ssize_t (cookie_write_function_t)(void *, const char *, size_t);
    typedef int (cookie_seek_function_t)(void *, __off64_t *, int);
    typedef int (cookie_close_function_t)(void *);
    typedef struct _IO_cookie_io_functions_t {
        cookie_read_function_t *read;
        cookie_write_function_t *write;
        cookie_seek_function_t *seek;
        cookie_close_function_t *close;
    } cookie_io_functions_t;
    typedef __gnuc_va_list va_list;
    typedef __fpos_t fpos_t;
    typedef __fpos64_t fpos64_t;
    extern FILE *stdin;
    extern FILE *stdout;
    extern FILE *stderr;
    extern int remove(const char *__filename) throw();
    extern int rename(const char *__old, const char *__new) throw();
    extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new) throw();
    extern int renameat2(int __oldfd, const char *__old, int __newfd, const char *__new, unsigned int __flags) throw();
    extern FILE *tmpfile();
    extern FILE *tmpfile64();
    extern char *tmpnam(char *__s) throw();
    extern char *tmpnam_r(char *__s) throw();
    extern char *tempnam(const char *__dir, const char *__pfx) throw() __attribute__((malloc));
    extern int fclose(FILE *__stream);
    extern int fflush(FILE *__stream);
    extern int fflush_unlocked(FILE *__stream);
    extern int fcloseall();
    extern FILE *fopen(const char *__restrict __filename, const char *__restrict __modes);
    extern FILE *freopen(const char *__restrict __filename, const char *__restrict __modes, FILE *__restrict __stream);
    extern FILE *fopen64(const char *__restrict __filename, const char *__restrict __modes);
    extern FILE *freopen64(const char *__restrict __filename, const char *__restrict __modes, FILE *__restrict __stream);
    extern FILE *fdopen(int __fd, const char *__modes) throw();
    extern FILE *fopencookie(void *__restrict __magic_cookie, const char *__restrict __modes, cookie_io_functions_t __io_funcs) throw();
    extern FILE *fmemopen(void *__s, size_t __len, const char *__modes) throw();
    extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc) throw();
    extern void setbuf(FILE *__restrict __stream, char *__restrict __buf) throw();
    extern int setvbuf(FILE *__restrict __stream, char *__restrict __buf, int __modes, size_t __n) throw();
    extern void setbuffer(FILE *__restrict __stream, char *__restrict __buf, size_t __size) throw();
    extern void setlinebuf(FILE *__stream) throw();
    extern int fprintf(FILE *__restrict __stream, const char *__restrict __format, ...);
    extern int printf(const char *__restrict __format, ...);
    extern int sprintf(char *__restrict __s, const char *__restrict __format, ...) throw();
    extern int vfprintf(FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg);
    extern int vprintf(const char *__restrict __format, __gnuc_va_list __arg);
    extern int vsprintf(char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) throw();
    extern int snprintf(char *__restrict __s, size_t __maxlen, const char *__restrict __format, ...) throw() __attribute__((format(printf, 3, 4)));
    extern int vsnprintf(char *__restrict __s, size_t __maxlen, const char *__restrict __format, __gnuc_va_list __arg) throw() __attribute__((format(printf, 3, 0)));
    extern int vasprintf(char **__restrict __ptr, const char *__restrict __f, __gnuc_va_list __arg) throw() __attribute__((format(printf, 2, 0)));
    extern int __asprintf(char **__restrict __ptr, const char *__restrict __fmt, ...) throw() __attribute__((format(printf, 2, 3)));
    extern int asprintf(char **__restrict __ptr, const char *__restrict __fmt, ...) throw() __attribute__((format(printf, 2, 3)));
    extern int vdprintf(int __fd, const char *__restrict __fmt, __gnuc_va_list __arg) __attribute__((format(printf, 2, 0)));
    extern int dprintf(int __fd, const char *__restrict __fmt, ...) __attribute__((format(printf, 2, 3)));
    extern int fscanf(FILE *__restrict __stream, const char *__restrict __format, ...);
    extern int scanf(const char *__restrict __format, ...);
    extern int sscanf(const char *__restrict __s, const char *__restrict __format, ...) throw();
    extern int fscanf(FILE *__restrict __stream, const char *__restrict __format, ...) asm("__isoc99_fscanf");
    extern int scanf(const char *__restrict __format, ...) asm("__isoc99_scanf");
    extern int sscanf(const char *__restrict __s, const char *__restrict __format, ...) throw() asm("__isoc99_sscanf");
    extern int vfscanf(FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __attribute__((format(scanf, 2, 0)));
    extern int vscanf(const char *__restrict __format, __gnuc_va_list __arg) __attribute__((format(scanf, 1, 0)));
    extern int vsscanf(const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) throw() __attribute__((format(scanf, 2, 0)));
    extern int vfscanf(FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) asm("__isoc99_vfscanf") __attribute__((format(scanf, 2, 0)));
    extern int vscanf(const char *__restrict __format, __gnuc_va_list __arg) asm("__isoc99_vscanf") __attribute__((format(scanf, 1, 0)));
    extern int vsscanf(const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) throw() asm("__isoc99_vsscanf") __attribute__((format(scanf, 2, 0)));
    extern int fgetc(FILE *__stream);
    extern int getc(FILE *__stream);
    extern int getchar();
    extern int getc_unlocked(FILE *__stream);
    extern int getchar_unlocked();
    extern int fgetc_unlocked(FILE *__stream);
    extern int fputc(int __c, FILE *__stream);
    extern int putc(int __c, FILE *__stream);
    extern int putchar(int __c);
    extern int fputc_unlocked(int __c, FILE *__stream);
    extern int putc_unlocked(int __c, FILE *__stream);
    extern int putchar_unlocked(int __c);
    extern int getw(FILE *__stream);
    extern int putw(int __w, FILE *__stream);
    extern char *fgets(char *__restrict __s, int __n, FILE *__restrict __stream);
    extern char *fgets_unlocked(char *__restrict __s, int __n, FILE *__restrict __stream);
    extern __ssize_t __getdelim(char **__restrict __lineptr, size_t *__restrict __n, int __delimiter, FILE *__restrict __stream);
    extern __ssize_t getdelim(char **__restrict __lineptr, size_t *__restrict __n, int __delimiter, FILE *__restrict __stream);
    extern __ssize_t getline(char **__restrict __lineptr, size_t *__restrict __n, FILE *__restrict __stream);
    extern int fputs(const char *__restrict __s, FILE *__restrict __stream);
    extern int puts(const char *__s);
    extern int ungetc(int __c, FILE *__stream);
    extern size_t fread(void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream);
    extern size_t fwrite(const void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __s);
    extern int fputs_unlocked(const char *__restrict __s, FILE *__restrict __stream);
    extern size_t fread_unlocked(void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream);
    extern size_t fwrite_unlocked(const void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream);
    extern int fseek(FILE *__stream, long __off, int __whence);
    extern long ftell(FILE *__stream);
    extern void rewind(FILE *__stream);
    extern int fseeko(FILE *__stream, __off_t __off, int __whence);
    extern __off_t ftello(FILE *__stream);
    extern int fgetpos(FILE *__restrict __stream, fpos_t *__restrict __pos);
    extern int fsetpos(FILE *__stream, const fpos_t *__pos);
    extern int fseeko64(FILE *__stream, __off64_t __off, int __whence);
    extern __off64_t ftello64(FILE *__stream);
    extern int fgetpos64(FILE *__restrict __stream, fpos64_t *__restrict __pos);
    extern int fsetpos64(FILE *__stream, const fpos64_t *__pos);
    extern void clearerr(FILE *__stream) throw();
    extern int feof(FILE *__stream) throw();
    extern int ferror(FILE *__stream) throw();
    extern void clearerr_unlocked(FILE *__stream) throw();
    extern int feof_unlocked(FILE *__stream) throw();
    extern int ferror_unlocked(FILE *__stream) throw();
    extern void perror(const char *__s);
    extern int sys_nerr;
    extern const char *const sys_errlist[];
    extern int _sys_nerr;
    extern const char *const _sys_errlist[];
    extern int fileno(FILE *__stream) throw();
    extern int fileno_unlocked(FILE *__stream) throw();
    extern FILE *popen(const char *__command, const char *__modes);
    extern int pclose(FILE *__stream);
    extern char *ctermid(char *__s) throw();
    extern char *cuserid(char *__s);
    struct obstack;
    extern int obstack_printf(struct obstack *__restrict __obstack, const char *__restrict __format, ...) throw() __attribute__((format(printf, 2, 3)));
    extern int obstack_vprintf(struct obstack *__restrict __obstack, const char *__restrict __format, __gnuc_va_list __args) throw() __attribute__((format(printf, 2, 0)));
    extern void flockfile(FILE *__stream) throw();
    extern int ftrylockfile(FILE *__stream) throw();
    extern void funlockfile(FILE *__stream) throw();
    extern int __uflow(FILE *);
    extern int __overflow(FILE *, int);
}
namespace std {
    using ::FILE;
    using ::fpos_t;
    using ::clearerr;
    using ::fclose;
    using ::feof;
    using ::ferror;
    using ::fflush;
    using ::fgetc;
    using ::fgetpos;
    using ::fgets;
    using ::fopen;
    using ::fprintf;
    using ::fputc;
    using ::fputs;
    using ::fread;
    using ::freopen;
    using ::fscanf;
    using ::fseek;
    using ::fsetpos;
    using ::ftell;
    using ::fwrite;
    using ::getc;
    using ::getchar;
    using ::perror;
    using ::printf;
    using ::putc;
    using ::putchar;
    using ::puts;
    using ::remove;
    using ::rename;
    using ::rewind;
    using ::scanf;
    using ::setbuf;
    using ::setvbuf;
    using ::sprintf;
    using ::sscanf;
    using ::tmpfile;
    using ::tmpnam;
    using ::ungetc;
    using ::vfprintf;
    using ::vprintf;
    using ::vsprintf;
}
namespace __gnu_cxx {
    using ::snprintf;
    using ::vfscanf;
    using ::vscanf;
    using ::vsnprintf;
    using ::vsscanf;
}
namespace std {
    using ::__gnu_cxx::snprintf;
    using ::__gnu_cxx::vfscanf;
    using ::__gnu_cxx::vscanf;
    using ::__gnu_cxx::vsnprintf;
    using ::__gnu_cxx::vsscanf;
}
extern "C" {
    extern int *__errno_location() throw() __attribute__((const));
    extern char *program_invocation_name;
    extern char *program_invocation_short_name;
    typedef int error_t;
}
namespace __gnu_cxx {
    template <typename _TRet, typename _Ret = _TRet, typename _CharT, typename ..._Base> _Ret __stoa(_TRet (*__convf)(const _CharT *, _CharT **, _Base...), const char *__name, const _CharT *__str, std::size_t *__idx, _Base ...__base)     {
        _Ret __ret;
        _CharT *__endptr;
        const struct _Save_errno {
            _Save_errno() : _M_errno((*__errno_location()))             {
                (*__errno_location()) = 0;
            }
            ~_Save_errno()             {
                if ((*__errno_location()) == 0)
                    (*__errno_location()) = this->_M_errno;
            }
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
            static bool _S_chk(_TRet, std::false_type)             {
                return false;
            }
            static bool _S_chk(_TRet __val, std::true_type)             {
                return __val < _TRet(__numeric_traits<int>::__min) || __val > _TRet(__numeric_traits<int>::__max);
            }
        };
        const _TRet __tmp = __convf(__str, &__endptr, __base...);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<_Ret, int>({})))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> int __stoa<long, int, char, <int>>(long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base)     {
        int __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<int, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long __stoa<long, long, char, <int>>(long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base)     {
        long __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> unsigned long __stoa<unsigned long, unsigned long, char, <int>>(unsigned long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base)     {
        unsigned long __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const unsigned long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<unsigned long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long long __stoa<long long, long long, char, <int>>(long long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base)     {
        long long __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> unsigned long long __stoa<unsigned long long, unsigned long long, char, <int>>(unsigned long long (*__convf)(const char *, char **, int), const char *__name, const char *__str, std::size_t *__idx, int __base)     {
        unsigned long long __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const unsigned long long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<unsigned long long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> float __stoa<float, float, char, <>>(float (*__convf)(const char *, char **), const char *__name, const char *__str, std::size_t *__idx)     {
        float __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const float __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<float, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> double __stoa<double, double, char, <>>(double (*__convf)(const char *, char **), const char *__name, const char *__str, std::size_t *__idx)     {
        double __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const double __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<double, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long double __stoa<long double, long double, char, <>>(long double (*__convf)(const char *, char **), const char *__name, const char *__str, std::size_t *__idx)     {
        long double __ret;
        char *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long double __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long double, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> int __stoa<long, int, wchar_t, <int>>(long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base)     {
        int __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<int, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long __stoa<long, long, wchar_t, <int>>(long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base)     {
        long __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> unsigned long __stoa<unsigned long, unsigned long, wchar_t, <int>>(unsigned long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base)     {
        unsigned long __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const unsigned long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<unsigned long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long long __stoa<long long, long long, wchar_t, <int>>(long long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base)     {
        long long __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> unsigned long long __stoa<unsigned long long, unsigned long long, wchar_t, <int>>(unsigned long long (*__convf)(const wchar_t *, wchar_t **, int), const char *__name, const wchar_t *__str, std::size_t *__idx, int __base)     {
        unsigned long long __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const unsigned long long __tmp = __convf(__str, &__endptr, __base);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<unsigned long long, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> float __stoa<float, float, wchar_t, <>>(float (*__convf)(const wchar_t *, wchar_t **), const char *__name, const wchar_t *__str, std::size_t *__idx)     {
        float __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const float __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<float, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> double __stoa<double, double, wchar_t, <>>(double (*__convf)(const wchar_t *, wchar_t **), const char *__name, const wchar_t *__str, std::size_t *__idx)     {
        double __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const double __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<double, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template<> long double __stoa<long double, long double, wchar_t, <>>(long double (*__convf)(const wchar_t *, wchar_t **), const char *__name, const wchar_t *__str, std::size_t *__idx)     {
        long double __ret;
        wchar_t *__endptr;
        const struct _Save_errno {
            int _M_errno;
        } __save_errno;
        struct _Range_chk {
        };
        const long double __tmp = __convf(__str, &__endptr);
        if (__endptr == __str)
            std::__throw_invalid_argument(__name);
        else if ((*__errno_location()) == 34 || _Range_chk::_S_chk(__tmp, std::is_same<long double, int>{}))
            std::__throw_out_of_range(__name);
        else
            __ret = __tmp;
        if (__idx)
            *__idx = __endptr - __str;
        return __ret;
    }
    template <typename _String, typename _CharT = typename _String::value_type> _String __to_xstring(int (*__convf)(_CharT *, std::size_t, const _CharT *, __va_list_tag *), std::size_t __n, const _CharT *__fmt, ...)     {
        _CharT *__s = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __n));
        __builtin_va_list __args;
        __builtin_va_start(__args, __fmt);
        const int __len = __convf(__s, __n, __fmt, __args);
        __builtin_va_end(__args);
        return _String(__s, __s + __len);
    }
    template<> std::__cxx11::basic_string<char> __to_xstring<std::__cxx11::basic_string<char>, char>(int (*__convf)(char *, std::size_t, const char *, __va_list_tag *), std::size_t __n, const char *__fmt, ...)     {
        char *__s = static_cast<char *>(__builtin_alloca(sizeof(char) * __n));
        __builtin_va_list __args;
        __builtin_va_start(__args, __fmt);
        const int __len = __convf(__s, __n, __fmt, __args);
        __builtin_va_end(__args);
        return std::__cxx11::basic_string<char>(__s, __s + __len);
    }
    template<> std::__cxx11::basic_string<wchar_t> __to_xstring<std::__cxx11::basic_string<wchar_t>, wchar_t>(int (*__convf)(wchar_t *, std::size_t, const wchar_t *, __va_list_tag *), std::size_t __n, const wchar_t *__fmt, ...)     {
        wchar_t *__s = static_cast<wchar_t *>(__builtin_alloca(sizeof(wchar_t) * __n));
        __builtin_va_list __args;
        __builtin_va_start(__args, __fmt);
        const int __len = __convf(__s, __n, __fmt, __args);
        __builtin_va_end(__args);
        return std::__cxx11::basic_string<wchar_t>(__s, __s + __len);
    }
}
namespace std {
    inline namespace __cxx11 {
        inline int stoi(const std::string &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(), __idx, __base);
        }
        inline long stol(const std::string &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(), __idx, __base);
        }
        inline unsigned long stoul(const std::string &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(), __idx, __base);
        }
        inline long long stoll(const std::string &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(), __idx, __base);
        }
        inline unsigned long long stoull(const std::string &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(), __idx, __base);
        }
        inline float stof(const std::string &__str, std::size_t *__idx = 0)         {
            return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx);
        }
        inline double stod(const std::string &__str, std::size_t *__idx = 0)         {
            return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx);
        }
        inline long double stold(const std::string &__str, std::size_t *__idx = 0)         {
            return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx);
        }
        inline std::string to_string(int __val)         {
            return __gnu_cxx::__to_xstring<std::string>(&std::vsnprintf, 4 * sizeof(int), "%d", __val);
        }
        inline std::string to_string(unsigned int __val)         {
            return __gnu_cxx::__to_xstring<std::string>(&std::vsnprintf, 4 * sizeof(unsigned int), "%u", __val);
        }
        inline std::string to_string(long __val)         {
            return __gnu_cxx::__to_xstring<std::string>(&std::vsnprintf, 4 * sizeof(long), "%ld", __val);
        }
        inline std::string to_string(unsigned long __val)         {
            return __gnu_cxx::__to_xstring<std::string>(&std::vsnprintf, 4 * sizeof(unsigned long), "%lu", __val);
        }
        inline std::string to_string(long long __val)         {
            return __gnu_cxx::__to_xstring<std::string>(&std::vsnprintf, 4 * sizeof(long long), "%lld", __val);
        }
        inline std::string to_string(unsigned long long __val)         {
            return __gnu_cxx::__to_xstring<std::string>(&std::vsnprintf, 4 * sizeof(unsigned long long), "%llu", __val);
        }
        inline std::string to_string(float __val)         {
            const int __n = __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::string>(&std::vsnprintf, __n, "%f", __val);
        }
        inline std::string to_string(double __val)         {
            const int __n = __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::string>(&std::vsnprintf, __n, "%f", __val);
        }
        inline std::string to_string(long double __val)         {
            const int __n = __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::string>(&std::vsnprintf, __n, "%Lf", __val);
        }
        inline int stoi(const std::wstring &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(), __idx, __base);
        }
        inline long stol(const std::wstring &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(), __idx, __base);
        }
        inline unsigned long stoul(const std::wstring &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(), __idx, __base);
        }
        inline long long stoll(const std::wstring &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(), __idx, __base);
        }
        inline unsigned long long stoull(const std::wstring &__str, std::size_t *__idx = 0, int __base = 10)         {
            return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(), __idx, __base);
        }
        inline float stof(const std::wstring &__str, std::size_t *__idx = 0)         {
            return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx);
        }
        inline double stod(const std::wstring &__str, std::size_t *__idx = 0)         {
            return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx);
        }
        inline long double stold(const std::wstring &__str, std::size_t *__idx = 0)         {
            return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx);
        }
        inline std::wstring to_wstring(int __val)         {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(int), L"%d", __val);
        }
        inline std::wstring to_wstring(unsigned int __val)         {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(unsigned int), L"%u", __val);
        }
        inline std::wstring to_wstring(long __val)         {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(long), L"%ld", __val);
        }
        inline std::wstring to_wstring(unsigned long __val)         {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(unsigned long), L"%lu", __val);
        }
        inline std::wstring to_wstring(long long __val)         {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(long long), L"%lld", __val);
        }
        inline std::wstring to_wstring(unsigned long long __val)         {
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, 4 * sizeof(unsigned long long), L"%llu", __val);
        }
        inline std::wstring to_wstring(float __val)         {
            const int __n = __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, __n, L"%f", __val);
        }
        inline std::wstring to_wstring(double __val)         {
            const int __n = __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, __n, L"%f", __val);
        }
        inline std::wstring to_wstring(long double __val)         {
            const int __n = __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
            return __gnu_cxx::__to_xstring<std::wstring>(&std::vswprintf, __n, L"%Lf", __val);
        }
    }
}
namespace std {
    template <typename _Result, typename _Arg> struct __hash_base {
        typedef _Result result_type;
        typedef _Arg argument_type;
    };
template<> struct __hash_base<unsigned long, bool> {
        typedef unsigned long result_type;
        typedef bool argument_type;
    };
template<> struct __hash_base<unsigned long, char> {
        typedef unsigned long result_type;
        typedef char argument_type;
    };
template<> struct __hash_base<unsigned long, signed char> {
        typedef unsigned long result_type;
        typedef signed char argument_type;
    };
template<> struct __hash_base<unsigned long, unsigned char> {
        typedef unsigned long result_type;
        typedef unsigned char argument_type;
    };
template<> struct __hash_base<unsigned long, wchar_t> {
        typedef unsigned long result_type;
        typedef wchar_t argument_type;
    };
template<> struct __hash_base<unsigned long, char16_t> {
        typedef unsigned long result_type;
        typedef char16_t argument_type;
    };
template<> struct __hash_base<unsigned long, char32_t> {
        typedef unsigned long result_type;
        typedef char32_t argument_type;
    };
template<> struct __hash_base<unsigned long, short> {
        typedef unsigned long result_type;
        typedef short argument_type;
    };
template<> struct __hash_base<unsigned long, int> {
        typedef unsigned long result_type;
        typedef int argument_type;
    };
template<> struct __hash_base<unsigned long, long> {
        typedef unsigned long result_type;
        typedef long argument_type;
    };
template<> struct __hash_base<unsigned long, long long> {
        typedef unsigned long result_type;
        typedef long long argument_type;
    };
template<> struct __hash_base<unsigned long, unsigned short> {
        typedef unsigned long result_type;
        typedef unsigned short argument_type;
    };
template<> struct __hash_base<unsigned long, unsigned int> {
        typedef unsigned long result_type;
        typedef unsigned int argument_type;
    };
template<> struct __hash_base<unsigned long, unsigned long> {
        typedef unsigned long result_type;
        typedef unsigned long argument_type;
    };
template<> struct __hash_base<unsigned long, unsigned long long> {
        typedef unsigned long result_type;
        typedef unsigned long long argument_type;
    };
template<> struct __hash_base<unsigned long, __int128> {
        typedef unsigned long result_type;
        typedef __int128 argument_type;
    };
template<> struct __hash_base<unsigned long, unsigned __int128> {
        typedef unsigned long result_type;
        typedef unsigned __int128 argument_type;
    };
template<> struct __hash_base<unsigned long, float> {
        typedef unsigned long result_type;
        typedef float argument_type;
    };
template<> struct __hash_base<unsigned long, double> {
        typedef unsigned long result_type;
        typedef double argument_type;
    };
template<> struct __hash_base<unsigned long, long double> {
        typedef unsigned long result_type;
        typedef long double argument_type;
    };
template<> struct __hash_base<unsigned long, std::__cxx11::basic_string<char>> {
        typedef unsigned long result_type;
        typedef std::__cxx11::basic_string<char> argument_type;
    };
template<> struct __hash_base<unsigned long, std::__cxx11::basic_string<wchar_t>> {
        typedef unsigned long result_type;
        typedef std::__cxx11::basic_string<wchar_t> argument_type;
    };
template<> struct __hash_base<unsigned long, std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> >> {
        typedef unsigned long result_type;
        typedef std::__cxx11::basic_string<char16_t, std::char_traits<char16_t>, std::allocator<char16_t> > argument_type;
    };
template<> struct __hash_base<unsigned long, std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> >> {
        typedef unsigned long result_type;
        typedef std::__cxx11::basic_string<char32_t, std::char_traits<char32_t>, std::allocator<char32_t> > argument_type;
    };
template<> struct __hash_base<unsigned long, std::error_code> {
        typedef unsigned long result_type;
        typedef std::error_code argument_type;
    };
    template <typename _Tp> struct hash;
    template <typename _Tp, typename = void> struct __poison_hash {
        static constexpr bool __enable_hash_call = false;
    private:
        __poison_hash<_Tp, type-parameter-0-1>(__poison_hash<_Tp, type-parameter-0-1> &&);
        ~__poison_hash<_Tp, type-parameter-0-1>();
    };
    template <typename _Tp> struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>> {
        static constexpr bool __enable_hash_call = true;
    };
    template <typename _Tp, bool = is_enum<_Tp>::value> struct __hash_enum {
    private:
        __hash_enum<_Tp, >(__hash_enum<_Tp, > &&);
        ~__hash_enum<_Tp, >();
    };
    template <typename _Tp> struct __hash_enum<_Tp, true> : public __hash_base<std::size_t, _Tp> {
        std::size_t operator()(_Tp __val) const noexcept         {
            using __type = typename underlying_type<_Tp>::type;
            return hash<__type>({})(static_cast<__type>(__val));
        }
    };
    template <typename _Tp> struct hash : __hash_enum<_Tp> {
    };
    template <typename _Tp> struct hash<_Tp *> : public __hash_base<std::size_t, _Tp *> {
        std::size_t operator()(_Tp *__p) const noexcept         {
            return reinterpret_cast<std::size_t>(__p);
        }
    };
    template<> struct hash<bool> : public __hash_base<std::size_t, bool> {
        std::size_t operator()(bool __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<char> : public __hash_base<std::size_t, char> {
        std::size_t operator()(char __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<signed char> : public __hash_base<std::size_t, signed char> {
        std::size_t operator()(signed char __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned char> : public __hash_base<std::size_t, unsigned char> {
        std::size_t operator()(unsigned char __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<wchar_t> : public __hash_base<std::size_t, wchar_t> {
        std::size_t operator()(wchar_t __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<char16_t> : public __hash_base<std::size_t, char16_t> {
        std::size_t operator()(char16_t __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<char32_t> : public __hash_base<std::size_t, char32_t> {
        std::size_t operator()(char32_t __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<short> : public __hash_base<std::size_t, short> {
        std::size_t operator()(short __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<int> : public __hash_base<std::size_t, int> {
        std::size_t operator()(int __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<long> : public __hash_base<std::size_t, long> {
        std::size_t operator()(long __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<long long> : public __hash_base<std::size_t, long long> {
        std::size_t operator()(long long __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned short> : public __hash_base<std::size_t, unsigned short> {
        std::size_t operator()(unsigned short __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned int> : public __hash_base<std::size_t, unsigned int> {
        std::size_t operator()(unsigned int __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned long> : public __hash_base<std::size_t, unsigned long> {
        std::size_t operator()(unsigned long __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned long long> : public __hash_base<std::size_t, unsigned long long> {
        std::size_t operator()(unsigned long long __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<__int128> : public __hash_base<std::size_t, __int128> {
        std::size_t operator()(__int128 __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    template<> struct hash<unsigned __int128> : public __hash_base<std::size_t, unsigned __int128> {
        std::size_t operator()(unsigned __int128 __val) const noexcept         {
            return static_cast<std::size_t>(__val);
        }
    };
    struct _Hash_impl {
        static std::size_t hash(const void *__ptr, std::size_t __clength, std::size_t __seed = static_cast<std::size_t>(3339675911UL))         {
            return _Hash_bytes(__ptr, __clength, __seed);
        }
        template <typename _Tp> static std::size_t hash(const _Tp &__val)         {
            return hash(&__val, sizeof (__val));
        }
        template<> static std::size_t hash<float>(const float &__val)         {
            return hash(&__val, sizeof (__val));
        }
        template<> static std::size_t hash<double>(const double &__val)         {
            return hash(&__val, sizeof (__val));
        }
        template<> static std::size_t hash<int>(const int &__val)         {
            return hash(&__val, sizeof (__val));
        }
        template <typename _Tp> static std::size_t __hash_combine(const _Tp &__val, std::size_t __hash)         {
            return hash(&__val, sizeof (__val), __hash);
        }
        template<> static std::size_t __hash_combine<const std::_V2::error_category *>(const std::_V2::error_category *const &__val, std::size_t __hash)         {
            return hash(&__val, sizeof (__val), __hash);
        }
    };
    struct _Fnv_hash_impl {
        static std::size_t hash(const void *__ptr, std::size_t __clength, std::size_t __seed = static_cast<std::size_t>(2166136261UL))         {
            return _Fnv_hash_bytes(__ptr, __clength, __seed);
        }
        template <typename _Tp> static std::size_t hash(const _Tp &__val)         {
            return hash(&__val, sizeof (__val));
        }
        template <typename _Tp> static std::size_t __hash_combine(const _Tp &__val, std::size_t __hash)         {
            return hash(&__val, sizeof (__val), __hash);
        }
    };
    template<> struct hash<float> : public __hash_base<std::size_t, float> {
        std::size_t operator()(float __val) const noexcept         {
            return __val != 0.F ? std::_Hash_impl::hash(__val) : 0;
        }
    };
    template<> struct hash<double> : public __hash_base<std::size_t, double> {
        std::size_t operator()(double __val) const noexcept         {
            return __val != 0. ? std::_Hash_impl::hash(__val) : 0;
        }
    };
    template<> struct hash<long double> : public __hash_base<std::size_t, long double> {
        std::size_t operator()(long double __val) const noexcept __attribute__((pure));
    };
    template <typename _Hash> struct __is_fast_hash : public std::true_type {
    };
    template<> struct __is_fast_hash<hash<long double>> : public std::false_type {
    };
}
namespace std {
    template<> struct hash<std::string> : public __hash_base<std::size_t, std::string> {
        std::size_t operator()(const std::string &__s) const noexcept         {
            return std::_Hash_impl::hash(__s.data(), __s.length());
        }
    };
    template<> struct __is_fast_hash<hash<std::string>> : std::false_type {
    };
    template<> struct hash<std::wstring> : public __hash_base<std::size_t, std::wstring> {
        std::size_t operator()(const std::wstring &__s) const noexcept         {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(wchar_t));
        }
    };
    template<> struct __is_fast_hash<hash<std::wstring>> : std::false_type {
    };
    template<> struct hash<std::u16string> : public __hash_base<std::size_t, std::u16string> {
        std::size_t operator()(const std::u16string &__s) const noexcept         {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char16_t));
        }
    };
    template<> struct __is_fast_hash<hash<std::u16string>> : std::false_type {
    };
    template<> struct hash<std::u32string> : public __hash_base<std::size_t, std::u32string> {
        std::size_t operator()(const std::u32string &__s) const noexcept         {
            return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char32_t));
        }
    };
    template<> struct __is_fast_hash<hash<std::u32string>> : std::false_type {
    };
    inline namespace literals {
        inline namespace string_literals {
            inline basic_string<char> operator""s(const char *__str, std::size_t __len) __attribute__((abi_tag("cxx11")))             {
                return basic_string<char>{__str, __len};
            }
            inline basic_string<wchar_t> operator""s(const wchar_t *__str, std::size_t __len) __attribute__((abi_tag("cxx11")))             {
                return basic_string<wchar_t>{__str, __len};
            }
            inline basic_string<char16_t> operator""s(const char16_t *__str, std::size_t __len) __attribute__((abi_tag("cxx11")))             {
                return basic_string<char16_t>{__str, __len};
            }
            inline basic_string<char32_t> operator""s(const char32_t *__str, std::size_t __len) __attribute__((abi_tag("cxx11")))             {
                return basic_string<char32_t>{__str, __len};
            }
        }
    }
}
namespace std {
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type npos;
    template <typename _CharT, typename _Traits, typename _Alloc> void basic_string<_CharT, _Traits, _Alloc>::swap(basic_string<_CharT, _Traits, _Alloc> &__s) noexcept     {
        if (this == &__s)
            return;
        _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());
        if (this->_M_is_local())
            if (__s._M_is_local()) {
                if (this->length() && __s.length()) {
                    _CharT __tmp_data[_S_local_capacity + 1];
                    traits_type::copy(__tmp_data, __s._M_local_buf, _S_local_capacity + 1);
                    traits_type::copy(__s._M_local_buf, this->_M_local_buf, _S_local_capacity + 1);
                    traits_type::copy(this->_M_local_buf, __tmp_data, _S_local_capacity + 1);
                } else if (__s.length()) {
                    traits_type::copy(this->_M_local_buf, __s._M_local_buf, _S_local_capacity + 1);
                    this->_M_length(__s.length());
                    __s._M_set_length(0);
                    return;
                } else if (this->length()) {
                    traits_type::copy(__s._M_local_buf, this->_M_local_buf, _S_local_capacity + 1);
                    __s._M_length(this->length());
                    this->_M_set_length(0);
                    return;
                }
            } else {
                const std::__cxx11::basic_string::size_type __tmp_capacity = __s._M_allocated_capacity;
                traits_type::copy(__s._M_local_buf, this->_M_local_buf, _S_local_capacity + 1);
                _M_data(__s._M_data());
                __s._M_data(__s._M_local_buf);
                this->_M_capacity(__tmp_capacity);
            }
        else {
            const std::__cxx11::basic_string::size_type __tmp_capacity = this->_M_allocated_capacity;
            if (__s._M_is_local()) {
                traits_type::copy(this->_M_local_buf, __s._M_local_buf, _S_local_capacity + 1);
                __s._M_data(_M_data());
                _M_data(this->_M_local_buf);
            } else {
                std::__cxx11::basic_string::pointer __tmp_ptr = _M_data();
                _M_data(__s._M_data());
                __s._M_data(__tmp_ptr);
                this->_M_capacity(__s._M_allocated_capacity);
            }
            __s._M_capacity(__tmp_capacity);
        }
        const std::__cxx11::basic_string::size_type __tmp_length = this->length();
        this->_M_length(__s.length());
        __s._M_length(__tmp_length);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::pointer basic_string<_CharT, _Traits, _Alloc>::_M_create(std::__cxx11::basic_string::size_type &__capacity, std::__cxx11::basic_string::size_type __old_capacity)     {
        if (__capacity > this->max_size())
            std::__throw_length_error(("basic_string::_M_create"));
        if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) {
            __capacity = 2 * __old_capacity;
            if (__capacity > this->max_size())
                __capacity = this->max_size();
        }
        return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> template <typename _InIterator> void basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag)     {
        std::__cxx11::basic_string::size_type __len = 0;
        std::__cxx11::basic_string::size_type __capacity = std::__cxx11::basic_string::size_type(_S_local_capacity);
        while (__beg != __end && __len < __capacity)
            {
                _M_data()[__len++] = *__beg;
                ++__beg;
            }
        try {
            while (__beg != __end)
                {
                    if (__len == __capacity) {
                        __capacity = __len + 1;
                        std::__cxx11::basic_string::pointer __another = this->_M_create(__capacity, __len);
                        this->_S_copy(__another, _M_data(), __len);
                        this->_M_dispose();
                        _M_data(__another);
                        this->_M_capacity(__capacity);
                    }
                    _M_data()[__len++] = *__beg;
                    ++__beg;
                }
        } catch (...) {
            this->_M_dispose();
            throw;
        }
        this->_M_set_length(__len);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> template <typename _InIterator> void basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator __beg, _InIterator __end, std::forward_iterator_tag)     {
        if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
            std::__throw_logic_error(("basic_string::_M_construct null not valid"));
        std::__cxx11::basic_string::size_type __dnew = static_cast<std::__cxx11::basic_string::size_type>(std::distance(__beg, __end));
        if (__dnew > std::__cxx11::basic_string::size_type(_S_local_capacity)) {
            _M_data(this->_M_create(__dnew, std::__cxx11::basic_string::size_type(0)));
            this->_M_capacity(__dnew);
        }
        try {
            this->_S_copy_chars(_M_data(), __beg, __end);
        } catch (...) {
            this->_M_dispose();
            throw;
        }
        this->_M_set_length(__dnew);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> void basic_string<_CharT, _Traits, _Alloc>::_M_construct(std::__cxx11::basic_string::size_type __n, _CharT __c)     {
        if (__n > std::__cxx11::basic_string::size_type(_S_local_capacity)) {
            _M_data(this->_M_create(__n, std::__cxx11::basic_string::size_type(0)));
            this->_M_capacity(__n);
        }
        if (__n)
            this->_S_assign(_M_data(), __n, __c);
        this->_M_set_length(__n);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> void basic_string<_CharT, _Traits, _Alloc>::_M_assign(const basic_string<_CharT, _Traits, _Alloc> &__str)     {
        if (this != &__str) {
            const std::__cxx11::basic_string::size_type __rsize = __str.length();
            const std::__cxx11::basic_string::size_type __capacity = this->capacity();
            if (__rsize > __capacity) {
                std::__cxx11::basic_string::size_type __new_capacity = __rsize;
                std::__cxx11::basic_string::pointer __tmp = this->_M_create(__new_capacity, __capacity);
                this->_M_dispose();
                _M_data(__tmp);
                this->_M_capacity(__new_capacity);
            }
            if (__rsize)
                this->_S_copy(_M_data(), __str._M_data(), __rsize);
            this->_M_set_length(__rsize);
        }
    }
    template <typename _CharT, typename _Traits, typename _Alloc> void basic_string<_CharT, _Traits, _Alloc>::reserve(std::__cxx11::basic_string::size_type __res = 0)     {
        if (__res < this->length())
            __res = this->length();
        const std::__cxx11::basic_string::size_type __capacity = this->capacity();
        if (__res != __capacity) {
            if (__res > __capacity || __res > std::__cxx11::basic_string::size_type(_S_local_capacity)) {
                std::__cxx11::basic_string::pointer __tmp = this->_M_create(__res, __capacity);
                this->_S_copy(__tmp, _M_data(), this->length() + 1);
                this->_M_dispose();
                _M_data(__tmp);
                this->_M_capacity(__res);
            } else if (!this->_M_is_local()) {
                this->_S_copy(_M_local_data(), _M_data(), this->length() + 1);
                this->_M_destroy(__capacity);
                _M_data(_M_local_data());
            }
        }
    }
    template <typename _CharT, typename _Traits, typename _Alloc> void basic_string<_CharT, _Traits, _Alloc>::_M_mutate(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __len1, const _CharT *__s, std::__cxx11::basic_string::size_type __len2)     {
        const std::__cxx11::basic_string::size_type __how_much = this->length() - __pos - __len1;
        std::__cxx11::basic_string::size_type __new_capacity = this->length() + __len2 - __len1;
        std::__cxx11::basic_string::pointer __r = this->_M_create(__new_capacity, this->capacity());
        if (__pos)
            this->_S_copy(__r, _M_data(), __pos);
        if (__s && __len2)
            this->_S_copy(__r + __pos, __s, __len2);
        if (__how_much)
            this->_S_copy(__r + __pos + __len2, _M_data() + __pos + __len1, __how_much);
        this->_M_dispose();
        _M_data(__r);
        this->_M_capacity(__new_capacity);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> void basic_string<_CharT, _Traits, _Alloc>::_M_erase(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n)     {
        const std::__cxx11::basic_string::size_type __how_much = this->length() - __pos - __n;
        if (__how_much && __n)
            this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);
        this->_M_set_length(this->length() - __n);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> void basic_string<_CharT, _Traits, _Alloc>::resize(std::__cxx11::basic_string::size_type __n, _CharT __c)     {
        const std::__cxx11::basic_string::size_type __size = this->size();
        if (__size < __n)
            this->append(__n - __size, __c);
        else if (__n < __size)
            this->_M_set_length(__n);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_append(const _CharT *__s, std::__cxx11::basic_string::size_type __n)     {
        const std::__cxx11::basic_string::size_type __len = __n + this->size();
        if (__len <= this->capacity()) {
            if (__n)
                this->_S_copy(this->_M_data() + this->size(), __s, __n);
        } else
            this->_M_mutate(this->size(), std::__cxx11::basic_string::size_type(0), __s, __n);
        this->_M_set_length(__len);
        return *this;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> template <typename _InputIterator> basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace_dispatch(std::__cxx11::basic_string::const_iterator __i1, std::__cxx11::basic_string::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type)     {
        const basic_string<_CharT, _Traits, _Alloc> __s(__k1, __k2);
        const std::__cxx11::basic_string::size_type __n1 = __i2 - __i1;
        return this->_M_replace(__i1 - begin(), __n1, __s._M_data(), __s.size());
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace_aux(std::__cxx11::basic_string::size_type __pos1, std::__cxx11::basic_string::size_type __n1, std::__cxx11::basic_string::size_type __n2, _CharT __c)     {
        this->_M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
        const std::__cxx11::basic_string::size_type __old_size = this->size();
        const std::__cxx11::basic_string::size_type __new_size = __old_size + __n2 - __n1;
        if (__new_size <= this->capacity()) {
            std::__cxx11::basic_string::pointer __p = this->_M_data() + __pos1;
            const std::__cxx11::basic_string::size_type __how_much = __old_size - __pos1 - __n1;
            if (__how_much && __n1 != __n2)
                this->_S_move(__p + __n2, __p + __n1, __how_much);
        } else
            this->_M_mutate(__pos1, __n1, 0, __n2);
        if (__n2)
            this->_S_assign(this->_M_data() + __pos1, __n2, __c);
        this->_M_set_length(__new_size);
        return *this;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __len1, const _CharT *__s, const std::__cxx11::basic_string::size_type __len2)     {
        this->_M_check_length(__len1, __len2, "basic_string::_M_replace");
        const std::__cxx11::basic_string::size_type __old_size = this->size();
        const std::__cxx11::basic_string::size_type __new_size = __old_size + __len2 - __len1;
        if (__new_size <= this->capacity()) {
            std::__cxx11::basic_string::pointer __p = this->_M_data() + __pos;
            const std::__cxx11::basic_string::size_type __how_much = __old_size - __pos - __len1;
            if (this->_M_disjunct(__s)) {
                if (__how_much && __len1 != __len2)
                    this->_S_move(__p + __len2, __p + __len1, __how_much);
                if (__len2)
                    this->_S_copy(__p, __s, __len2);
            } else {
                if (__len2 && __len2 <= __len1)
                    this->_S_move(__p, __s, __len2);
                if (__how_much && __len1 != __len2)
                    this->_S_move(__p + __len2, __p + __len1, __how_much);
                if (__len2 > __len1) {
                    if (__s + __len2 <= __p + __len1)
                        this->_S_move(__p, __s, __len2);
                    else if (__s >= __p + __len1)
                        this->_S_copy(__p, __s + __len2 - __len1, __len2);
                    else {
                        const std::__cxx11::basic_string::size_type __nleft = (__p + __len1) - __s;
                        this->_S_move(__p, __s, __nleft);
                        this->_S_copy(__p + __nleft, __p + __len2, __len2 - __nleft);
                    }
                }
            }
        } else
            this->_M_mutate(__pos, __len1, __s, __len2);
        this->_M_set_length(__new_size);
        return *this;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::copy(_CharT *__s, std::__cxx11::basic_string::size_type __n, std::__cxx11::basic_string::size_type __pos = 0) const     {
        this->_M_check(__pos, "basic_string::copy");
        __n = this->_M_limit(__pos, __n);
        ;
        if (__n)
            _S_copy(__s, _M_data() + __pos, __n);
        return __n;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> operator+(const _CharT *__lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        ;
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __string_type::size_type __size_type;
        const __size_type __len = _Traits::length(__lhs);
        __string_type __str;
        __str.reserve(__len + __rhs.size());
        __str.append(__lhs, __len);
        __str.append(__rhs);
        return __str;
    }
    template<> basic_string<char, std::char_traits<char>, std::allocator<char> > operator+<char, std::char_traits<char>, std::allocator<char>>(const char *__lhs, const basic_string<char, std::char_traits<char>, std::allocator<char> > &__rhs)    template <typename _CharT, typename _Traits, typename _Alloc> basic_string<_CharT, _Traits, _Alloc> operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc> &__rhs)     {
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __string_type::size_type __size_type;
        __string_type __str;
        const __size_type __len = __rhs.size();
        __str.reserve(__len + 1);
        __str.append(__size_type(1), __lhs);
        __str.append(__rhs);
        return __str;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept     {
        ;
        const std::__cxx11::basic_string::size_type __size = this->size();
        if (__n == 0)
            return __pos <= __size ? __pos : npos;
        if (__pos >= __size)
            return npos;
        const _CharT __elem0 = __s[0];
        const _CharT *const __data = this->data();
        const _CharT *__first = __data + __pos;
        const _CharT *const __last = __data + __size;
        std::__cxx11::basic_string::size_type __len = __size - __pos;
        while (__len >= __n)
            {
                __first = traits_type::find(__first, __len - __n + 1, __elem0);
                if (!__first)
                    return npos;
                if (traits_type::compare(__first, __s, __n) == 0)
                    return __first - __data;
                __len = __last - ++__first;
            }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find(_CharT __c, std::__cxx11::basic_string::size_type __pos = 0) const noexcept     {
        std::__cxx11::basic_string::size_type __ret = npos;
        const std::__cxx11::basic_string::size_type __size = this->size();
        if (__pos < __size) {
            const _CharT *__data = _M_data();
            const std::__cxx11::basic_string::size_type __n = __size - __pos;
            const _CharT *__p = traits_type::find(__data + __pos, __n, __c);
            if (__p)
                __ret = __p - __data;
        }
        return __ret;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::rfind(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept     {
        ;
        const std::__cxx11::basic_string::size_type __size = this->size();
        if (__n <= __size) {
            __pos = std::min(std::__cxx11::basic_string::size_type(__size - __n), __pos);
            const _CharT *__data = _M_data();
            do {
                if (traits_type::compare(__data + __pos, __s, __n) == 0)
                    return __pos;
            } while (__pos-- > 0);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::rfind(_CharT __c, std::__cxx11::basic_string::size_type __pos = npos) const noexcept     {
        std::__cxx11::basic_string::size_type __size = this->size();
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            for (++__size; __size-- > 0;)
                if (traits_type::eq(_M_data()[__size], __c))
                    return __size;
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept     {
        ;
        for (; __n && __pos < this->size(); ++__pos) {
            const _CharT *__p = traits_type::find(__s, __n, _M_data()[__pos]);
            if (__p)
                return __pos;
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept     {
        ;
        std::__cxx11::basic_string::size_type __size = this->size();
        if (__size && __n) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (traits_type::find(__s, __n, _M_data()[__size]))
                    return __size;
            } while (__size-- != 0);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept     {
        ;
        for (; __pos < this->size(); ++__pos)
            if (!traits_type::find(__s, __n, _M_data()[__pos]))
                return __pos;
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(_CharT __c, std::__cxx11::basic_string::size_type __pos = 0) const noexcept     {
        for (; __pos < this->size(); ++__pos)
            if (!traits_type::eq(_M_data()[__pos], __c))
                return __pos;
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(const _CharT *__s, std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n) const noexcept     {
        ;
        std::__cxx11::basic_string::size_type __size = this->size();
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (!traits_type::find(__s, __n, _M_data()[__size]))
                    return __size;
            } while (__size--);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> typename basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(_CharT __c, std::__cxx11::basic_string::size_type __pos = npos) const noexcept     {
        std::__cxx11::basic_string::size_type __size = this->size();
        if (__size) {
            if (--__size > __pos)
                __size = __pos;
            do {
                if (!traits_type::eq(_M_data()[__size], __c))
                    return __size;
            } while (__size--);
        }
        return npos;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> int basic_string<_CharT, _Traits, _Alloc>::compare(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n, const basic_string<_CharT, _Traits, _Alloc> &__str) const     {
        this->_M_check(__pos, "basic_string::compare");
        __n = this->_M_limit(__pos, __n);
        const std::__cxx11::basic_string::size_type __osize = __str.size();
        const std::__cxx11::basic_string::size_type __len = std::min(__n, __osize);
        int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
        if (!__r)
            __r = _S_compare(__n, __osize);
        return __r;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> int basic_string<_CharT, _Traits, _Alloc>::compare(std::__cxx11::basic_string::size_type __pos1, std::__cxx11::basic_string::size_type __n1, const basic_string<_CharT, _Traits, _Alloc> &__str, std::__cxx11::basic_string::size_type __pos2, std::__cxx11::basic_string::size_type __n2 = npos) const     {
        this->_M_check(__pos1, "basic_string::compare");
        __str._M_check(__pos2, "basic_string::compare");
        __n1 = this->_M_limit(__pos1, __n1);
        __n2 = __str._M_limit(__pos2, __n2);
        const std::__cxx11::basic_string::size_type __len = std::min(__n1, __n2);
        int __r = traits_type::compare(_M_data() + __pos1, __str.data() + __pos2, __len);
        if (!__r)
            __r = _S_compare(__n1, __n2);
        return __r;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> int basic_string<_CharT, _Traits, _Alloc>::compare(const _CharT *__s) const noexcept     {
        ;
        const std::__cxx11::basic_string::size_type __size = this->size();
        const std::__cxx11::basic_string::size_type __osize = traits_type::length(__s);
        const std::__cxx11::basic_string::size_type __len = std::min(__size, __osize);
        int __r = traits_type::compare(_M_data(), __s, __len);
        if (!__r)
            __r = _S_compare(__size, __osize);
        return __r;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> int basic_string<_CharT, _Traits, _Alloc>::compare(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n1, const _CharT *__s) const     {
        ;
        this->_M_check(__pos, "basic_string::compare");
        __n1 = this->_M_limit(__pos, __n1);
        const std::__cxx11::basic_string::size_type __osize = traits_type::length(__s);
        const std::__cxx11::basic_string::size_type __len = std::min(__n1, __osize);
        int __r = traits_type::compare(_M_data() + __pos, __s, __len);
        if (!__r)
            __r = _S_compare(__n1, __osize);
        return __r;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> int basic_string<_CharT, _Traits, _Alloc>::compare(std::__cxx11::basic_string::size_type __pos, std::__cxx11::basic_string::size_type __n1, const _CharT *__s, std::__cxx11::basic_string::size_type __n2) const     {
        ;
        this->_M_check(__pos, "basic_string::compare");
        __n1 = this->_M_limit(__pos, __n1);
        const std::__cxx11::basic_string::size_type __len = std::min(__n1, __n2);
        int __r = traits_type::compare(_M_data() + __pos, __s, __len);
        if (!__r)
            __r = _S_compare(__n1, __n2);
        return __r;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, basic_string<_CharT, _Traits, _Alloc> &__str)     {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __istream_type::ios_base __ios_base;
        typedef typename __istream_type::int_type __int_type;
        typedef typename __string_type::size_type __size_type;
        typedef ctype<_CharT> __ctype_type;
        typedef typename __ctype_type::ctype_base __ctype_base;
        __size_type __extracted = 0;
        typename __ios_base::iostate __err = __ios_base::goodbit;
        typename __istream_type::sentry __cerb(__in, false);
        if (__cerb) {
            try {
                __str.erase();
                _CharT __buf[128];
                __size_type __len = 0;
                const std::streamsize __w = __in.width();
                const __size_type __n = __w > 0 ? static_cast<__size_type>(__w) : __str.max_size();
                const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
                const __int_type __eof = _Traits::eof();
                __int_type __c = __in.rdbuf()->sgetc();
                while (__extracted < __n && !_Traits::eq_int_type(__c, __eof) && !__ct.is(__ctype_base::space, _Traits::to_char_type(__c)))
                    {
                        if (__len == sizeof (__buf) / sizeof(_CharT)) {
                            __str.append(__buf, sizeof (__buf) / sizeof(_CharT));
                            __len = 0;
                        }
                        __buf[__len++] = _Traits::to_char_type(__c);
                        ++__extracted;
                        __c = __in.rdbuf()->snextc();
                    }
                __str.append(__buf, __len);
                if (_Traits::eq_int_type(__c, __eof))
                    __err |= __ios_base::eofbit;
                __in.width(0);
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(__ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(__ios_base::badbit);
            }
        }
        if (!__extracted)
            __err |= __ios_base::failbit;
        if (__err)
            __in.setstate(__err);
        return __in;
    }
    template <typename _CharT, typename _Traits, typename _Alloc> basic_istream<_CharT, _Traits> &getline(basic_istream<_CharT, _Traits> &__in, basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim)     {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
        typedef typename __istream_type::ios_base __ios_base;
        typedef typename __istream_type::int_type __int_type;
        typedef typename __string_type::size_type __size_type;
        __size_type __extracted = 0;
        const __size_type __n = __str.max_size();
        typename __ios_base::iostate __err = __ios_base::goodbit;
        typename __istream_type::sentry __cerb(__in, true);
        if (__cerb) {
            try {
                __str.erase();
                const __int_type __idelim = _Traits::to_int_type(__delim);
                const __int_type __eof = _Traits::eof();
                __int_type __c = __in.rdbuf()->sgetc();
                while (__extracted < __n && !_Traits::eq_int_type(__c, __eof) && !_Traits::eq_int_type(__c, __idelim))
                    {
                        __str += _Traits::to_char_type(__c);
                        ++__extracted;
                        __c = __in.rdbuf()->snextc();
                    }
                if (_Traits::eq_int_type(__c, __eof))
                    __err |= __ios_base::eofbit;
                else if (_Traits::eq_int_type(__c, __idelim)) {
                    ++__extracted;
                    __in.rdbuf()->sbumpc();
                } else
                    __err |= __ios_base::failbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(__ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(__ios_base::badbit);
            }
        }
        if (!__extracted)
            __err |= __ios_base::failbit;
        if (__err)
            __in.setstate(__err);
        return __in;
    }
    template<> class basic_string<char> {
        typedef typename __gnu_cxx::__alloc_traits<allocator<char> >::rebind<char>::other _Char_alloc_type;
        typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
    public:
        typedef std::char_traits<char> traits_type;
        typedef typename char_traits<char>::char_type value_type;
        typedef std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Char_alloc_type allocator_type;
        typedef typename _Alloc_traits::size_type size_type;
        typedef typename _Alloc_traits::difference_type difference_type;
        typedef typename _Alloc_traits::reference reference;
        typedef typename _Alloc_traits::const_reference const_reference;
        typedef typename _Alloc_traits::pointer pointer;
        typedef typename _Alloc_traits::const_pointer const_pointer;
        typedef __gnu_cxx::__normal_iterator<pointer, basic_string<char> > iterator;
        typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<char> > const_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        typedef std::reverse_iterator<iterator> reverse_iterator;
        static const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type npos = static_cast<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type>(-1);
    protected:
        typedef std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator __const_iterator;
    private:
        struct _Alloc_hider : std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::allocator_type {
            _Alloc_hider(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::pointer __dat, const std::allocator<char> &__a) : std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::allocator_type(__a), _M_p(__dat)             {
            }
            _Alloc_hider(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::pointer __dat, std::allocator<char> &&__a) : std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::allocator_type(std::move(__a)), _M_p(__dat)             {
            }
            std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::pointer _M_p;
        };
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_Alloc_hider _M_dataplus;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _M_string_length;
        enum  {
            _S_local_capacity = 15 / sizeof(char)
        };
        union {
            char _M_local_buf[16];
            std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _M_allocated_capacity;
        };
        void _M_data(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::pointer __p)         {
            this->_M_dataplus._M_p = __p;
        }
        void _M_length(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __length)         {
            this->_M_string_length = __length;
        }
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::pointer _M_data() const         {
            return this->_M_dataplus._M_p;
        }
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::pointer _M_local_data()         {
            return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
        }
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_pointer _M_local_data() const         {
            return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
        }
        void _M_capacity(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __capacity)         {
            this->_M_allocated_capacity = __capacity;
        }
        void _M_set_length(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n)         {
            this->_M_length(__n);
            traits_type::assign(this->_M_data()[__n], char());
        }
        bool _M_is_local() const         {
            return this->_M_data() == this->_M_local_data();
        }
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::pointer _M_create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type &, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type);
        void _M_dispose()         {
            if (!this->_M_is_local())
                this->_M_destroy(this->_M_allocated_capacity);
        }
        void _M_destroy(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __size) throw()         {
            _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
        }
        template <typename _InIterator> void _M_construct_aux(_InIterator __beg, _InIterator __end, std::__false_type);
        template<> void _M_construct_aux<char *>(char *__beg, char *__end, std::__false_type)         {
            typedef typename iterator_traits<char *>::iterator_category _Tag;
            this->_M_construct(__beg, __end, _Tag());
        }
;
        template<> void _M_construct_aux<const char *>(const char *__beg, const char *__end, std::__false_type)         {
            typedef typename iterator_traits<const char *>::iterator_category _Tag;
            this->_M_construct(__beg, __end, _Tag());
        }
;
        template <typename _Integer> void _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type);
        void _M_construct_aux_2(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __req, char __c);
        template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end);
        template<> void _M_construct<char *>(char *__beg, char *__end)         {
            typedef typename std::__is_integer<char *>::__type _Integral;
            this->_M_construct_aux(__beg, __end, _Integral());
        }
;
        template<> void _M_construct<const char *>(const char *__beg, const char *__end)         {
            typedef typename std::__is_integer<const char *>::__type _Integral;
            this->_M_construct_aux(__beg, __end, _Integral());
        }
;
        template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
        template<> void _M_construct<char *>(char *__beg, char *__end, std::input_iterator_tag);
        template<> void _M_construct<const char *>(const char *__beg, const char *__end, std::input_iterator_tag);
        template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
        template<> void basic_string<char, char_traits<char>, allocator<char> >::_M_construct<char *>(char *__beg, char *__end, std::forward_iterator_tag)         {
            if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                std::__throw_logic_error(("basic_string::_M_construct null not valid"));
            std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __dnew = static_cast<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type>(std::distance(__beg, __end));
            if (__dnew > std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type(_S_local_capacity)) {
                this->_M_data(this->_M_create(__dnew, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type(0)));
                this->_M_capacity(__dnew);
            }
            try {
                this->_S_copy_chars(this->_M_data(), __beg, __end);
            } catch (...) {
                this->_M_dispose();
                throw;
            }
            this->_M_set_length(__dnew);
        }
;
        template<> void basic_string<char, char_traits<char>, allocator<char> >::_M_construct<const char *>(const char *__beg, const char *__end, std::forward_iterator_tag)         {
            if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                std::__throw_logic_error(("basic_string::_M_construct null not valid"));
            std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __dnew = static_cast<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type>(std::distance(__beg, __end));
            if (__dnew > std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type(_S_local_capacity)) {
                this->_M_data(this->_M_create(__dnew, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type(0)));
                this->_M_capacity(__dnew);
            }
            try {
                this->_S_copy_chars(this->_M_data(), __beg, __end);
            } catch (...) {
                this->_M_dispose();
                throw;
            }
            this->_M_set_length(__dnew);
        }
;
        void _M_construct(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __req, char __c);
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::allocator_type &_M_get_allocator()         {
            return this->_M_dataplus;
        }
        const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::allocator_type &_M_get_allocator() const         {
            return this->_M_dataplus;
        }
    private:
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _M_check(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, const char *__s) const         {
            if (__pos > this->size())
                __throw_out_of_range_fmt(("%s: __pos (which is %zu) > this->size() (which is %zu)"), __s, __pos, this->size());
            return __pos;
        }
        void _M_check_length(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n2, const char *__s) const         {
            if (this->max_size() - (this->size() - __n1) < __n2)
                __throw_length_error((__s));
        }
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type _M_limit(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __off) const noexcept         {
            const bool __testoff = __off < this->size() - __pos;
            return __testoff ? __off : this->size() - __pos;
        }
        bool _M_disjunct(const char *__s) const noexcept;
        static void _S_copy(char *__d, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n)         {
            if (__n == 1)
                traits_type::assign(*__d, *__s);
            else
                traits_type::copy(__d, __s, __n);
        }
        static void _S_move(char *__d, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n);
        static void _S_assign(char *__d, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n, char __c);
        template <class _Iterator> static void _S_copy_chars(char *__p, _Iterator __k1, _Iterator __k2);
        template<> static void _S_copy_chars<char *>(char *__p, char *__k1, char *__k2);
        template<> static void _S_copy_chars<const char *>(char *__p, const char *__k1, const char *__k2);
        static void _S_copy_chars(char *__p, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator __k1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator __k2) noexcept;
        static void _S_copy_chars(char *__p, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator __k1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator __k2) noexcept;
        static void _S_copy_chars(char *__p, char *__k1, char *__k2) noexcept         {
            _S_copy(__p, __k1, __k2 - __k1);
        }
        static void _S_copy_chars(char *__p, const char *__k1, const char *__k2) noexcept         {
            _S_copy(__p, __k1, __k2 - __k1);
        }
        static int _S_compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n2) noexcept;
        void _M_assign(const std::__cxx11::basic_string<char> &);
        void _M_mutate(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __len1, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __len2);
        void _M_erase(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n);
    public:
        basic_string() noexcept(is_nothrow_default_constructible<allocator<char> >::valuebasic_string() noexcept(is_nothrow_default_constructible<allocator<char> >::value);
        explicit basic_string(const std::allocator<char> &__a) noexcept;
        basic_string(const std::__cxx11::basic_string<char> &__str) : _M_dataplus(this->_M_local_data(), _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))         {
            this->_M_construct(__str._M_data(), __str._M_data() + __str.length());
        }
        basic_string(const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, const std::allocator<char> &__a);
        basic_string(const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n);
        basic_string(const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n, const std::allocator<char> &__a);
        basic_string(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a)         {
            this->_M_construct(__s, __s + __n);
        }
        basic_string(const char *__s, const std::allocator<char> &__a);
        basic_string(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n, char __c, const std::allocator<char> &__a);
        basic_string(std::__cxx11::basic_string<char> &&__str) noexcept : _M_dataplus(this->_M_local_data(), std::move(__str._M_get_allocator()))         {
            if (__str._M_is_local()) {
                traits_type::copy(this->_M_local_buf, __str._M_local_buf, _S_local_capacity + 1);
            } else {
                this->_M_data(__str._M_data());
                this->_M_capacity(__str._M_allocated_capacity);
            }
            this->_M_length(__str.length());
            __str._M_data(__str._M_local_data());
            __str._M_set_length(0);
        }
        basic_string(initializer_list<char> __l, const std::allocator<char> &__a);
        basic_string(const std::__cxx11::basic_string<char> &__str, const std::allocator<char> &__a);
        basic_string(std::__cxx11::basic_string<char> &&__str, const std::allocator<char> &__a);
        template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<char> &__a);
        template<> basic_string<char *, void>(char *__beg, char *__end, const std::allocator<char> &__a = std::allocator<char>()) : _M_dataplus(this->_M_local_data(), __a)         {
            this->_M_construct(__beg, __end);
        }
;
        ~basic_string<char>() noexcept         {
            this->_M_dispose();
        }
        std::__cxx11::basic_string<char> &operator=(const std::__cxx11::basic_string<char> &__str);
        std::__cxx11::basic_string<char> &operator=(const char *__s);
        std::__cxx11::basic_string<char> &operator=(char __c);
        std::__cxx11::basic_string<char> &operator=(std::__cxx11::basic_string<char> &&__str);
        std::__cxx11::basic_string<char> &operator=(initializer_list<char> __l);
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator begin() noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator begin() const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator end() noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator end() const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::reverse_iterator rbegin() noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reverse_iterator rbegin() const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::reverse_iterator rend() noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reverse_iterator rend() const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator cbegin() const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator cend() const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reverse_iterator crbegin() const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reverse_iterator crend() const noexcept;
    public:
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type size() const noexcept         {
            return this->_M_string_length;
        }
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type length() const noexcept         {
            return this->_M_string_length;
        }
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type max_size() const noexcept         {
            return (_Alloc_traits::max_size(this->_M_get_allocator()) - 1) / 2;
        }
        void resize(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n, char __c);
        void resize(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n);
        void shrink_to_fit() noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type capacity() const noexcept         {
            return this->_M_is_local() ? std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type(_S_local_capacity) : this->_M_allocated_capacity;
        }
        void reserve(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __res_arg);
        void clear() noexcept;
        bool empty() const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reference operator[](std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::reference operator[](std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos);
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reference at(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n) const;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::reference at(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n);
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::reference front() noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reference front() const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::reference back() noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_reference back() const noexcept;
        std::__cxx11::basic_string<char> &operator+=(const std::__cxx11::basic_string<char> &__str);
        std::__cxx11::basic_string<char> &operator+=(const char *__s);
        std::__cxx11::basic_string<char> &operator+=(char __c);
        std::__cxx11::basic_string<char> &operator+=(initializer_list<char> __l);
        std::__cxx11::basic_string<char> &append(const std::__cxx11::basic_string<char> &__str)         {
            return this->_M_append(__str._M_data(), __str.size());
        }
        std::__cxx11::basic_string<char> &append(const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n);
        std::__cxx11::basic_string<char> &append(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n);
        std::__cxx11::basic_string<char> &append(const char *__s)         {
            ;
            const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n = traits_type::length(__s);
            this->_M_check_length(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type(0), __n, "basic_string::append");
            return this->_M_append(__s, __n);
        }
        std::__cxx11::basic_string<char> &append(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n, char __c);
        std::__cxx11::basic_string<char> &append(initializer_list<char> __l);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char> &append(_InputIterator __first, _InputIterator __last);
        void push_back(char __c);
        std::__cxx11::basic_string<char> &assign(const std::__cxx11::basic_string<char> &__str);
        std::__cxx11::basic_string<char> &assign(std::__cxx11::basic_string<char> &&__str);
        std::__cxx11::basic_string<char> &assign(const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n);
        std::__cxx11::basic_string<char> &assign(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n);
        std::__cxx11::basic_string<char> &assign(const char *__s);
        std::__cxx11::basic_string<char> &assign(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n, char __c);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char> &assign(_InputIterator __first, _InputIterator __last);
        std::__cxx11::basic_string<char> &assign(initializer_list<char> __l);
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator __p, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n, char __c);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator __p, _InputIterator __beg, _InputIterator __end);
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator __p, initializer_list<char> __l);
        std::__cxx11::basic_string<char> &insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos1, const std::__cxx11::basic_string<char> &__str)         {
            return this->replace(__pos1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type(0), __str._M_data(), __str.size());
        }
        std::__cxx11::basic_string<char> &insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos1, const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n);
        std::__cxx11::basic_string<char> &insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n);
        std::__cxx11::basic_string<char> &insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, const char *__s)         {
            ;
            return this->replace(__pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type(0), __s, traits_type::length(__s));
        }
        std::__cxx11::basic_string<char> &insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n, char __c);
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator insert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__const_iterator __p, char __c);
        std::__cxx11::basic_string<char> &erase(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n);
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator erase(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__const_iterator __position);
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator erase(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__const_iterator __first, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__const_iterator __last);
        void pop_back() noexcept;
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n, const std::__cxx11::basic_string<char> &__str);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n1, const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n2);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n1, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n2)         {
            ;
            return this->_M_replace(this->_M_check(__pos, "basic_string::replace"), this->_M_limit(__pos, __n1), __s, __n2);
        }
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n1, const char *__s);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n2, char __c);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__const_iterator __i2, const std::__cxx11::basic_string<char> &__str);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__const_iterator __i2, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__const_iterator __i2, const char *__s);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__const_iterator __i2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n, char __c);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__const_iterator __i2, char *__k1, char *__k2);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__const_iterator __i2, const char *__k1, const char *__k2);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__const_iterator __i2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator __k1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::iterator __k2);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::__const_iterator __i2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator __k1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator __k2);
        std::__cxx11::basic_string<char> &replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator __i2, initializer_list<char> __l);
    private:
        template <class _Integer> std::__cxx11::basic_string<char> &_M_replace_dispatch(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
        template <class _InputIterator> std::__cxx11::basic_string<char> &_M_replace_dispatch(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator __i1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
        std::__cxx11::basic_string<char> &_M_replace_aux(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n2, char __c);
        std::__cxx11::basic_string<char> &_M_replace(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __len1, const char *__s, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __len2);
        std::__cxx11::basic_string<char> &_M_append(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n);
    public:
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type copy(char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos = 0) const;
        void swap(std::__cxx11::basic_string<char> &__s) noexcept;
        const char *c_str() const noexcept         {
            return this->_M_data();
        }
        const char *data() const noexcept         {
            return this->_M_data();
        }
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::allocator_type get_allocator() const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find(const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type rfind(const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type rfind(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type rfind(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos) const;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type rfind(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_of(const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_of(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_of(const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_of(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_not_of(const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_not_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_not_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_first_not_of(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_not_of(const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_not_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_not_of(const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type find_last_not_of(char __c, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<char> substr(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n) const;
        int compare(const std::__cxx11::basic_string<char> &__str) const;
        int compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n, const std::__cxx11::basic_string<char> &__str) const;
        int compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos1, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n1, const std::__cxx11::basic_string<char> &__str, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos2, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n2) const;
        int compare(const char *__s) const noexcept;
        int compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n1, const char *__s) const;
        int compare(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __pos, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n1, const char *__s, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::size_type __n2) const;
        friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
    };
    template<> class basic_string<wchar_t> {
        typedef typename __gnu_cxx::__alloc_traits<allocator<wchar_t> >::rebind<wchar_t>::other _Char_alloc_type;
        typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
    public:
        typedef std::char_traits<wchar_t> traits_type;
        typedef typename char_traits<wchar_t>::char_type value_type;
        typedef std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::_Char_alloc_type allocator_type;
        typedef typename _Alloc_traits::size_type size_type;
        typedef typename _Alloc_traits::difference_type difference_type;
        typedef typename _Alloc_traits::reference reference;
        typedef typename _Alloc_traits::const_reference const_reference;
        typedef typename _Alloc_traits::pointer pointer;
        typedef typename _Alloc_traits::const_pointer const_pointer;
        typedef __gnu_cxx::__normal_iterator<pointer, basic_string<wchar_t> > iterator;
        typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string<wchar_t> > const_iterator;
        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
        typedef std::reverse_iterator<iterator> reverse_iterator;
        static const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type npos = static_cast<std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type>(-1);
    protected:
        typedef std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_iterator __const_iterator;
    private:
        struct _Alloc_hider : std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::allocator_type {
            _Alloc_hider(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::pointer __dat, const std::allocator<wchar_t> &__a) : std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::allocator_type(__a), _M_p(__dat)             {
            }
            _Alloc_hider(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::pointer __dat, std::allocator<wchar_t> &&__a) : std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::allocator_type(std::move(__a)), _M_p(__dat)             {
            }
            std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::pointer _M_p;
        };
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::_Alloc_hider _M_dataplus;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type _M_string_length;
        enum  {
            _S_local_capacity = 15 / sizeof(wchar_t)
        };
        union {
            wchar_t _M_local_buf[4];
            std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type _M_allocated_capacity;
        };
        void _M_data(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::pointer __p)         {
            this->_M_dataplus._M_p = __p;
        }
        void _M_length(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __length)         {
            this->_M_string_length = __length;
        }
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::pointer _M_data() const         {
            return this->_M_dataplus._M_p;
        }
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::pointer _M_local_data()         {
            return std::pointer_traits<pointer>::pointer_to(*this->_M_local_buf);
        }
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_pointer _M_local_data() const         {
            return std::pointer_traits<const_pointer>::pointer_to(*this->_M_local_buf);
        }
        void _M_capacity(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __capacity)         {
            this->_M_allocated_capacity = __capacity;
        }
        void _M_set_length(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n)         {
            this->_M_length(__n);
            traits_type::assign(this->_M_data()[__n], wchar_t());
        }
        bool _M_is_local() const         {
            return this->_M_data() == this->_M_local_data();
        }
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::pointer _M_create(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type &, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type);
        void _M_dispose()         {
            if (!this->_M_is_local())
                this->_M_destroy(this->_M_allocated_capacity);
        }
        void _M_destroy(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __size) throw()         {
            _Alloc_traits::deallocate(this->_M_get_allocator(), this->_M_data(), __size + 1);
        }
        template <typename _InIterator> void _M_construct_aux(_InIterator __beg, _InIterator __end, std::__false_type);
        template<> void _M_construct_aux<wchar_t *>(wchar_t *__beg, wchar_t *__end, std::__false_type)         {
            typedef typename iterator_traits<wchar_t *>::iterator_category _Tag;
            this->_M_construct(__beg, __end, _Tag());
        }
;
        template<> void _M_construct_aux<const wchar_t *>(const wchar_t *__beg, const wchar_t *__end, std::__false_type)         {
            typedef typename iterator_traits<const wchar_t *>::iterator_category _Tag;
            this->_M_construct(__beg, __end, _Tag());
        }
;
        template <typename _Integer> void _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type);
        void _M_construct_aux_2(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __req, wchar_t __c);
        template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end);
        template<> void _M_construct<wchar_t *>(wchar_t *__beg, wchar_t *__end)         {
            typedef typename std::__is_integer<wchar_t *>::__type _Integral;
            this->_M_construct_aux(__beg, __end, _Integral());
        }
;
        template<> void _M_construct<const wchar_t *>(const wchar_t *__beg, const wchar_t *__end)         {
            typedef typename std::__is_integer<const wchar_t *>::__type _Integral;
            this->_M_construct_aux(__beg, __end, _Integral());
        }
;
        template <typename _InIterator> void _M_construct(_InIterator __beg, _InIterator __end, std::input_iterator_tag);
        template<> void _M_construct<wchar_t *>(wchar_t *__beg, wchar_t *__end, std::input_iterator_tag);
        template<> void _M_construct<const wchar_t *>(const wchar_t *__beg, const wchar_t *__end, std::input_iterator_tag);
        template <typename _FwdIterator> void _M_construct(_FwdIterator __beg, _FwdIterator __end, std::forward_iterator_tag);
        template<> void basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >::_M_construct<wchar_t *>(wchar_t *__beg, wchar_t *__end, std::forward_iterator_tag)         {
            if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                std::__throw_logic_error(("basic_string::_M_construct null not valid"));
            std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __dnew = static_cast<std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type>(std::distance(__beg, __end));
            if (__dnew > std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type(_S_local_capacity)) {
                this->_M_data(this->_M_create(__dnew, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type(0)));
                this->_M_capacity(__dnew);
            }
            try {
                this->_S_copy_chars(this->_M_data(), __beg, __end);
            } catch (...) {
                this->_M_dispose();
                throw;
            }
            this->_M_set_length(__dnew);
        }
;
        template<> void basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >::_M_construct<const wchar_t *>(const wchar_t *__beg, const wchar_t *__end, std::forward_iterator_tag)         {
            if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                std::__throw_logic_error(("basic_string::_M_construct null not valid"));
            std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __dnew = static_cast<std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type>(std::distance(__beg, __end));
            if (__dnew > std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type(_S_local_capacity)) {
                this->_M_data(this->_M_create(__dnew, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type(0)));
                this->_M_capacity(__dnew);
            }
            try {
                this->_S_copy_chars(this->_M_data(), __beg, __end);
            } catch (...) {
                this->_M_dispose();
                throw;
            }
            this->_M_set_length(__dnew);
        }
;
        void _M_construct(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __req, wchar_t __c);
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::allocator_type &_M_get_allocator()         {
            return this->_M_dataplus;
        }
        const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::allocator_type &_M_get_allocator() const;
    private:
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type _M_check(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, const char *__s) const;
        void _M_check_length(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n2, const char *__s) const;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type _M_limit(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __off) const noexcept;
        bool _M_disjunct(const wchar_t *__s) const noexcept;
        static void _S_copy(wchar_t *__d, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n)         {
            if (__n == 1)
                traits_type::assign(*__d, *__s);
            else
                traits_type::copy(__d, __s, __n);
        }
        static void _S_move(wchar_t *__d, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n);
        static void _S_assign(wchar_t *__d, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n, wchar_t __c);
        template <class _Iterator> static void _S_copy_chars(wchar_t *__p, _Iterator __k1, _Iterator __k2);
        template<> static void _S_copy_chars<wchar_t *>(wchar_t *__p, wchar_t *__k1, wchar_t *__k2);
        template<> static void _S_copy_chars<const wchar_t *>(wchar_t *__p, const wchar_t *__k1, const wchar_t *__k2);
        static void _S_copy_chars(wchar_t *__p, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::iterator __k1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::iterator __k2) noexcept;
        static void _S_copy_chars(wchar_t *__p, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_iterator __k1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_iterator __k2) noexcept;
        static void _S_copy_chars(wchar_t *__p, wchar_t *__k1, wchar_t *__k2) noexcept         {
            _S_copy(__p, __k1, __k2 - __k1);
        }
        static void _S_copy_chars(wchar_t *__p, const wchar_t *__k1, const wchar_t *__k2) noexcept         {
            _S_copy(__p, __k1, __k2 - __k1);
        }
        static int _S_compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n2) noexcept;
        void _M_assign(const std::__cxx11::basic_string<wchar_t> &);
        void _M_mutate(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __len1, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __len2);
        void _M_erase(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n);
    public:
        basic_string();
        explicit basic_string(const std::allocator<wchar_t> &__a) noexcept;
        basic_string(const std::__cxx11::basic_string<wchar_t> &__str);
        basic_string(const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, const std::allocator<wchar_t> &__a);
        basic_string(const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n);
        basic_string(const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n, const std::allocator<wchar_t> &__a);
        basic_string(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n, const std::allocator<wchar_t> &__a = std::allocator<wchar_t>()) : _M_dataplus(this->_M_local_data(), __a)         {
            this->_M_construct(__s, __s + __n);
        }
        basic_string(const wchar_t *__s, const std::allocator<wchar_t> &__a);
        basic_string(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n, wchar_t __c, const std::allocator<wchar_t> &__a);
        basic_string(std::__cxx11::basic_string<wchar_t> &&__str) noexcept : _M_dataplus(this->_M_local_data(), std::move(__str._M_get_allocator()))         {
            if (__str._M_is_local()) {
                traits_type::copy(this->_M_local_buf, __str._M_local_buf, _S_local_capacity + 1);
            } else {
                this->_M_data(__str._M_data());
                this->_M_capacity(__str._M_allocated_capacity);
            }
            this->_M_length(__str.length());
            __str._M_data(__str._M_local_data());
            __str._M_set_length(0);
        }
        basic_string(initializer_list<wchar_t> __l, const std::allocator<wchar_t> &__a);
        basic_string(const std::__cxx11::basic_string<wchar_t> &__str, const std::allocator<wchar_t> &__a);
        basic_string(std::__cxx11::basic_string<wchar_t> &&__str, const std::allocator<wchar_t> &__a);
        template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>> basic_string(_InputIterator __beg, _InputIterator __end, const std::allocator<wchar_t> &__a);
        template<> basic_string<wchar_t *, void>(wchar_t *__beg, wchar_t *__end, const std::allocator<wchar_t> &__a = std::allocator<wchar_t>()) : _M_dataplus(this->_M_local_data(), __a)         {
            this->_M_construct(__beg, __end);
        }
;
        ~basic_string<wchar_t>() noexcept         {
            this->_M_dispose();
        }
        std::__cxx11::basic_string<wchar_t> &operator=(const std::__cxx11::basic_string<wchar_t> &__str);
        std::__cxx11::basic_string<wchar_t> &operator=(const wchar_t *__s);
        std::__cxx11::basic_string<wchar_t> &operator=(wchar_t __c);
        std::__cxx11::basic_string<wchar_t> &operator=(std::__cxx11::basic_string<wchar_t> &&__str);
        std::__cxx11::basic_string<wchar_t> &operator=(initializer_list<wchar_t> __l);
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::iterator begin() noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_iterator begin() const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::iterator end() noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_iterator end() const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::reverse_iterator rbegin() noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_reverse_iterator rbegin() const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::reverse_iterator rend() noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_reverse_iterator rend() const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_iterator cbegin() const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_iterator cend() const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_reverse_iterator crbegin() const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_reverse_iterator crend() const noexcept;
    public:
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type size() const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type length() const noexcept         {
            return this->_M_string_length;
        }
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type max_size() const noexcept;
        void resize(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n, wchar_t __c);
        void resize(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n);
        void shrink_to_fit() noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type capacity() const noexcept;
        void reserve(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __res_arg);
        void clear() noexcept;
        bool empty() const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_reference operator[](std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::reference operator[](std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos);
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_reference at(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n) const;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::reference at(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n);
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::reference front() noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_reference front() const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::reference back() noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_reference back() const noexcept;
        std::__cxx11::basic_string<wchar_t> &operator+=(const std::__cxx11::basic_string<wchar_t> &__str);
        std::__cxx11::basic_string<wchar_t> &operator+=(const wchar_t *__s);
        std::__cxx11::basic_string<wchar_t> &operator+=(wchar_t __c);
        std::__cxx11::basic_string<wchar_t> &operator+=(initializer_list<wchar_t> __l);
        std::__cxx11::basic_string<wchar_t> &append(const std::__cxx11::basic_string<wchar_t> &__str);
        std::__cxx11::basic_string<wchar_t> &append(const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n);
        std::__cxx11::basic_string<wchar_t> &append(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n);
        std::__cxx11::basic_string<wchar_t> &append(const wchar_t *__s);
        std::__cxx11::basic_string<wchar_t> &append(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n, wchar_t __c);
        std::__cxx11::basic_string<wchar_t> &append(initializer_list<wchar_t> __l);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<wchar_t> &append(_InputIterator __first, _InputIterator __last);
        void push_back(wchar_t __c);
        std::__cxx11::basic_string<wchar_t> &assign(const std::__cxx11::basic_string<wchar_t> &__str);
        std::__cxx11::basic_string<wchar_t> &assign(std::__cxx11::basic_string<wchar_t> &&__str);
        std::__cxx11::basic_string<wchar_t> &assign(const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n);
        std::__cxx11::basic_string<wchar_t> &assign(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n);
        std::__cxx11::basic_string<wchar_t> &assign(const wchar_t *__s);
        std::__cxx11::basic_string<wchar_t> &assign(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n, wchar_t __c);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<wchar_t> &assign(_InputIterator __first, _InputIterator __last);
        std::__cxx11::basic_string<wchar_t> &assign(initializer_list<wchar_t> __l);
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::iterator insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_iterator __p, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n, wchar_t __c);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::iterator insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_iterator __p, _InputIterator __beg, _InputIterator __end);
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::iterator insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_iterator __p, initializer_list<wchar_t> __l);
        std::__cxx11::basic_string<wchar_t> &insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos1, const std::__cxx11::basic_string<wchar_t> &__str);
        std::__cxx11::basic_string<wchar_t> &insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos1, const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n);
        std::__cxx11::basic_string<wchar_t> &insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n);
        std::__cxx11::basic_string<wchar_t> &insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, const wchar_t *__s);
        std::__cxx11::basic_string<wchar_t> &insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n, wchar_t __c);
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::iterator insert(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::__const_iterator __p, wchar_t __c);
        std::__cxx11::basic_string<wchar_t> &erase(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n);
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::iterator erase(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::__const_iterator __position);
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::iterator erase(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::__const_iterator __first, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::__const_iterator __last);
        void pop_back() noexcept;
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n, const std::__cxx11::basic_string<wchar_t> &__str);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n1, const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n2);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n1, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n2);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n1, const wchar_t *__s);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n2, wchar_t __c);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::__const_iterator __i2, const std::__cxx11::basic_string<wchar_t> &__str);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::__const_iterator __i2, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::__const_iterator __i2, const wchar_t *__s);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::__const_iterator __i2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n, wchar_t __c);
        template <class _InputIterator, typename = std::_RequireInputIter<_InputIterator>> std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_iterator __i2, _InputIterator __k1, _InputIterator __k2);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::__const_iterator __i2, wchar_t *__k1, wchar_t *__k2);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::__const_iterator __i2, const wchar_t *__k1, const wchar_t *__k2);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::__const_iterator __i2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::iterator __k1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::iterator __k2);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::__const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::__const_iterator __i2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_iterator __k1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_iterator __k2);
        std::__cxx11::basic_string<wchar_t> &replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_iterator __i2, initializer_list<wchar_t> __l);
    private:
        template <class _Integer> std::__cxx11::basic_string<wchar_t> &_M_replace_dispatch(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_iterator __i2, _Integer __n, _Integer __val, std::__true_type);
        template <class _InputIterator> std::__cxx11::basic_string<wchar_t> &_M_replace_dispatch(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_iterator __i1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, std::__false_type);
        std::__cxx11::basic_string<wchar_t> &_M_replace_aux(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n2, wchar_t __c);
        std::__cxx11::basic_string<wchar_t> &_M_replace(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __len1, const wchar_t *__s, const std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __len2);
        std::__cxx11::basic_string<wchar_t> &_M_append(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n);
    public:
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type copy(wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos) const;
        void swap(std::__cxx11::basic_string<wchar_t> &__s) noexcept;
        const wchar_t *c_str() const noexcept         {
            return this->_M_data();
        }
        const wchar_t *data() const noexcept         {
            return this->_M_data();
        }
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::allocator_type get_allocator() const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type find(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type find(const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type find(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type find(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type rfind(const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type rfind(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type rfind(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos) const;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type rfind(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type find_first_of(const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type find_first_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type find_first_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type find_first_of(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type find_last_of(const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type find_last_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type find_last_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type find_last_of(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type find_first_not_of(const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type find_first_not_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type find_first_not_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type find_first_not_of(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type find_last_not_of(const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type find_last_not_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type find_last_not_of(const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type find_last_not_of(wchar_t __c, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos) const noexcept;
        std::__cxx11::basic_string<wchar_t> substr(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n) const;
        int compare(const std::__cxx11::basic_string<wchar_t> &__str) const;
        int compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n, const std::__cxx11::basic_string<wchar_t> &__str) const;
        int compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos1, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n1, const std::__cxx11::basic_string<wchar_t> &__str, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos2, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n2) const;
        int compare(const wchar_t *__s) const noexcept;
        int compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n1, const wchar_t *__s) const;
        int compare(std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __pos, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n1, const wchar_t *__s, std::__cxx11::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::size_type __n2) const;
        friend template <typename, typename = char_traits<_CharT>, typename = allocator<_CharT>> class basic_stringbuf;
    };
}
namespace std {
    class locale {
    public:
        typedef int category;
        class facet;
        class id;
        class _Impl;
        friend  class facet;
        friend  class _Impl;
        friend template <typename _Facet> bool has_facet(const std::locale &) throw();
        friend template <typename _Facet> const _Facet &use_facet(const std::locale &);
        friend template <typename _Cache> struct __use_cache;
        static const std::locale::category none = 0;
        static const std::locale::category ctype = 1L << 0;
        static const std::locale::category numeric = 1L << 1;
        static const std::locale::category collate = 1L << 2;
        static const std::locale::category time = 1L << 3;
        static const std::locale::category monetary = 1L << 4;
        static const std::locale::category messages = 1L << 5;
        static const std::locale::category all = (ctype | numeric | collate | time | monetary | messages);
        locale() throw();
        locale(const std::locale &__other) throw();
        explicit locale(const char *__s);
        locale(const std::locale &__base, const char *__s, std::locale::category __cat);
        explicit locale(const std::string &__s) : NULL TYPE(__s.c_str())         {
        }
        locale(const std::locale &__base, const std::string &__s, std::locale::category __cat) : NULL TYPE(__base, __s.c_str(), __cat)         {
        }
        locale(const std::locale &__base, const std::locale &__add, std::locale::category __cat);
        template <typename _Facet> locale(const std::locale &__other, _Facet *__f);
        ~locale() throw();
        const std::locale &operator=(const std::locale &__other) throw();
        template <typename _Facet> std::locale combine(const std::locale &__other) const;
        std::string name() const __attribute__((abi_tag("cxx11")));
        bool operator==(const std::locale &__other) const throw();
        bool operator!=(const std::locale &__other) const throw()         {
            return !(this->operator==(__other));
        }
        template <typename _Char, typename _Traits, typename _Alloc> bool operator()(const basic_string<_Char, _Traits, _Alloc> &__s1, const basic_string<_Char, _Traits, _Alloc> &__s2) const;
        static std::locale global(const std::locale &__loc);
        static const std::locale &classic();
    private:
        std::locale::_Impl *_M_impl;
        static std::locale::_Impl *_S_classic;
        static std::locale::_Impl *_S_global;
        static const char *const *const _S_categories;
        enum  {
            _S_categories_size = 6 + 6
        };
        static __gthread_once_t _S_once;
        explicit locale(std::locale::_Impl *) throw();
        static void _S_initialize();
        static void _S_initialize_once() throw();
        static std::locale::category _S_normalize_category(std::locale::category);
        void _M_coalesce(const std::locale &__base, const std::locale &__add, std::locale::category __cat);
        static const std::locale::id *const _S_twinned_facets[];
    };
    class facet {
    private:
        friend  class locale;
        friend  class locale::_Impl;
        mutable _Atomic_word _M_refcount;
        static std::__c_locale _S_c_locale;
        static const char _S_c_name[2];
        static __gthread_once_t _S_once;
        static void _S_initialize_once();
    protected:
        explicit facet(std::size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)         {
        }
        virtual ~facet() noexcept;
        static void _S_create_c_locale(std::__c_locale &__cloc, const char *__s, std::__c_locale __old = 0);
        static std::__c_locale _S_clone_c_locale(std::__c_locale &__cloc) throw();
        static void _S_destroy_c_locale(std::__c_locale &__cloc);
        static std::__c_locale _S_lc_ctype_c_locale(std::__c_locale __cloc, const char *__s);
        static std::__c_locale _S_get_c_locale();
        static const char *_S_get_c_name() throw() __attribute__((const));
        facet(const std::locale::facet &) = delete
        std::locale::facet &operator=(const std::locale::facet &) = delete
    private:
        void _M_add_reference() const throw()         {
            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
        }
        void _M_remove_reference() const throw()         {
            ;
            if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1) == 1) {
                ;
                try {
                    delete this;
                } catch (...) {
                }
            }
        }
        const std::locale::facet *_M_sso_shim(const std::locale::id *) const;
        const std::locale::facet *_M_cow_shim(const std::locale::id *) const;
    protected:
        class __shim;
    };
    class id {
    private:
        friend  class locale;
        friend  class locale::_Impl;
        friend template <typename _Facet> const _Facet &use_facet(const std::locale &);
        friend template <typename _Facet> bool has_facet(const std::locale &) throw();
        mutable std::size_t _M_index;
        static _Atomic_word _S_refcount;
        void operator=(const std::locale::id &);
        id(const std::locale::id &);
    public:
        id()         {
        }
        std::size_t _M_id() const throw();
    };
    class _Impl {
    public:
        friend  class locale;
        friend  class locale::facet;
        friend template <typename _Facet> bool has_facet(const std::locale &) throw();
        friend template <typename _Facet> const _Facet &use_facet(const std::locale &);
        friend template <typename _Cache> struct __use_cache;
    private:
        _Atomic_word _M_refcount;
        const std::locale::facet **_M_facets;
        std::size_t _M_facets_size;
        const std::locale::facet **_M_caches;
        char **_M_names;
        static const locale::id *const _S_id_ctype[];
        static const locale::id *const _S_id_numeric[];
        static const locale::id *const _S_id_collate[];
        static const locale::id *const _S_id_time[];
        static const locale::id *const _S_id_monetary[];
        static const locale::id *const _S_id_messages[];
        static const locale::id *const *const _S_facet_categories[];
        void _M_add_reference() throw()         {
            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
        }
        void _M_remove_reference() throw()         {
            ;
            if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1) == 1) {
                ;
                try {
                    delete this;
                } catch (...) {
                }
            }
        }
        _Impl(const std::locale::_Impl &, std::size_t);
        _Impl(const char *, std::size_t);
        _Impl(std::size_t) throw();
        ~_Impl() throw();
        _Impl(const std::locale::_Impl &);
        void operator=(const std::locale::_Impl &);
        bool _M_check_same_name()         {
            bool __ret = true;
            if (this->_M_names[1])
                for (std::size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
                    __ret = __builtin_strcmp(this->_M_names[__i], this->_M_names[__i + 1]) == 0;
            return __ret;
        }
        void _M_replace_categories(const std::locale::_Impl *, std::locale::category);
        void _M_replace_category(const std::locale::_Impl *, const locale::id *const *);
        void _M_replace_facet(const std::locale::_Impl *, const locale::id *);
        void _M_install_facet(const locale::id *, const std::locale::facet *);
        template <typename _Facet> void _M_init_facet(_Facet *__facet)         {
            this->_M_install_facet(&_Facet::id, __facet);
        }
        template <typename _Facet> void _M_init_facet_unchecked(_Facet *__facet)         {
            __facet->_M_add_reference();
            this->_M_facets[_Facet::id._M_id()] = __facet;
        }
        void _M_install_cache(const std::locale::facet *, std::size_t);
        void _M_init_extra(std::locale::facet **);
        void _M_init_extra(void *, void *, const char *, const char *);
    };
    template <typename _CharT> class collate : public locale::facet {
    public:
        typedef _CharT char_type;
        typedef basic_string<_CharT> string_type;
    protected:
        std::__c_locale _M_c_locale_collate;
    public:
        static locale::id id;
        explicit collate<_CharT>(std::size_t __refs = 0) : std::locale::facet(__refs), _M_c_locale_collate(_S_get_c_locale())         {
        }
        explicit collate<_CharT>(std::__c_locale __cloc, std::size_t __refs = 0) : std::locale::facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))         {
        }
        int compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const         {
            return this->do_compare(__lo1, __hi1, __lo2, __hi2);
        }
        std::__cxx11::collate::string_type transform(const _CharT *__lo, const _CharT *__hi) const         {
            return this->do_transform(__lo, __hi);
        }
        long hash(const _CharT *__lo, const _CharT *__hi) const         {
            return this->do_hash(__lo, __hi);
        }
        int _M_compare(const _CharT *, const _CharT *) const throw();
        std::size_t _M_transform(_CharT *, const _CharT *, std::size_t) const throw();
    protected:
        virtual ~collate<_CharT>()         {
            _S_destroy_c_locale(this->_M_c_locale_collate);
        }
        virtual int do_compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const;
        virtual std::__cxx11::collate::string_type do_transform(const _CharT *__lo, const _CharT *__hi) const;
        virtual long do_hash(const _CharT *__lo, const _CharT *__hi) const;
    };
    locale::id id;
    template <> int collate<char>::_M_compare(const char *, const char *) const throw();
    template <> std::size_t collate<char>::_M_transform(char *, const char *, std::size_t) const throw();
    template <> int collate<wchar_t>::_M_compare(const wchar_t *, const wchar_t *) const throw();
    template <> std::size_t collate<wchar_t>::_M_transform(wchar_t *, const wchar_t *, std::size_t) const throw();
    template <typename _CharT> class collate_byname : public collate<_CharT> {
    public:
        typedef _CharT char_type;
        typedef basic_string<_CharT> string_type;
        explicit collate_byname<_CharT>(const char *__s, std::size_t __refs = 0) : collate<_CharT>(__refs)         {
            if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0) {
                this->_S_destroy_c_locale(this->_M_c_locale_collate);
                this->_S_create_c_locale(this->_M_c_locale_collate, __s);
            }
        }
        explicit collate_byname<_CharT>(const std::string &__s, std::size_t __refs = 0) : collate_byname<_CharT>(__s.c_str(), __refs)         {
        }
    protected:
        virtual ~collate_byname<_CharT>()         {
        }
    };
}
namespace std {
    template <typename _Facet> locale::locale(const std::locale &__other, _Facet *__f)     {
        this->_M_impl = new std::locale::_Impl(*__other._M_impl, 1);
        try {
            this->_M_impl->_M_install_facet(&_Facet::id, __f);
        } catch (...) {
            this->_M_impl->_M_remove_reference();
            throw;
        }
        delete [] this->_M_impl->_M_names[0];
        this->_M_impl->_M_names[0] = 0;
    }
    template <typename _Facet> std::locale locale::combine(const std::locale &__other) const     {
        std::locale::_Impl *__tmp = new std::locale::_Impl(*this->_M_impl, 1);
        try {
            __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
        } catch (...) {
            __tmp->_M_remove_reference();
            throw;
        }
        return std::locale(__tmp);
    }
    template <typename _CharT, typename _Traits, typename _Alloc> bool locale::operator()(const basic_string<_CharT, _Traits, _Alloc> &__s1, const basic_string<_CharT, _Traits, _Alloc> &__s2) const     {
        typedef std::collate<_CharT> __collate_type;
        const __collate_type &__collate = use_facet<__collate_type>(*this);
        return (__collate.compare(__s1.data(), __s1.data() + __s1.length(), __s2.data(), __s2.data() + __s2.length()) < 0);
    }
    template <typename _Facet> bool has_facet(const std::locale &__loc) throw()     {
        const std::size_t __i = _Facet::id._M_id();
        const locale::facet **__facets = __loc._M_impl->_M_facets;
        return (__i < __loc._M_impl->_M_facets_size && dynamic_cast<const _Facet *>(__facets[__i]));
    }
    template <typename _Facet> const _Facet &use_facet(const std::locale &__loc)     {
        const std::size_t __i = _Facet::id._M_id();
        const locale::facet **__facets = __loc._M_impl->_M_facets;
        if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
            __throw_bad_cast();
        return dynamic_cast<const _Facet &>(*__facets[__i]);
    }
    template <typename _CharT> int collate<_CharT>::_M_compare(const _CharT *, const _CharT *) const throw()     {
        return 0;
    }
    template <typename _CharT> std::size_t collate<_CharT>::_M_transform(_CharT *, const _CharT *, std::size_t) const throw()     {
        return 0;
    }
    template <typename _CharT> int collate<_CharT>::do_compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const     {
        const std::__cxx11::collate::string_type __one(__lo1, __hi1);
        const std::__cxx11::collate::string_type __two(__lo2, __hi2);
        const _CharT *__p = __one.c_str();
        const _CharT *__pend = __one.data() + __one.length();
        const _CharT *__q = __two.c_str();
        const _CharT *__qend = __two.data() + __two.length();
        for (;;) {
            const int __res = this->_M_compare(__p, __q);
            if (__res)
                return __res;
            __p += char_traits<_CharT>::length(__p);
            __q += char_traits<_CharT>::length(__q);
            if (__p == __pend && __q == __qend)
                return 0;
            else if (__p == __pend)
                return -1;
            else if (__q == __qend)
                return 1;
            __p++;
            __q++;
        }
    }
    template <typename _CharT> typename collate<_CharT>::string_type collate<_CharT>::do_transform(const _CharT *__lo, const _CharT *__hi) const     {
        std::__cxx11::collate::string_type __ret;
        const std::__cxx11::collate::string_type __str(__lo, __hi);
        const _CharT *__p = __str.c_str();
        const _CharT *__pend = __str.data() + __str.length();
        std::size_t __len = (__hi - __lo) * 2;
        _CharT *__c = new _CharT [__len];
        try {
            for (;;) {
                std::size_t __res = this->_M_transform(__c, __p, __len);
                if (__res >= __len) {
                    __len = __res + 1;
                    delete [] __c , __c = 0;
                    __c = new _CharT [__len];
                    __res = this->_M_transform(__c, __p, __len);
                }
                __ret.append(__c, __res);
                __p += char_traits<_CharT>::length(__p);
                if (__p == __pend)
                    break;
                __p++;
                __ret.push_back(_CharT());
            }
        } catch (...) {
            delete [] __c;
            throw;
        }
        delete [] __c;
        return __ret;
    }
    template <typename _CharT> long collate<_CharT>::do_hash(const _CharT *__lo, const _CharT *__hi) const     {
        unsigned long __val = 0;
        for (; __lo < __hi; ++__lo)
            __val = *__lo + ((__val << 7) | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::__digits - 7)));
        return static_cast<long>(__val);
    }
    template<> class collate<char> : public locale::facet {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
    protected:
        std::__c_locale _M_c_locale_collate;
    public:
        static locale::id id;
        explicit collate(std::size_t __refs);
        explicit collate(std::__c_locale __cloc, std::size_t __refs);
        int compare(const char *__lo1, const char *__hi1, const char *__lo2, const char *__hi2) const;
        std::__cxx11::collate<char>::string_type transform(const char *__lo, const char *__hi) const;
        long hash(const char *__lo, const char *__hi) const;
        int _M_compare(const char *, const char *) const throw();
        std::size_t _M_transform(char *, const char *, std::size_t) const throw();
    protected:
        virtual ~collate<char>() noexcept;
        virtual int do_compare(const char *__lo1, const char *__hi1, const char *__lo2, const char *__hi2) const;
        virtual std::__cxx11::collate<char>::string_type do_transform(const char *__lo, const char *__hi) const;
        virtual long do_hash(const char *__lo, const char *__hi) const;
    };
    template<> class collate_byname<char> : public collate<char> {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
        explicit collate_byname(const char *__s, std::size_t __refs);
        explicit collate_byname(const std::string &__s, std::size_t __refs);
    protected:
        virtual ~collate_byname<char>() noexcept;
    };
    template<> class collate<wchar_t> : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
    protected:
        std::__c_locale _M_c_locale_collate;
    public:
        static locale::id id;
        explicit collate(std::size_t __refs);
        explicit collate(std::__c_locale __cloc, std::size_t __refs);
        int compare(const wchar_t *__lo1, const wchar_t *__hi1, const wchar_t *__lo2, const wchar_t *__hi2) const;
        std::__cxx11::collate<wchar_t>::string_type transform(const wchar_t *__lo, const wchar_t *__hi) const;
        long hash(const wchar_t *__lo, const wchar_t *__hi) const;
        int _M_compare(const wchar_t *, const wchar_t *) const throw();
        std::size_t _M_transform(wchar_t *, const wchar_t *, std::size_t) const throw();
    protected:
        virtual ~collate<wchar_t>() noexcept;
        virtual int do_compare(const wchar_t *__lo1, const wchar_t *__hi1, const wchar_t *__lo2, const wchar_t *__hi2) const;
        virtual std::__cxx11::collate<wchar_t>::string_type do_transform(const wchar_t *__lo, const wchar_t *__hi) const;
        virtual long do_hash(const wchar_t *__lo, const wchar_t *__hi) const;
    };
    template<> class collate_byname<wchar_t> : public collate<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
        explicit collate_byname(const char *__s, std::size_t __refs);
        explicit collate_byname(const std::string &__s, std::size_t __refs);
    protected:
        virtual ~collate_byname<wchar_t>() noexcept;
    };
}
namespace std {
    enum class errc : int {
        address_family_not_supported = 97,
        address_in_use = 98,
        address_not_available = 99,
        already_connected = 106,
        argument_list_too_long = 7,
        argument_out_of_domain = 33,
        bad_address = 14,
        bad_file_descriptor = 9,
        bad_message = 74,
        broken_pipe = 32,
        connection_aborted = 103,
        connection_already_in_progress = 114,
        connection_refused = 111,
        connection_reset = 104,
        cross_device_link = 18,
        destination_address_required = 89,
        device_or_resource_busy = 16,
        directory_not_empty = 39,
        executable_format_error = 8,
        file_exists = 17,
        file_too_large = 27,
        filename_too_long = 36,
        function_not_supported = 38,
        host_unreachable = 113,
        identifier_removed = 43,
        illegal_byte_sequence = 84,
        inappropriate_io_control_operation = 25,
        interrupted = 4,
        invalid_argument = 22,
        invalid_seek = 29,
        io_error = 5,
        is_a_directory = 21,
        message_size = 90,
        network_down = 100,
        network_reset = 102,
        network_unreachable = 101,
        no_buffer_space = 105,
        no_child_process = 10,
        no_link = 67,
        no_lock_available = 37,
        no_message_available = 61,
        no_message = 42,
        no_protocol_option = 92,
        no_space_on_device = 28,
        no_stream_resources = 63,
        no_such_device_or_address = 6,
        no_such_device = 19,
        no_such_file_or_directory = 2,
        no_such_process = 3,
        not_a_directory = 20,
        not_a_socket = 88,
        not_a_stream = 60,
        not_connected = 107,
        not_enough_memory = 12,
        not_supported = 95,
        operation_canceled = 125,
        operation_in_progress = 115,
        operation_not_permitted = 1,
        operation_not_supported = 95,
        operation_would_block = 11,
        owner_dead = 130,
        permission_denied = 13,
        protocol_error = 71,
        protocol_not_supported = 93,
        read_only_file_system = 30,
        resource_deadlock_would_occur = 35,
        resource_unavailable_try_again = 11,
        result_out_of_range = 34,
        state_not_recoverable = 131,
        stream_timeout = 62,
        text_file_busy = 26,
        timed_out = 110,
        too_many_files_open_in_system = 23,
        too_many_files_open = 24,
        too_many_links = 31,
        too_many_symbolic_link_levels = 40,
        value_too_large = 75,
        wrong_protocol_type = 91
    };
}
namespace std {
    struct __cow_string {
        union {
            const char *_M_p;
            char _M_bytes[8];
        };
        __cow_string();
        __cow_string(const std::string &);
        __cow_string(const char *, std::size_t);
        __cow_string(const std::__cow_string &) noexcept;
        std::__cow_string &operator=(const std::__cow_string &) noexcept;
        ~__cow_string();
        __cow_string(std::__cow_string &&) noexcept;
        std::__cow_string &operator=(std::__cow_string &&) noexcept;
    };
    typedef basic_string<char> __sso_string;
    class logic_error : public std::exception {
        std::__cow_string _M_msg;
    public:
        explicit logic_error(const std::string &__arg);
        explicit logic_error(const char *);
        logic_error(std::logic_error &&) noexcept;
        std::logic_error &operator=(std::logic_error &&) noexcept;
        logic_error(const std::logic_error &) noexcept;
        std::logic_error &operator=(const std::logic_error &) noexcept;
        virtual ~logic_error() noexcept;
        virtual const char *what() const noexcept;
    };
    class domain_error : public std::logic_error {
    public:
        explicit domain_error(const std::string &__arg);
        explicit domain_error(const char *);
        domain_error(const std::domain_error &) = default
        std::domain_error &operator=(const std::domain_error &) = default
        domain_error(std::domain_error &&) = default
        std::domain_error &operator=(std::domain_error &&) = default
        virtual ~domain_error() noexcept;
    };
    class invalid_argument : public std::logic_error {
    public:
        explicit invalid_argument(const std::string &__arg);
        explicit invalid_argument(const char *);
        invalid_argument(const std::invalid_argument &) = default
        std::invalid_argument &operator=(const std::invalid_argument &) = default
        invalid_argument(std::invalid_argument &&) = default
        std::invalid_argument &operator=(std::invalid_argument &&) = default
        virtual ~invalid_argument() noexcept;
    };
    class length_error : public std::logic_error {
    public:
        explicit length_error(const std::string &__arg);
        explicit length_error(const char *);
        length_error(const std::length_error &) = default
        std::length_error &operator=(const std::length_error &) = default
        length_error(std::length_error &&) = default
        std::length_error &operator=(std::length_error &&) = default
        virtual ~length_error() noexcept;
    };
    class out_of_range : public std::logic_error {
    public:
        explicit out_of_range(const std::string &__arg);
        explicit out_of_range(const char *);
        out_of_range(const std::out_of_range &) = default
        std::out_of_range &operator=(const std::out_of_range &) = default
        out_of_range(std::out_of_range &&) = default
        std::out_of_range &operator=(std::out_of_range &&) = default
        virtual ~out_of_range() noexcept;
    };
    class runtime_error : public std::exception {
        std::__cow_string _M_msg;
    public:
        explicit runtime_error(const std::string &__arg);
        explicit runtime_error(const char *);
        runtime_error(std::runtime_error &&) noexcept;
        std::runtime_error &operator=(std::runtime_error &&) noexcept;
        runtime_error(const std::runtime_error &) noexcept;
        std::runtime_error &operator=(const std::runtime_error &) noexcept;
        virtual ~runtime_error() noexcept;
        virtual const char *what() const noexcept;
    };
    class range_error : public std::runtime_error {
    public:
        explicit range_error(const std::string &__arg);
        explicit range_error(const char *);
        range_error(const std::range_error &) = default
        std::range_error &operator=(const std::range_error &) = default
        range_error(std::range_error &&) = default
        std::range_error &operator=(std::range_error &&) = default
        virtual ~range_error() noexcept;
    };
    class overflow_error : public std::runtime_error {
    public:
        explicit overflow_error(const std::string &__arg);
        explicit overflow_error(const char *);
        overflow_error(const std::overflow_error &) = default
        std::overflow_error &operator=(const std::overflow_error &) = default
        overflow_error(std::overflow_error &&) = default
        std::overflow_error &operator=(std::overflow_error &&) = default
        virtual ~overflow_error() noexcept;
    };
    class underflow_error : public std::runtime_error {
    public:
        explicit underflow_error(const std::string &__arg);
        explicit underflow_error(const char *);
        underflow_error(const std::underflow_error &) = default
        std::underflow_error &operator=(const std::underflow_error &) = default
        underflow_error(std::underflow_error &&) = default
        std::underflow_error &operator=(std::underflow_error &&) = default
        virtual ~underflow_error() noexcept;
    };
}
namespace std {
    class error_code;
    class error_condition;
    class system_error;
    template <typename _Tp> struct is_error_code_enum : public std::false_type {
    };
template<> struct is_error_code_enum<std::error_code> : public std::false_type {
    };
template<> struct is_error_code_enum<std::_V2::error_category> : public std::false_type {
    };
template<> struct is_error_code_enum<int> : public std::false_type {
    };
template<> struct is_error_code_enum<std::error_condition> : public std::false_type {
    };
template<> struct is_error_code_enum<const char *> : public std::false_type {
    };
    template <typename _Tp> struct is_error_condition_enum : public std::false_type {
    };
template<> struct is_error_condition_enum<std::error_condition> : public std::false_type {
    };
template<> struct is_error_condition_enum<std::_V2::error_category> : public std::false_type {
    };
template<> struct is_error_condition_enum<std::error_code> : public std::false_type {
    };
    template<> struct is_error_condition_enum<std::errc> : public std::true_type {
    };
    inline namespace _V2 {
        class error_category {
        public:
            error_category() noexcept = default
            virtual ~error_category();
            error_category(const std::_V2::error_category &) = delete
            std::_V2::error_category &operator=(const std::_V2::error_category &) = delete
            virtual const char *name() const noexcept = 0;
        private:
            virtual std::__cow_string _M_message(int) const __attribute__((abi_tag("cxx11")));
        public:
            virtual std::string message(int) const __attribute__((abi_tag("cxx11"))) = 0;
        public:
            virtual std::error_condition default_error_condition(int __i) const noexcept;
            virtual bool equivalent(int __i, const std::error_condition &__cond) const noexcept;
            virtual bool equivalent(const std::error_code &__code, int __i) const noexcept;
            bool operator<(const std::_V2::error_category &__other) const noexcept             {
                return less<const std::_V2::error_category *>()(this, &__other);
            }
            bool operator==(const std::_V2::error_category &__other) const noexcept             {
                return this == &__other;
            }
            bool operator!=(const std::_V2::error_category &__other) const noexcept             {
                return this != &__other;
            }
        };
        const std::_V2::error_category &system_category() noexcept __attribute__((const));
        const std::_V2::error_category &generic_category() noexcept __attribute__((const));
    }
    std::error_code make_error_code(std::errc) noexcept;
    template <typename _Tp> struct hash;
    struct error_code {
        error_code() noexcept : _M_value(0), _M_cat(&system_category())         {
        }
        error_code(int __v, const std::_V2::error_category &__cat) noexcept : _M_value(__v), _M_cat(&__cat)         {
        }
        template <typename _ErrorCodeEnum, typename = typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value>::type> error_code(_ErrorCodeEnum __e) noexcept         {
            *this = make_error_code(__e);
        }
        template<> error_code<std::io_errc, void>(std::io_errc __e) noexcept        void assign(int __v, const std::_V2::error_category &__cat) noexcept         {
            this->_M_value = __v;
            this->_M_cat = &__cat;
        }
        void clear() noexcept         {
            this->assign(0, system_category());
        }
        template <typename _ErrorCodeEnum> typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value, error_code &>::type operator=(_ErrorCodeEnum __e) noexcept         {
            return *this = make_error_code(__e);
        }
        int value() const noexcept         {
            return this->_M_value;
        }
        const std::_V2::error_category &category() const noexcept         {
            return *this->_M_cat;
        }
        std::error_condition default_error_condition() const noexcept;
        std::string message() const __attribute__((abi_tag("cxx11")))         {
            return this->category().message(this->value());
        }
        explicit operator bool() const noexcept         {
            return this->_M_value != 0;
        }
    private:
        friend  class hash<error_code>;
        int _M_value;
        const std::_V2::error_category *_M_cat;
    };
    inline std::error_code make_error_code(std::errc __e) noexcept     {
        return std::error_code(static_cast<int>(__e), generic_category());
    }
    inline bool operator<(const std::error_code &__lhs, const std::error_code &__rhs) noexcept     {
        return (__lhs.category() < __rhs.category() || (__lhs.category() == __rhs.category() && __lhs.value() < __rhs.value()));
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os, const std::error_code &__e)     {
        return (__os << __e.category().name() << ':' << __e.value());
    }
    std::error_condition make_error_condition(std::errc) noexcept;
    struct error_condition {
        error_condition() noexcept : _M_value(0), _M_cat(&generic_category())         {
        }
        error_condition(int __v, const std::_V2::error_category &__cat) noexcept : _M_value(__v), _M_cat(&__cat)         {
        }
        template <typename _ErrorConditionEnum, typename = typename enable_if<is_error_condition_enum<_ErrorConditionEnum>::value>::type> error_condition(_ErrorConditionEnum __e) noexcept         {
            *this = make_error_condition(__e);
        }
        void assign(int __v, const std::_V2::error_category &__cat) noexcept         {
            this->_M_value = __v;
            this->_M_cat = &__cat;
        }
        template <typename _ErrorConditionEnum> typename enable_if<is_error_condition_enum<_ErrorConditionEnum>::value, error_condition &>::type operator=(_ErrorConditionEnum __e) noexcept         {
            return *this = make_error_condition(__e);
        }
        void clear() noexcept         {
            this->assign(0, generic_category());
        }
        int value() const noexcept         {
            return this->_M_value;
        }
        const std::_V2::error_category &category() const noexcept         {
            return *this->_M_cat;
        }
        std::string message() const __attribute__((abi_tag("cxx11")))         {
            return this->category().message(this->value());
        }
        explicit operator bool() const noexcept         {
            return this->_M_value != 0;
        }
    private:
        int _M_value;
        const std::_V2::error_category *_M_cat;
    };
    inline std::error_condition make_error_condition(std::errc __e) noexcept     {
        return std::error_condition(static_cast<int>(__e), generic_category());
    }
    inline bool operator<(const std::error_condition &__lhs, const std::error_condition &__rhs) noexcept     {
        return (__lhs.category() < __rhs.category() || (__lhs.category() == __rhs.category() && __lhs.value() < __rhs.value()));
    }
    inline bool operator==(const std::error_code &__lhs, const std::error_code &__rhs) noexcept     {
        return (__lhs.category() == __rhs.category() && __lhs.value() == __rhs.value());
    }
    inline bool operator==(const std::error_code &__lhs, const std::error_condition &__rhs) noexcept     {
        return (__lhs.category().equivalent(__lhs.value(), __rhs) || __rhs.category().equivalent(__lhs, __rhs.value()));
    }
    inline bool operator==(const std::error_condition &__lhs, const std::error_code &__rhs) noexcept     {
        return (__rhs.category().equivalent(__rhs.value(), __lhs) || __lhs.category().equivalent(__rhs, __lhs.value()));
    }
    inline bool operator==(const std::error_condition &__lhs, const std::error_condition &__rhs) noexcept     {
        return (__lhs.category() == __rhs.category() && __lhs.value() == __rhs.value());
    }
    inline bool operator!=(const std::error_code &__lhs, const std::error_code &__rhs) noexcept     {
        return !(__lhs == __rhs);
    }
    inline bool operator!=(const std::error_code &__lhs, const std::error_condition &__rhs) noexcept     {
        return !(__lhs == __rhs);
    }
    inline bool operator!=(const std::error_condition &__lhs, const std::error_code &__rhs) noexcept     {
        return !(__lhs == __rhs);
    }
    inline bool operator!=(const std::error_condition &__lhs, const std::error_condition &__rhs) noexcept     {
        return !(__lhs == __rhs);
    }
    class system_error : public std::runtime_error {
    private:
        std::error_code _M_code;
    public:
        system_error(std::error_code __ec = std::error_code()) : std::runtime_error(__ec.message()), _M_code(__ec)         {
        }
        system_error(std::error_code __ec, const std::string &__what) : std::runtime_error(__what + ": " + __ec.message()), _M_code(__ec)         {
        }
        system_error(std::error_code __ec, const char *__what) : std::runtime_error(__what + (": " + __ec.message())), _M_code(__ec)         {
        }
        system_error(int __v, const std::_V2::error_category &__ecat, const char *__what) : NULL TYPE(std::error_code(__v, __ecat), __what)         {
        }
        system_error(int __v, const std::_V2::error_category &__ecat) : std::runtime_error(std::error_code(__v, __ecat).message()), _M_code(__v, __ecat)         {
        }
        system_error(int __v, const std::_V2::error_category &__ecat, const std::string &__what) : std::runtime_error(__what + ": " + std::error_code(__v, __ecat).message()), _M_code(__v, __ecat)         {
        }
        system_error(const std::system_error &) = default
        std::system_error &operator=(const std::system_error &) = default
        virtual ~system_error() noexcept;
        const std::error_code &code() const noexcept         {
            return this->_M_code;
        }
    };
}
namespace std {
    template<> struct hash<std::error_code> : public __hash_base<std::size_t, std::error_code> {
        std::size_t operator()(const std::error_code &__e) const noexcept         {
            const std::size_t __tmp = std::_Hash_impl::hash(__e._M_value);
            return std::_Hash_impl::__hash_combine(__e._M_cat, __tmp);
        }
    };
}
namespace std {
    enum _Ios_Fmtflags {
        _S_boolalpha = 1L << 0,
        _S_dec = 1L << 1,
        _S_fixed = 1L << 2,
        _S_hex = 1L << 3,
        _S_internal = 1L << 4,
        _S_left = 1L << 5,
        _S_oct = 1L << 6,
        _S_right = 1L << 7,
        _S_scientific = 1L << 8,
        _S_showbase = 1L << 9,
        _S_showpoint = 1L << 10,
        _S_showpos = 1L << 11,
        _S_skipws = 1L << 12,
        _S_unitbuf = 1L << 13,
        _S_uppercase = 1L << 14,
        _S_adjustfield = _S_left | _S_right | _S_internal,
        _S_basefield = _S_dec | _S_oct | _S_hex,
        _S_floatfield = _S_scientific | _S_fixed,
        _S_ios_fmtflags_end = 1L << 16,
        _S_ios_fmtflags_max = 2147483647,
        _S_ios_fmtflags_min = ~2147483647
    };
    inline constexpr std::_Ios_Fmtflags operator&(std::_Ios_Fmtflags __a, std::_Ios_Fmtflags __b)     {
        return std::_Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Fmtflags operator|(std::_Ios_Fmtflags __a, std::_Ios_Fmtflags __b)     {
        return std::_Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Fmtflags operator^(std::_Ios_Fmtflags __a, std::_Ios_Fmtflags __b)     {
        return std::_Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Fmtflags operator~(std::_Ios_Fmtflags __a)     {
        return std::_Ios_Fmtflags(~static_cast<int>(__a));
    }
    inline const std::_Ios_Fmtflags &operator|=(std::_Ios_Fmtflags &__a, std::_Ios_Fmtflags __b)     {
        return __a = __a | __b;
    }
    inline const std::_Ios_Fmtflags &operator&=(std::_Ios_Fmtflags &__a, std::_Ios_Fmtflags __b)     {
        return __a = __a & __b;
    }
    inline const std::_Ios_Fmtflags &operator^=(std::_Ios_Fmtflags &__a, std::_Ios_Fmtflags __b)     {
        return __a = __a ^ __b;
    }
    enum _Ios_Openmode {
        _S_app = 1L << 0,
        _S_ate = 1L << 1,
        _S_bin = 1L << 2,
        _S_in = 1L << 3,
        _S_out = 1L << 4,
        _S_trunc = 1L << 5,
        _S_ios_openmode_end = 1L << 16,
        _S_ios_openmode_max = 2147483647,
        _S_ios_openmode_min = ~2147483647
    };
    inline constexpr std::_Ios_Openmode operator&(std::_Ios_Openmode __a, std::_Ios_Openmode __b)     {
        return std::_Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Openmode operator|(std::_Ios_Openmode __a, std::_Ios_Openmode __b)     {
        return std::_Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Openmode operator^(std::_Ios_Openmode __a, std::_Ios_Openmode __b)     {
        return std::_Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Openmode operator~(std::_Ios_Openmode __a)     {
        return std::_Ios_Openmode(~static_cast<int>(__a));
    }
    inline const std::_Ios_Openmode &operator|=(std::_Ios_Openmode &__a, std::_Ios_Openmode __b)     {
        return __a = __a | __b;
    }
    inline const std::_Ios_Openmode &operator&=(std::_Ios_Openmode &__a, std::_Ios_Openmode __b)     {
        return __a = __a & __b;
    }
    inline const std::_Ios_Openmode &operator^=(std::_Ios_Openmode &__a, std::_Ios_Openmode __b)     {
        return __a = __a ^ __b;
    }
    enum _Ios_Iostate {
        _S_goodbit = 0,
        _S_badbit = 1L << 0,
        _S_eofbit = 1L << 1,
        _S_failbit = 1L << 2,
        _S_ios_iostate_end = 1L << 16,
        _S_ios_iostate_max = 2147483647,
        _S_ios_iostate_min = ~2147483647
    };
    inline constexpr std::_Ios_Iostate operator&(std::_Ios_Iostate __a, std::_Ios_Iostate __b)     {
        return std::_Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Iostate operator|(std::_Ios_Iostate __a, std::_Ios_Iostate __b)     {
        return std::_Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Iostate operator^(std::_Ios_Iostate __a, std::_Ios_Iostate __b)     {
        return std::_Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b));
    }
    inline constexpr std::_Ios_Iostate operator~(std::_Ios_Iostate __a)     {
        return std::_Ios_Iostate(~static_cast<int>(__a));
    }
    inline const std::_Ios_Iostate &operator|=(std::_Ios_Iostate &__a, std::_Ios_Iostate __b)     {
        return __a = __a | __b;
    }
    inline const std::_Ios_Iostate &operator&=(std::_Ios_Iostate &__a, std::_Ios_Iostate __b)     {
        return __a = __a & __b;
    }
    inline const std::_Ios_Iostate &operator^=(std::_Ios_Iostate &__a, std::_Ios_Iostate __b)     {
        return __a = __a ^ __b;
    }
    enum _Ios_Seekdir {
        _S_beg = 0,
        _S_cur = 1,
        _S_end = 2,
        _S_ios_seekdir_end = 1L << 16
    };
    enum class io_errc : int {
        stream = 1
    };
    template<> struct is_error_code_enum<std::io_errc> : public std::true_type {
    };
    const std::_V2::error_category &iostream_category() noexcept;
    inline std::error_code make_error_code(std::io_errc __e) noexcept     {
        return std::error_code(static_cast<int>(__e), iostream_category());
    }
    inline std::error_condition make_error_condition(std::io_errc __e) noexcept     {
        return std::error_condition(static_cast<int>(__e), iostream_category());
    }
    class ios_base {
    public:
        class __attribute__((abi_tag("cxx11"))) failure : public std::system_error {
        public:
            explicit failure(const std::string &__str);
            explicit failure(const std::string &, const std::error_code &);
            explicit failure(const char *, const std::error_code & = io_errc::stream);
            virtual ~failure() throw();
            virtual const char *what() const throw();
        };
        typedef std::_Ios_Fmtflags fmtflags;
        static const std::ios_base::fmtflags boolalpha = _S_boolalpha;
        static const std::ios_base::fmtflags dec = _S_dec;
        static const std::ios_base::fmtflags fixed = _S_fixed;
        static const std::ios_base::fmtflags hex = _S_hex;
        static const std::ios_base::fmtflags internal = _S_internal;
        static const std::ios_base::fmtflags left = _S_left;
        static const std::ios_base::fmtflags oct = _S_oct;
        static const std::ios_base::fmtflags right = _S_right;
        static const std::ios_base::fmtflags scientific = _S_scientific;
        static const std::ios_base::fmtflags showbase = _S_showbase;
        static const std::ios_base::fmtflags showpoint = _S_showpoint;
        static const std::ios_base::fmtflags showpos = _S_showpos;
        static const std::ios_base::fmtflags skipws = _S_skipws;
        static const std::ios_base::fmtflags unitbuf = _S_unitbuf;
        static const std::ios_base::fmtflags uppercase = _S_uppercase;
        static const std::ios_base::fmtflags adjustfield = _S_adjustfield;
        static const std::ios_base::fmtflags basefield = _S_basefield;
        static const std::ios_base::fmtflags floatfield = _S_floatfield;
        typedef std::_Ios_Iostate iostate;
        static const std::ios_base::iostate badbit = _S_badbit;
        static const std::ios_base::iostate eofbit = _S_eofbit;
        static const std::ios_base::iostate failbit = _S_failbit;
        static const std::ios_base::iostate goodbit = _S_goodbit;
        typedef std::_Ios_Openmode openmode;
        static const std::ios_base::openmode app = _S_app;
        static const std::ios_base::openmode ate = _S_ate;
        static const std::ios_base::openmode binary = _S_bin;
        static const std::ios_base::openmode in = _S_in;
        static const std::ios_base::openmode out = _S_out;
        static const std::ios_base::openmode trunc = _S_trunc;
        typedef std::_Ios_Seekdir seekdir;
        static const std::ios_base::seekdir beg = _S_beg;
        static const std::ios_base::seekdir cur = _S_cur;
        static const std::ios_base::seekdir end = _S_end;
        typedef int io_state;
        typedef int open_mode;
        typedef int seek_dir;
        typedef std::streampos streampos;
        typedef std::streamoff streamoff;
        enum event {
            erase_event,
            imbue_event,
            copyfmt_event
        };
        typedef void (*event_callback)(std::ios_base::event, std::ios_base &, int);
        void register_callback(std::ios_base::event_callback __fn, int __index);
    protected:
        std::streamsize _M_precision;
        std::streamsize _M_width;
        std::ios_base::fmtflags _M_flags;
        std::ios_base::iostate _M_exception;
        std::ios_base::iostate _M_streambuf_state;
        struct _Callback_list {
            std::ios_base::_Callback_list *_M_next;
            ios_base::event_callback _M_fn;
            int _M_index;
            _Atomic_word _M_refcount;
            _Callback_list(ios_base::event_callback __fn, int __index, std::ios_base::_Callback_list *__cb) : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0)             {
            }
            void _M_add_reference()             {
                __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
            }
            int _M_remove_reference()             {
                ;
                int __res = __gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount, -1);
                if (__res == 0) {
                    ;
                }
                return __res;
            }
        };
        std::ios_base::_Callback_list *_M_callbacks;
        void _M_call_callbacks(std::ios_base::event __ev) throw();
        void _M_dispose_callbacks() throw();
        struct _Words {
            void *_M_pword;
            long _M_iword;
            _Words() : _M_pword(0), _M_iword(0)             {
            }
        };
        std::ios_base::_Words _M_word_zero;
        enum  {
            _S_local_word_size = 8
        };
        std::ios_base::_Words _M_local_word[8];
        int _M_word_size;
        std::ios_base::_Words *_M_word;
        std::ios_base::_Words &_M_grow_words(int __index, bool __iword);
        std::locale _M_ios_locale;
        void _M_init() throw();
    public:
        class Init {
            friend  class ios_base;
        public:
            Init();
            ~Init() noexcept;
            Init(const std::ios_base::Init &) = default
            std::ios_base::Init &operator=(const std::ios_base::Init &) = default
        private:
            static _Atomic_word _S_refcount;
            static bool _S_synced_with_stdio;
        };
        std::ios_base::fmtflags flags() const         {
            return this->_M_flags;
        }
        std::ios_base::fmtflags flags(std::ios_base::fmtflags __fmtfl)         {
            std::ios_base::fmtflags __old = this->_M_flags;
            this->_M_flags = __fmtfl;
            return __old;
        }
        std::ios_base::fmtflags setf(std::ios_base::fmtflags __fmtfl)         {
            std::ios_base::fmtflags __old = this->_M_flags;
            this->_M_flags |= __fmtfl;
            return __old;
        }
        std::ios_base::fmtflags setf(std::ios_base::fmtflags __fmtfl, std::ios_base::fmtflags __mask)         {
            std::ios_base::fmtflags __old = this->_M_flags;
            this->_M_flags &= ~ __mask;
            this->_M_flags |= (__fmtfl & __mask);
            return __old;
        }
        void unsetf(std::ios_base::fmtflags __mask)         {
            this->_M_flags &= ~ __mask;
        }
        std::streamsize precision() const         {
            return this->_M_precision;
        }
        std::streamsize precision(std::streamsize __prec)         {
            std::streamsize __old = this->_M_precision;
            this->_M_precision = __prec;
            return __old;
        }
        std::streamsize width() const         {
            return this->_M_width;
        }
        std::streamsize width(std::streamsize __wide)         {
            std::streamsize __old = this->_M_width;
            this->_M_width = __wide;
            return __old;
        }
        static bool sync_with_stdio(bool __sync = true);
        std::locale imbue(const std::locale &__loc) throw();
        std::locale getloc() const         {
            return this->_M_ios_locale;
        }
        const std::locale &_M_getloc() const         {
            return this->_M_ios_locale;
        }
        static int xalloc() throw();
        long &iword(int __ix)         {
            std::ios_base::_Words &__word = ((unsigned int)__ix < (unsigned int)this->_M_word_size) ? this->_M_word[__ix] : this->_M_grow_words(__ix, true);
            return __word._M_iword;
        }
        void *&pword(int __ix)         {
            std::ios_base::_Words &__word = ((unsigned int)__ix < (unsigned int)this->_M_word_size) ? this->_M_word[__ix] : this->_M_grow_words(__ix, false);
            return __word._M_pword;
        }
        virtual ~ios_base() throw();
    protected:
        ios_base() throw();
    public:
        ios_base(const std::ios_base &) = delete
        std::ios_base &operator=(const std::ios_base &) = delete
    protected:
        void _M_move(std::ios_base &) noexcept;
        void _M_swap(std::ios_base &__rhs) noexcept;
    };
    inline std::ios_base &boolalpha(std::ios_base &__base)     {
        __base.setf(ios_base::boolalpha);
        return __base;
    }
    inline std::ios_base &noboolalpha(std::ios_base &__base)     {
        __base.unsetf(ios_base::boolalpha);
        return __base;
    }
    inline std::ios_base &showbase(std::ios_base &__base)     {
        __base.setf(ios_base::showbase);
        return __base;
    }
    inline std::ios_base &noshowbase(std::ios_base &__base)     {
        __base.unsetf(ios_base::showbase);
        return __base;
    }
    inline std::ios_base &showpoint(std::ios_base &__base)     {
        __base.setf(ios_base::showpoint);
        return __base;
    }
    inline std::ios_base &noshowpoint(std::ios_base &__base)     {
        __base.unsetf(ios_base::showpoint);
        return __base;
    }
    inline std::ios_base &showpos(std::ios_base &__base)     {
        __base.setf(ios_base::showpos);
        return __base;
    }
    inline std::ios_base &noshowpos(std::ios_base &__base)     {
        __base.unsetf(ios_base::showpos);
        return __base;
    }
    inline std::ios_base &skipws(std::ios_base &__base)     {
        __base.setf(ios_base::skipws);
        return __base;
    }
    inline std::ios_base &noskipws(std::ios_base &__base)     {
        __base.unsetf(ios_base::skipws);
        return __base;
    }
    inline std::ios_base &uppercase(std::ios_base &__base)     {
        __base.setf(ios_base::uppercase);
        return __base;
    }
    inline std::ios_base &nouppercase(std::ios_base &__base)     {
        __base.unsetf(ios_base::uppercase);
        return __base;
    }
    inline std::ios_base &unitbuf(std::ios_base &__base)     {
        __base.setf(ios_base::unitbuf);
        return __base;
    }
    inline std::ios_base &nounitbuf(std::ios_base &__base)     {
        __base.unsetf(ios_base::unitbuf);
        return __base;
    }
    inline std::ios_base &internal(std::ios_base &__base)     {
        __base.setf(ios_base::internal, ios_base::adjustfield);
        return __base;
    }
    inline std::ios_base &left(std::ios_base &__base)     {
        __base.setf(ios_base::left, ios_base::adjustfield);
        return __base;
    }
    inline std::ios_base &right(std::ios_base &__base)     {
        __base.setf(ios_base::right, ios_base::adjustfield);
        return __base;
    }
    inline std::ios_base &dec(std::ios_base &__base)     {
        __base.setf(ios_base::dec, ios_base::basefield);
        return __base;
    }
    inline std::ios_base &hex(std::ios_base &__base)     {
        __base.setf(ios_base::hex, ios_base::basefield);
        return __base;
    }
    inline std::ios_base &oct(std::ios_base &__base)     {
        __base.setf(ios_base::oct, ios_base::basefield);
        return __base;
    }
    inline std::ios_base &fixed(std::ios_base &__base)     {
        __base.setf(ios_base::fixed, ios_base::floatfield);
        return __base;
    }
    inline std::ios_base &scientific(std::ios_base &__base)     {
        __base.setf(ios_base::scientific, ios_base::floatfield);
        return __base;
    }
    inline std::ios_base &hexfloat(std::ios_base &__base)     {
        __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
        return __base;
    }
    inline std::ios_base &defaultfloat(std::ios_base &__base)     {
        __base.unsetf(ios_base::floatfield);
        return __base;
    }
}
namespace std {
    template <typename _CharT, typename _Traits> std::streamsize __copy_streambufs_eof(basic_streambuf<_CharT, _Traits> *, basic_streambuf<_CharT, _Traits> *, bool &);
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_streambuf {
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<std::basic_streambuf::char_type, std::basic_streambuf::traits_type> __streambuf_type;
        friend  class basic_ios<char_type, traits_type>;
        friend  class basic_istream<char_type, traits_type>;
        friend  class basic_ostream<char_type, traits_type>;
        friend  class istreambuf_iterator<char_type, traits_type>;
        friend  class ostreambuf_iterator<char_type, traits_type>;
        friend std::streamsize __copy_streambufs_eof(basic_streambuf<_CharT, _Traits> *, basic_streambuf<_CharT, _Traits> *, bool &);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2> >::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, void>::__type advance(istreambuf_iterator<_CharT2> &, _Distance);
        friend template <typename _CharT2, typename _Traits2> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, _CharT2 *);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &getline(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
    protected:
        std::basic_streambuf::char_type *_M_in_beg;
        std::basic_streambuf::char_type *_M_in_cur;
        std::basic_streambuf::char_type *_M_in_end;
        std::basic_streambuf::char_type *_M_out_beg;
        std::basic_streambuf::char_type *_M_out_cur;
        std::basic_streambuf::char_type *_M_out_end;
        std::locale _M_buf_locale;
    public:
        virtual ~basic_streambuf<_CharT, _Traits>()         {
        }
        std::locale pubimbue(const std::locale &__loc)         {
            std::locale __tmp(this->getloc());
            this->imbue(__loc);
            this->_M_buf_locale = __loc;
            return __tmp;
        }
        std::locale getloc() const         {
            return this->_M_buf_locale;
        }
        basic_streambuf<_CharT, _Traits> *pubsetbuf(std::basic_streambuf::char_type *__s, std::streamsize __n)         {
            return this->setbuf(__s, __n);
        }
        std::basic_streambuf::pos_type pubseekoff(std::basic_streambuf::off_type __off, ios_base::seekdir __way, ios_base::openmode __mode = ios_base::in | ios_base::out)         {
            return this->seekoff(__off, __way, __mode);
        }
        std::basic_streambuf::pos_type pubseekpos(std::basic_streambuf::pos_type __sp, ios_base::openmode __mode = ios_base::in | ios_base::out)         {
            return this->seekpos(__sp, __mode);
        }
        int pubsync()         {
            return this->sync();
        }
        std::streamsize in_avail()         {
            const std::streamsize __ret = this->egptr() - this->gptr();
            return __ret ? __ret : this->showmanyc();
        }
        std::basic_streambuf::int_type snextc()         {
            std::basic_streambuf::int_type __ret = traits_type::eof();
            if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(), __ret), true))
                __ret = this->sgetc();
            return __ret;
        }
        std::basic_streambuf::int_type sbumpc()         {
            std::basic_streambuf::int_type __ret;
            if (__builtin_expect(this->gptr() < this->egptr(), true)) {
                __ret = traits_type::to_int_type(*this->gptr());
                this->gbump(1);
            } else
                __ret = this->uflow();
            return __ret;
        }
        std::basic_streambuf::int_type sgetc()         {
            std::basic_streambuf::int_type __ret;
            if (__builtin_expect(this->gptr() < this->egptr(), true))
                __ret = traits_type::to_int_type(*this->gptr());
            else
                __ret = this->underflow();
            return __ret;
        }
        std::streamsize sgetn(std::basic_streambuf::char_type *__s, std::streamsize __n)         {
            return this->xsgetn(__s, __n);
        }
        std::basic_streambuf::int_type sputbackc(std::basic_streambuf::char_type __c)         {
            std::basic_streambuf::int_type __ret;
            const bool __testpos = this->eback() < this->gptr();
            if (__builtin_expect(!__testpos || !traits_type::eq(__c, this->gptr()[-1]), false))
                __ret = this->pbackfail(traits_type::to_int_type(__c));
            else {
                this->gbump(-1);
                __ret = traits_type::to_int_type(*this->gptr());
            }
            return __ret;
        }
        std::basic_streambuf::int_type sungetc()         {
            std::basic_streambuf::int_type __ret;
            if (__builtin_expect(this->eback() < this->gptr(), true)) {
                this->gbump(-1);
                __ret = traits_type::to_int_type(*this->gptr());
            } else
                __ret = this->pbackfail();
            return __ret;
        }
        std::basic_streambuf::int_type sputc(std::basic_streambuf::char_type __c)         {
            std::basic_streambuf::int_type __ret;
            if (__builtin_expect(this->pptr() < this->epptr(), true)) {
                *this->pptr() = __c;
                this->pbump(1);
                __ret = traits_type::to_int_type(__c);
            } else
                __ret = this->overflow(traits_type::to_int_type(__c));
            return __ret;
        }
        std::streamsize sputn(const std::basic_streambuf::char_type *__s, std::streamsize __n)         {
            return this->xsputn(__s, __n);
        }
    protected:
        basic_streambuf<_CharT, _Traits>() : _M_in_beg(0), _M_in_cur(0), _M_in_end(0), _M_out_beg(0), _M_out_cur(0), _M_out_end(0), _M_buf_locale(std::locale())         {
        }
        std::basic_streambuf::char_type *eback() const         {
            return this->_M_in_beg;
        }
        std::basic_streambuf::char_type *gptr() const         {
            return this->_M_in_cur;
        }
        std::basic_streambuf::char_type *egptr() const         {
            return this->_M_in_end;
        }
        void gbump(int __n)         {
            this->_M_in_cur += __n;
        }
        void setg(std::basic_streambuf::char_type *__gbeg, std::basic_streambuf::char_type *__gnext, std::basic_streambuf::char_type *__gend)         {
            this->_M_in_beg = __gbeg;
            this->_M_in_cur = __gnext;
            this->_M_in_end = __gend;
        }
        std::basic_streambuf::char_type *pbase() const         {
            return this->_M_out_beg;
        }
        std::basic_streambuf::char_type *pptr() const         {
            return this->_M_out_cur;
        }
        std::basic_streambuf::char_type *epptr() const         {
            return this->_M_out_end;
        }
        void pbump(int __n)         {
            this->_M_out_cur += __n;
        }
        void setp(std::basic_streambuf::char_type *__pbeg, std::basic_streambuf::char_type *__pend)         {
            this->_M_out_beg = this->_M_out_cur = __pbeg;
            this->_M_out_end = __pend;
        }
        virtual void imbue(const std::locale &__loc __attribute__((unused)))         {
        }
        virtual basic_streambuf<std::basic_streambuf::char_type, _Traits> *setbuf(std::basic_streambuf::char_type *, std::streamsize)         {
            return this;
        }
        virtual std::basic_streambuf::pos_type seekoff(std::basic_streambuf::off_type, ios_base::seekdir, ios_base::openmode = ios_base::in | ios_base::out)         {
            return std::basic_streambuf::pos_type(std::basic_streambuf::off_type(-1));
        }
        virtual std::basic_streambuf::pos_type seekpos(std::basic_streambuf::pos_type, ios_base::openmode = ios_base::in | ios_base::out)         {
            return std::basic_streambuf::pos_type(std::basic_streambuf::off_type(-1));
        }
        virtual int sync()         {
            return 0;
        }
        virtual std::streamsize showmanyc()         {
            return 0;
        }
        virtual std::streamsize xsgetn(std::basic_streambuf::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf::int_type underflow()         {
            return traits_type::eof();
        }
        virtual std::basic_streambuf::int_type uflow()         {
            std::basic_streambuf::int_type __ret = traits_type::eof();
            const bool __testeof = traits_type::eq_int_type(this->underflow(), __ret);
            if (!__testeof) {
                __ret = traits_type::to_int_type(*this->gptr());
                this->gbump(1);
            }
            return __ret;
        }
        virtual std::basic_streambuf::int_type pbackfail(std::basic_streambuf::int_type __c = traits_type::eof() __attribute__((unused)))         {
            return traits_type::eof();
        }
        virtual std::streamsize xsputn(const std::basic_streambuf::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf::int_type overflow(std::basic_streambuf::int_type __c = traits_type::eof() __attribute__((unused)))         {
            return traits_type::eof();
        }
    public:
        void stossc() [[deprecated("stossc is deprecated, use sbumpc instead")]]         {
            if (this->gptr() < this->egptr())
                this->gbump(1);
            else
                this->uflow();
        }
        void __safe_gbump(std::streamsize __n)         {
            this->_M_in_cur += __n;
        }
        void __safe_pbump(std::streamsize __n)         {
            this->_M_out_cur += __n;
        }
    protected:
        basic_streambuf<_CharT, _Traits>(const basic_streambuf<_CharT, _Traits> &);
        basic_streambuf<_CharT, _Traits> &operator=(const basic_streambuf<_CharT, _Traits> &);
        void swap(basic_streambuf<_CharT, _Traits> &__sb)         {
            std::swap(this->_M_in_beg, __sb._M_in_beg);
            std::swap(this->_M_in_cur, __sb._M_in_cur);
            std::swap(this->_M_in_end, __sb._M_in_end);
            std::swap(this->_M_out_beg, __sb._M_out_beg);
            std::swap(this->_M_out_cur, __sb._M_out_cur);
            std::swap(this->_M_out_end, __sb._M_out_end);
            std::swap(this->_M_buf_locale, __sb._M_buf_locale);
        }
    };
    template <typename _CharT, typename _Traits> std::basic_streambuf<_CharT, _Traits>::basic_streambuf<_CharT, _Traits>(const basic_streambuf<_CharT, _Traits> &) = default
    template <typename _CharT, typename _Traits> std::basic_streambuf<_CharT, _Traits> &std::basic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf<_CharT, _Traits> &) = default
    template<> std::streamsize __copy_streambufs_eof<char, std::char_traits<char>>(basic_streambuf<char> *__sbin, basic_streambuf<char> *__sbout, bool &__ineof);
    template<> std::streamsize __copy_streambufs_eof<wchar_t, std::char_traits<wchar_t>>(basic_streambuf<wchar_t> *__sbin, basic_streambuf<wchar_t> *__sbout, bool &__ineof);
}
namespace std {
    template <typename _CharT, typename _Traits> std::streamsize basic_streambuf<_CharT, _Traits>::xsgetn(std::basic_streambuf::char_type *__s, std::streamsize __n)     {
        std::streamsize __ret = 0;
        while (__ret < __n)
            {
                const std::streamsize __buf_len = this->egptr() - this->gptr();
                if (__buf_len) {
                    const std::streamsize __remaining = __n - __ret;
                    const std::streamsize __len = std::min(__buf_len, __remaining);
                    traits_type::copy(__s, this->gptr(), __len);
                    __ret += __len;
                    __s += __len;
                    this->__safe_gbump(__len);
                }
                if (__ret < __n) {
                    const std::basic_streambuf::int_type __c = this->uflow();
                    if (!traits_type::eq_int_type(__c, traits_type::eof())) {
                        traits_type::assign(*__s++, traits_type::to_char_type(__c));
                        ++__ret;
                    } else
                        break;
                }
            }
        return __ret;
    }
    template <typename _CharT, typename _Traits> std::streamsize basic_streambuf<_CharT, _Traits>::xsputn(const std::basic_streambuf::char_type *__s, std::streamsize __n)     {
        std::streamsize __ret = 0;
        while (__ret < __n)
            {
                const std::streamsize __buf_len = this->epptr() - this->pptr();
                if (__buf_len) {
                    const std::streamsize __remaining = __n - __ret;
                    const std::streamsize __len = std::min(__buf_len, __remaining);
                    traits_type::copy(this->pptr(), __s, __len);
                    __ret += __len;
                    __s += __len;
                    this->__safe_pbump(__len);
                }
                if (__ret < __n) {
                    std::basic_streambuf::int_type __c = this->overflow(traits_type::to_int_type(*__s));
                    if (!traits_type::eq_int_type(__c, traits_type::eof())) {
                        ++__ret;
                        ++__s;
                    } else
                        break;
                }
            }
        return __ret;
    }
    template <typename _CharT, typename _Traits> std::streamsize __copy_streambufs_eof(basic_streambuf<_CharT, _Traits> *__sbin, basic_streambuf<_CharT, _Traits> *__sbout, bool &__ineof)     {
        std::streamsize __ret = 0;
        __ineof = true;
        typename _Traits::int_type __c = __sbin->sgetc();
        while (!_Traits::eq_int_type(__c, _Traits::eof()))
            {
                __c = __sbout->sputc(_Traits::to_char_type(__c));
                if (_Traits::eq_int_type(__c, _Traits::eof())) {
                    __ineof = false;
                    break;
                }
                ++__ret;
                __c = __sbin->snextc();
            }
        return __ret;
    }
    template <typename _CharT, typename _Traits> inline std::streamsize __copy_streambufs(basic_streambuf<_CharT, _Traits> *__sbin, basic_streambuf<_CharT, _Traits> *__sbout)     {
        bool __ineof;
        return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }
    template<> class basic_streambuf<char> {
    public:
        typedef char char_type;
        typedef std::char_traits<char> traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<std::basic_streambuf<char, std::char_traits<char> >::char_type, std::basic_streambuf<char, std::char_traits<char> >::traits_type> __streambuf_type;
        friend  class basic_ios<char_type, traits_type>;
        friend  class basic_istream<char_type, traits_type>;
        friend  class basic_ostream<char_type, traits_type>;
        friend  class istreambuf_iterator<char_type, traits_type>;
        friend  class ostreambuf_iterator<char_type, traits_type>;
        friend template<> std::streamsize __copy_streambufs_eof<>(std::basic_streambuf<char> *, std::basic_streambuf<char> *, bool &);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2> >::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, void>::__type advance(istreambuf_iterator<_CharT2> &, _Distance);
        friend template <typename _CharT2, typename _Traits2> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, _CharT2 *);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &getline(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
    protected:
        std::basic_streambuf<char, std::char_traits<char> >::char_type *_M_in_beg;
        std::basic_streambuf<char, std::char_traits<char> >::char_type *_M_in_cur;
        std::basic_streambuf<char, std::char_traits<char> >::char_type *_M_in_end;
        std::basic_streambuf<char, std::char_traits<char> >::char_type *_M_out_beg;
        std::basic_streambuf<char, std::char_traits<char> >::char_type *_M_out_cur;
        std::basic_streambuf<char, std::char_traits<char> >::char_type *_M_out_end;
        std::locale _M_buf_locale;
    public:
        virtual ~basic_streambuf<char>();
        std::locale pubimbue(const std::locale &__loc);
        std::locale getloc() const;
        std::basic_streambuf<char> *pubsetbuf(std::basic_streambuf<char, std::char_traits<char> >::char_type *__s, std::streamsize __n);
        std::basic_streambuf<char, std::char_traits<char> >::pos_type pubseekoff(std::basic_streambuf<char, std::char_traits<char> >::off_type __off, ios_base::seekdir __way, ios_base::openmode __mode);
        std::basic_streambuf<char, std::char_traits<char> >::pos_type pubseekpos(std::basic_streambuf<char, std::char_traits<char> >::pos_type __sp, ios_base::openmode __mode);
        int pubsync();
        std::streamsize in_avail();
        std::basic_streambuf<char, std::char_traits<char> >::int_type snextc();
        std::basic_streambuf<char, std::char_traits<char> >::int_type sbumpc();
        std::basic_streambuf<char, std::char_traits<char> >::int_type sgetc();
        std::streamsize sgetn(std::basic_streambuf<char, std::char_traits<char> >::char_type *__s, std::streamsize __n);
        std::basic_streambuf<char, std::char_traits<char> >::int_type sputbackc(std::basic_streambuf<char, std::char_traits<char> >::char_type __c);
        std::basic_streambuf<char, std::char_traits<char> >::int_type sungetc();
        std::basic_streambuf<char, std::char_traits<char> >::int_type sputc(std::basic_streambuf<char, std::char_traits<char> >::char_type __c);
        std::streamsize sputn(const std::basic_streambuf<char, std::char_traits<char> >::char_type *__s, std::streamsize __n);
    protected:
        basic_streambuf();
        std::basic_streambuf<char, std::char_traits<char> >::char_type *eback() const;
        std::basic_streambuf<char, std::char_traits<char> >::char_type *gptr() const;
        std::basic_streambuf<char, std::char_traits<char> >::char_type *egptr() const;
        void gbump(int __n);
        void setg(std::basic_streambuf<char, std::char_traits<char> >::char_type *__gbeg, std::basic_streambuf<char, std::char_traits<char> >::char_type *__gnext, std::basic_streambuf<char, std::char_traits<char> >::char_type *__gend);
        std::basic_streambuf<char, std::char_traits<char> >::char_type *pbase() const;
        std::basic_streambuf<char, std::char_traits<char> >::char_type *pptr() const;
        std::basic_streambuf<char, std::char_traits<char> >::char_type *epptr() const;
        void pbump(int __n);
        void setp(std::basic_streambuf<char, std::char_traits<char> >::char_type *__pbeg, std::basic_streambuf<char, std::char_traits<char> >::char_type *__pend);
        virtual void imbue(const std::locale &__loc __attribute__((unused)));
        virtual basic_streambuf<std::basic_streambuf<char, std::char_traits<char> >::char_type, std::char_traits<char> > *setbuf(std::basic_streambuf<char, std::char_traits<char> >::char_type *, std::streamsize);
        virtual std::basic_streambuf<char, std::char_traits<char> >::pos_type seekoff(std::basic_streambuf<char, std::char_traits<char> >::off_type, ios_base::seekdir, ios_base::openmode);
        virtual std::basic_streambuf<char, std::char_traits<char> >::pos_type seekpos(std::basic_streambuf<char, std::char_traits<char> >::pos_type, ios_base::openmode);
        virtual int sync();
        virtual std::streamsize showmanyc();
        virtual std::streamsize xsgetn(std::basic_streambuf<char, std::char_traits<char> >::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf<char, std::char_traits<char> >::int_type underflow();
        virtual std::basic_streambuf<char, std::char_traits<char> >::int_type uflow();
        virtual std::basic_streambuf<char, std::char_traits<char> >::int_type pbackfail(std::basic_streambuf<char, std::char_traits<char> >::int_type __c __attribute__((unused)));
        virtual std::streamsize xsputn(const std::basic_streambuf<char, std::char_traits<char> >::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf<char, std::char_traits<char> >::int_type overflow(std::basic_streambuf<char, std::char_traits<char> >::int_type __c __attribute__((unused)));
    public:
        void stossc() [[deprecated("stossc is deprecated, use sbumpc instead")]];
        void __safe_gbump(std::streamsize __n);
        void __safe_pbump(std::streamsize __n);
    protected:
        basic_streambuf(const std::basic_streambuf<char> &);
        std::basic_streambuf<char> &operator=(const std::basic_streambuf<char> &);
        void swap(std::basic_streambuf<char> &__sb);
    };
    template<> class basic_streambuf<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef typename traits_type::int_type int_type;
        typedef typename traits_type::pos_type pos_type;
        typedef typename traits_type::off_type off_type;
        typedef basic_streambuf<std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type, std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::traits_type> __streambuf_type;
        friend  class basic_ios<char_type, traits_type>;
        friend  class basic_istream<char_type, traits_type>;
        friend  class basic_ostream<char_type, traits_type>;
        friend  class istreambuf_iterator<char_type, traits_type>;
        friend  class ostreambuf_iterator<char_type, traits_type>;
        friend template<> std::streamsize __copy_streambufs_eof<>(std::basic_streambuf<wchar_t> *, std::basic_streambuf<wchar_t> *, bool &);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2> >::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, void>::__type advance(istreambuf_iterator<_CharT2> &, _Distance);
        friend template <typename _CharT2, typename _Traits2> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, _CharT2 *);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &operator>>(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &);
        friend template <typename _CharT2, typename _Traits2, typename _Alloc> basic_istream<_CharT2, _Traits2> &getline(basic_istream<_CharT2, _Traits2> &, basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
    protected:
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type *_M_in_beg;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type *_M_in_cur;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type *_M_in_end;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type *_M_out_beg;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type *_M_out_cur;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type *_M_out_end;
        std::locale _M_buf_locale;
    public:
        virtual ~basic_streambuf<wchar_t>();
        std::locale pubimbue(const std::locale &__loc);
        std::locale getloc() const;
        std::basic_streambuf<wchar_t> *pubsetbuf(std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type *__s, std::streamsize __n);
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::pos_type pubseekoff(std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::off_type __off, ios_base::seekdir __way, ios_base::openmode __mode);
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::pos_type pubseekpos(std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::pos_type __sp, ios_base::openmode __mode);
        int pubsync();
        std::streamsize in_avail();
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::int_type snextc();
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::int_type sbumpc();
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::int_type sgetc();
        std::streamsize sgetn(std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type *__s, std::streamsize __n);
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::int_type sputbackc(std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type __c);
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::int_type sungetc();
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::int_type sputc(std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type __c);
        std::streamsize sputn(const std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type *__s, std::streamsize __n);
    protected:
        basic_streambuf();
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type *eback() const;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type *gptr() const;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type *egptr() const;
        void gbump(int __n);
        void setg(std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type *__gbeg, std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type *__gnext, std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type *__gend);
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type *pbase() const;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type *pptr() const;
        std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type *epptr() const;
        void pbump(int __n);
        void setp(std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type *__pbeg, std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type *__pend);
        virtual void imbue(const std::locale &__loc __attribute__((unused)));
        virtual basic_streambuf<std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type, std::char_traits<wchar_t> > *setbuf(std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type *, std::streamsize);
        virtual std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::pos_type seekoff(std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::off_type, ios_base::seekdir, ios_base::openmode);
        virtual std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::pos_type seekpos(std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::pos_type, ios_base::openmode);
        virtual int sync();
        virtual std::streamsize showmanyc();
        virtual std::streamsize xsgetn(std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::int_type underflow();
        virtual std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::int_type uflow();
        virtual std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::int_type pbackfail(std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::int_type __c __attribute__((unused)));
        virtual std::streamsize xsputn(const std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::char_type *__s, std::streamsize __n);
        virtual std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::int_type overflow(std::basic_streambuf<wchar_t, std::char_traits<wchar_t> >::int_type __c __attribute__((unused)));
    public:
        void stossc() [[deprecated("stossc is deprecated, use sbumpc instead")]];
        void __safe_gbump(std::streamsize __n);
        void __safe_pbump(std::streamsize __n);
    protected:
        basic_streambuf(const std::basic_streambuf<wchar_t> &);
        std::basic_streambuf<wchar_t> &operator=(const std::basic_streambuf<wchar_t> &);
        void swap(std::basic_streambuf<wchar_t> &__sb);
    };
}
typedef unsigned long wctype_t;
enum  {
    __ISwupper = 0,
    __ISwlower = 1,
    __ISwalpha = 2,
    __ISwdigit = 3,
    __ISwxdigit = 4,
    __ISwspace = 5,
    __ISwprint = 6,
    __ISwgraph = 7,
    __ISwblank = 8,
    __ISwcntrl = 9,
    __ISwpunct = 10,
    __ISwalnum = 11,
    _ISwupper = ((__ISwupper) < 8 ? (int)((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int)((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int)((1UL << (__ISwupper)) >> 8) : (int)((1UL << (__ISwupper)) >> 24)))),
    _ISwlower = ((__ISwlower) < 8 ? (int)((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int)((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int)((1UL << (__ISwlower)) >> 8) : (int)((1UL << (__ISwlower)) >> 24)))),
    _ISwalpha = ((__ISwalpha) < 8 ? (int)((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int)((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int)((1UL << (__ISwalpha)) >> 8) : (int)((1UL << (__ISwalpha)) >> 24)))),
    _ISwdigit = ((__ISwdigit) < 8 ? (int)((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int)((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int)((1UL << (__ISwdigit)) >> 8) : (int)((1UL << (__ISwdigit)) >> 24)))),
    _ISwxdigit = ((__ISwxdigit) < 8 ? (int)((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int)((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int)((1UL << (__ISwxdigit)) >> 8) : (int)((1UL << (__ISwxdigit)) >> 24)))),
    _ISwspace = ((__ISwspace) < 8 ? (int)((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int)((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int)((1UL << (__ISwspace)) >> 8) : (int)((1UL << (__ISwspace)) >> 24)))),
    _ISwprint = ((__ISwprint) < 8 ? (int)((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int)((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int)((1UL << (__ISwprint)) >> 8) : (int)((1UL << (__ISwprint)) >> 24)))),
    _ISwgraph = ((__ISwgraph) < 8 ? (int)((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int)((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int)((1UL << (__ISwgraph)) >> 8) : (int)((1UL << (__ISwgraph)) >> 24)))),
    _ISwblank = ((__ISwblank) < 8 ? (int)((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int)((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int)((1UL << (__ISwblank)) >> 8) : (int)((1UL << (__ISwblank)) >> 24)))),
    _ISwcntrl = ((__ISwcntrl) < 8 ? (int)((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int)((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int)((1UL << (__ISwcntrl)) >> 8) : (int)((1UL << (__ISwcntrl)) >> 24)))),
    _ISwpunct = ((__ISwpunct) < 8 ? (int)((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int)((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int)((1UL << (__ISwpunct)) >> 8) : (int)((1UL << (__ISwpunct)) >> 24)))),
    _ISwalnum = ((__ISwalnum) < 8 ? (int)((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int)((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int)((1UL << (__ISwalnum)) >> 8) : (int)((1UL << (__ISwalnum)) >> 24))))
};
extern "C" {
    extern int iswalnum(wint_t __wc) throw();
    extern int iswalpha(wint_t __wc) throw();
    extern int iswcntrl(wint_t __wc) throw();
    extern int iswdigit(wint_t __wc) throw();
    extern int iswgraph(wint_t __wc) throw();
    extern int iswlower(wint_t __wc) throw();
    extern int iswprint(wint_t __wc) throw();
    extern int iswpunct(wint_t __wc) throw();
    extern int iswspace(wint_t __wc) throw();
    extern int iswupper(wint_t __wc) throw();
    extern int iswxdigit(wint_t __wc) throw();
    extern int iswblank(wint_t __wc) throw();
    extern wctype_t wctype(const char *__property) throw();
    extern int iswctype(wint_t __wc, wctype_t __desc) throw();
    extern wint_t towlower(wint_t __wc) throw();
    extern wint_t towupper(wint_t __wc) throw();
}
extern "C" {
    typedef const __int32_t *wctrans_t;
    extern wctrans_t wctrans(const char *__property) throw();
    extern wint_t towctrans(wint_t __wc, wctrans_t __desc) throw();
    extern int iswalnum_l(wint_t __wc, locale_t __locale) throw();
    extern int iswalpha_l(wint_t __wc, locale_t __locale) throw();
    extern int iswcntrl_l(wint_t __wc, locale_t __locale) throw();
    extern int iswdigit_l(wint_t __wc, locale_t __locale) throw();
    extern int iswgraph_l(wint_t __wc, locale_t __locale) throw();
    extern int iswlower_l(wint_t __wc, locale_t __locale) throw();
    extern int iswprint_l(wint_t __wc, locale_t __locale) throw();
    extern int iswpunct_l(wint_t __wc, locale_t __locale) throw();
    extern int iswspace_l(wint_t __wc, locale_t __locale) throw();
    extern int iswupper_l(wint_t __wc, locale_t __locale) throw();
    extern int iswxdigit_l(wint_t __wc, locale_t __locale) throw();
    extern int iswblank_l(wint_t __wc, locale_t __locale) throw();
    extern wctype_t wctype_l(const char *__property, locale_t __locale) throw();
    extern int iswctype_l(wint_t __wc, wctype_t __desc, locale_t __locale) throw();
    extern wint_t towlower_l(wint_t __wc, locale_t __locale) throw();
    extern wint_t towupper_l(wint_t __wc, locale_t __locale) throw();
    extern wctrans_t wctrans_l(const char *__property, locale_t __locale) throw();
    extern wint_t towctrans_l(wint_t __wc, wctrans_t __desc, locale_t __locale) throw();
}
namespace std {
    using ::wctrans_t;
    using ::wctype_t;
    using ::wint_t;
    using ::iswalnum;
    using ::iswalpha;
    using ::iswblank;
    using ::iswcntrl;
    using ::iswctype;
    using ::iswdigit;
    using ::iswgraph;
    using ::iswlower;
    using ::iswprint;
    using ::iswpunct;
    using ::iswspace;
    using ::iswupper;
    using ::iswxdigit;
    using ::towctrans;
    using ::towlower;
    using ::towupper;
    using ::wctrans;
    using ::wctype;
}
namespace std {
    struct ctype_base {
        typedef const int *__to_type;
        typedef unsigned short mask;
        static const std::ctype_base::mask upper = _ISupper;
        static const std::ctype_base::mask lower = _ISlower;
        static const std::ctype_base::mask alpha = _ISalpha;
        static const std::ctype_base::mask digit = _ISdigit;
        static const std::ctype_base::mask xdigit = _ISxdigit;
        static const std::ctype_base::mask space = _ISspace;
        static const std::ctype_base::mask print = _ISprint;
        static const std::ctype_base::mask graph = _ISalpha | _ISdigit | _ISpunct;
        static const std::ctype_base::mask cntrl = _IScntrl;
        static const std::ctype_base::mask punct = _ISpunct;
        static const std::ctype_base::mask alnum = _ISalpha | _ISdigit;
        static const std::ctype_base::mask blank = _ISblank;
    };
}
namespace std {
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class istreambuf_iterator : public iterator<std::input_iterator_tag, _CharT, typename _Traits::off_type, _CharT *, _CharT> {
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef typename _Traits::int_type int_type;
        typedef basic_streambuf<_CharT, _Traits> streambuf_type;
        typedef basic_istream<_CharT, _Traits> istream_type;
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ostreambuf_iterator<_CharT2> >::__type copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, ostreambuf_iterator<_CharT2>);
        friend template <bool _IsMove, typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, _CharT2 *);
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, istreambuf_iterator<_CharT2> >::__type find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, const _CharT2 &);
        friend template <typename _CharT2, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, void>::__type advance(istreambuf_iterator<_CharT2> &, _Distance);
    private:
        mutable std::istreambuf_iterator::streambuf_type *_M_sbuf;
        std::istreambuf_iterator::int_type _M_c;
    public:
        constexpr istreambuf_iterator<_CharT, _Traits>() noexcept : _M_sbuf(0), _M_c(traits_type::eof())         {
        }
        istreambuf_iterator<_CharT, _Traits>(const istreambuf_iterator<_CharT, _Traits> &) noexcept = default
        ~istreambuf_iterator<_CharT, _Traits>() = default
        istreambuf_iterator<_CharT, _Traits>(std::istreambuf_iterator::istream_type &__s) noexcept : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof())         {
        }
        istreambuf_iterator<_CharT, _Traits>(std::istreambuf_iterator::streambuf_type *__s) noexcept : _M_sbuf(__s), _M_c(traits_type::eof())         {
        }
        istreambuf_iterator<_CharT, _Traits> &operator=(const istreambuf_iterator<_CharT, _Traits> &) noexcept = default
        std::istreambuf_iterator::char_type operator*() const         {
            std::istreambuf_iterator::int_type __c = this->_M_get();
            return traits_type::to_char_type(__c);
        }
        istreambuf_iterator<_CharT, _Traits> &operator++()         {
            ;
            this->_M_sbuf->sbumpc();
            this->_M_c = traits_type::eof();
            return *this;
        }
        istreambuf_iterator<_CharT, _Traits> operator++(int)         {
            ;
            istreambuf_iterator<_CharT, _Traits> __old = *this;
            __old._M_c = this->_M_sbuf->sbumpc();
            this->_M_c = traits_type::eof();
            return __old;
        }
        bool equal(const istreambuf_iterator<_CharT, _Traits> &__b) const         {
            return this->_M_at_eof() == __b._M_at_eof();
        }
    private:
        std::istreambuf_iterator::int_type _M_get() const         {
            std::istreambuf_iterator::int_type __ret = this->_M_c;
            if (this->_M_sbuf && _S_is_eof(__ret) && _S_is_eof(__ret = this->_M_sbuf->sgetc()))
                this->_M_sbuf = 0;
            return __ret;
        }
        bool _M_at_eof() const         {
            return _S_is_eof(this->_M_get());
        }
        static bool _S_is_eof(std::istreambuf_iterator::int_type __c)         {
            const std::istreambuf_iterator::int_type __eof = traits_type::eof();
            return traits_type::eq_int_type(__c, __eof);
        }
    };
    template <typename _CharT, typename _Traits> inline bool operator==(const istreambuf_iterator<_CharT, _Traits> &__a, const istreambuf_iterator<_CharT, _Traits> &__b)     {
        return __a.equal(__b);
    }
    template <typename _CharT, typename _Traits> inline bool operator!=(const istreambuf_iterator<_CharT, _Traits> &__a, const istreambuf_iterator<_CharT, _Traits> &__b)     {
        return !__a.equal(__b);
    }
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class ostreambuf_iterator : public iterator<std::output_iterator_tag, void, void, void, void> {
    public:
        typedef _CharT char_type;
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> streambuf_type;
        typedef basic_ostream<_CharT, _Traits> ostream_type;
        friend template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ostreambuf_iterator<_CharT2> >::__type copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>, ostreambuf_iterator<_CharT2>);
    private:
        std::ostreambuf_iterator::streambuf_type *_M_sbuf;
        bool _M_failed;
    public:
        ostreambuf_iterator<_CharT, _Traits>(std::ostreambuf_iterator::ostream_type &__s) noexcept : _M_sbuf(__s.rdbuf()), _M_failed(!this->_M_sbuf)         {
        }
        ostreambuf_iterator<_CharT, _Traits>(std::ostreambuf_iterator::streambuf_type *__s) noexcept : _M_sbuf(__s), _M_failed(!this->_M_sbuf)         {
        }
        ostreambuf_iterator<_CharT, _Traits> &operator=(_CharT __c)         {
            if (!this->_M_failed && _Traits::eq_int_type(this->_M_sbuf->sputc(__c), _Traits::eof()))
                this->_M_failed = true;
            return *this;
        }
        ostreambuf_iterator<_CharT, _Traits> &operator*()         {
            return *this;
        }
        ostreambuf_iterator<_CharT, _Traits> &operator++(int)         {
            return *this;
        }
        ostreambuf_iterator<_CharT, _Traits> &operator++()         {
            return *this;
        }
        bool failed() const noexcept         {
            return this->_M_failed;
        }
        ostreambuf_iterator<_CharT, _Traits> &_M_put(const _CharT *__ws, std::streamsize __len)         {
            if (__builtin_expect(!this->_M_failed, true) && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len, false))
                this->_M_failed = true;
            return *this;
        }
    };
    template <typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT> >::__type copy(istreambuf_iterator<_CharT> __first, istreambuf_iterator<_CharT> __last, ostreambuf_iterator<_CharT> __result)     {
        if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed) {
            bool __ineof;
            __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
            if (!__ineof)
                __result._M_failed = true;
        }
        return __result;
    }
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT> >::__type __copy_move_a2(_CharT *__first, _CharT *__last, ostreambuf_iterator<_CharT> __result)     {
        const std::streamsize __num = __last - __first;
        if (__num > 0)
            __result._M_put(__first, __num);
        return __result;
    }
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, ostreambuf_iterator<_CharT> >::__type __copy_move_a2(const _CharT *__first, const _CharT *__last, ostreambuf_iterator<_CharT> __result)     {
        const std::streamsize __num = __last - __first;
        if (__num > 0)
            __result._M_put(__first, __num);
        return __result;
    }
    template <bool _IsMove, typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_move_a2(istreambuf_iterator<_CharT> __first, istreambuf_iterator<_CharT> __last, _CharT *__result)     {
        typedef istreambuf_iterator<_CharT> __is_iterator_type;
        typedef typename __is_iterator_type::traits_type traits_type;
        typedef typename __is_iterator_type::streambuf_type streambuf_type;
        typedef typename traits_type::int_type int_type;
        if (__first._M_sbuf && !__last._M_sbuf) {
            streambuf_type *__sb = __first._M_sbuf;
            int_type __c = __sb->sgetc();
            while (!traits_type::eq_int_type(__c, traits_type::eof()))
                {
                    const std::streamsize __n = __sb->egptr() - __sb->gptr();
                    if (__n > 1) {
                        traits_type::copy(__result, __sb->gptr(), __n);
                        __sb->__safe_gbump(__n);
                        __result += __n;
                        __c = __sb->underflow();
                    } else {
                        *__result++ = traits_type::to_char_type(__c);
                        __c = __sb->snextc();
                    }
                }
        }
        return __result;
    }
    template <typename _CharT> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, istreambuf_iterator<_CharT> >::__type find(istreambuf_iterator<_CharT> __first, istreambuf_iterator<_CharT> __last, const _CharT &__val)     {
        typedef istreambuf_iterator<_CharT> __is_iterator_type;
        typedef typename __is_iterator_type::traits_type traits_type;
        typedef typename __is_iterator_type::streambuf_type streambuf_type;
        typedef typename traits_type::int_type int_type;
        const int_type __eof = traits_type::eof();
        if (__first._M_sbuf && !__last._M_sbuf) {
            const int_type __ival = traits_type::to_int_type(__val);
            streambuf_type *__sb = __first._M_sbuf;
            int_type __c = __sb->sgetc();
            while (!traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __ival))
                {
                    std::streamsize __n = __sb->egptr() - __sb->gptr();
                    if (__n > 1) {
                        const _CharT *__p = traits_type::find(__sb->gptr(), __n, __val);
                        if (__p)
                            __n = __p - __sb->gptr();
                        __sb->__safe_gbump(__n);
                        __c = __sb->sgetc();
                    } else
                        __c = __sb->snextc();
                }
            __first._M_c = __eof;
        }
        return __first;
    }
    template <typename _CharT, typename _Distance> typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, void>::__type advance(istreambuf_iterator<_CharT> &__i, _Distance __n)     {
        if (__n == 0)
            return;
        ;
        ;
        typedef istreambuf_iterator<_CharT> __is_iterator_type;
        typedef typename __is_iterator_type::traits_type traits_type;
        typedef typename __is_iterator_type::streambuf_type streambuf_type;
        typedef typename traits_type::int_type int_type;
        const int_type __eof = traits_type::eof();
        streambuf_type *__sb = __i._M_sbuf;
        while (__n > 0)
            {
                std::streamsize __size = __sb->egptr() - __sb->gptr();
                if (__size > __n) {
                    __sb->__safe_gbump(__n);
                    break;
                }
                __sb->__safe_gbump(__size);
                __n -= __size;
                if (traits_type::eq_int_type(__sb->underflow(), __eof)) {
                    ;
                    break;
                }
            }
        __i._M_c = __eof;
    }
}
namespace std {
    template <typename _Tp> void __convert_to_v(const char *, _Tp &, ios_base::iostate &, const std::__c_locale &) throw();
    template<> void __convert_to_v<float>(const char *, float &, ios_base::iostate &, const std::__c_locale &) throw();
    template<> void __convert_to_v<double>(const char *, double &, ios_base::iostate &, const std::__c_locale &) throw();
    template<> void __convert_to_v<long double>(const char *, long double &, ios_base::iostate &, const std::__c_locale &) throw();
    template <typename _CharT, typename _Traits> struct __pad {
        static void _S_pad(std::ios_base &__io, _CharT __fill, _CharT *__news, const _CharT *__olds, std::streamsize __newlen, std::streamsize __oldlen);
    };
    template <typename _CharT> _CharT *__add_grouping(_CharT *__s, _CharT __sep, const char *__gbeg, std::size_t __gsize, const _CharT *__first, const _CharT *__last);
    template <typename _CharT> inline ostreambuf_iterator<_CharT> __write(ostreambuf_iterator<_CharT> __s, const _CharT *__ws, int __len)     {
        __s._M_put(__ws, __len);
        return __s;
    }
    template <typename _CharT, typename _OutIter> inline _OutIter __write(_OutIter __s, const _CharT *__ws, int __len)     {
        for (int __j = 0; __j < __len; __j++ , ++__s)
            *__s = __ws[__j];
        return __s;
    }
    template <typename _CharT> class __ctype_abstract_base : public locale::facet, public std::ctype_base {
    public:
        typedef _CharT char_type;
        bool is(std::ctype_base::mask __m, std::__ctype_abstract_base::char_type __c) const         {
            return this->do_is(__m, __c);
        }
        const std::__ctype_abstract_base::char_type *is(const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi, std::ctype_base::mask *__vec) const         {
            return this->do_is(__lo, __hi, __vec);
        }
        const std::__ctype_abstract_base::char_type *scan_is(std::ctype_base::mask __m, const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const         {
            return this->do_scan_is(__m, __lo, __hi);
        }
        const std::__ctype_abstract_base::char_type *scan_not(std::ctype_base::mask __m, const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const         {
            return this->do_scan_not(__m, __lo, __hi);
        }
        std::__ctype_abstract_base::char_type toupper(std::__ctype_abstract_base::char_type __c) const         {
            return this->do_toupper(__c);
        }
        const std::__ctype_abstract_base::char_type *toupper(std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const         {
            return this->do_toupper(__lo, __hi);
        }
        std::__ctype_abstract_base::char_type tolower(std::__ctype_abstract_base::char_type __c) const         {
            return this->do_tolower(__c);
        }
        const std::__ctype_abstract_base::char_type *tolower(std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const         {
            return this->do_tolower(__lo, __hi);
        }
        std::__ctype_abstract_base::char_type widen(char __c) const         {
            return this->do_widen(__c);
        }
        const char *widen(const char *__lo, const char *__hi, std::__ctype_abstract_base::char_type *__to) const         {
            return this->do_widen(__lo, __hi, __to);
        }
        char narrow(std::__ctype_abstract_base::char_type __c, char __dfault) const         {
            return this->do_narrow(__c, __dfault);
        }
        const std::__ctype_abstract_base::char_type *narrow(const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi, char __dfault, char *__to) const         {
            return this->do_narrow(__lo, __hi, __dfault, __to);
        }
    protected:
        explicit __ctype_abstract_base<_CharT>(std::size_t __refs = 0) : std::locale::facet(__refs)         {
        }
        virtual ~__ctype_abstract_base<_CharT>()         {
        }
        virtual bool do_is(std::ctype_base::mask __m, std::__ctype_abstract_base::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_is(const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi, std::ctype_base::mask *__vec) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_scan_is(std::ctype_base::mask __m, const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_scan_not(std::ctype_base::mask __m, const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base::char_type do_toupper(std::__ctype_abstract_base::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_toupper(std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base::char_type do_tolower(std::__ctype_abstract_base::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_tolower(std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base::char_type do_widen(char __c) const = 0;
        virtual const char *do_widen(const char *__lo, const char *__hi, std::__ctype_abstract_base::char_type *__to) const = 0;
        virtual char do_narrow(std::__ctype_abstract_base::char_type __c, char __dfault) const = 0;
        virtual const std::__ctype_abstract_base::char_type *do_narrow(const std::__ctype_abstract_base::char_type *__lo, const std::__ctype_abstract_base::char_type *__hi, char __dfault, char *__to) const = 0;
    };
template<> class __ctype_abstract_base<wchar_t> : public locale::facet, public std::ctype_base {
    public:
        typedef wchar_t char_type;
        bool is(std::ctype_base::mask __m, std::__ctype_abstract_base<wchar_t>::char_type __c) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *is(const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi, std::ctype_base::mask *__vec) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *scan_is(std::ctype_base::mask __m, const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *scan_not(std::ctype_base::mask __m, const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const;
        std::__ctype_abstract_base<wchar_t>::char_type toupper(std::__ctype_abstract_base<wchar_t>::char_type __c) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *toupper(std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const;
        std::__ctype_abstract_base<wchar_t>::char_type tolower(std::__ctype_abstract_base<wchar_t>::char_type __c) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *tolower(std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const;
        std::__ctype_abstract_base<wchar_t>::char_type widen(char __c) const;
        const char *widen(const char *__lo, const char *__hi, std::__ctype_abstract_base<wchar_t>::char_type *__to) const;
        char narrow(std::__ctype_abstract_base<wchar_t>::char_type __c, char __dfault) const;
        const std::__ctype_abstract_base<wchar_t>::char_type *narrow(const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi, char __dfault, char *__to) const;
    protected:
        explicit __ctype_abstract_base(std::size_t __refs);
        virtual ~__ctype_abstract_base<wchar_t>() noexcept;
        virtual bool do_is(std::ctype_base::mask __m, std::__ctype_abstract_base<wchar_t>::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_is(const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi, std::ctype_base::mask *__vec) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_scan_is(std::ctype_base::mask __m, const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_scan_not(std::ctype_base::mask __m, const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base<wchar_t>::char_type do_toupper(std::__ctype_abstract_base<wchar_t>::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_toupper(std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base<wchar_t>::char_type do_tolower(std::__ctype_abstract_base<wchar_t>::char_type __c) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_tolower(std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi) const = 0;
        virtual std::__ctype_abstract_base<wchar_t>::char_type do_widen(char __c) const = 0;
        virtual const char *do_widen(const char *__lo, const char *__hi, std::__ctype_abstract_base<wchar_t>::char_type *__to) const = 0;
        virtual char do_narrow(std::__ctype_abstract_base<wchar_t>::char_type __c, char __dfault) const = 0;
        virtual const std::__ctype_abstract_base<wchar_t>::char_type *do_narrow(const std::__ctype_abstract_base<wchar_t>::char_type *__lo, const std::__ctype_abstract_base<wchar_t>::char_type *__hi, char __dfault, char *__to) const = 0;
    };
    template <typename _CharT> class ctype : public __ctype_abstract_base<_CharT> {
    public:
        typedef _CharT char_type;
        typedef typename __ctype_abstract_base<_CharT>::mask mask;
        static locale::id id;
        explicit ctype<_CharT>(std::size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs)         {
        }
    protected:
        virtual ~ctype<_CharT>();
        virtual bool do_is(std::ctype::mask __m, std::ctype::char_type __c) const;
        virtual const std::ctype::char_type *do_is(const std::ctype::char_type *__lo, const std::ctype::char_type *__hi, std::ctype::mask *__vec) const;
        virtual const std::ctype::char_type *do_scan_is(std::ctype::mask __m, const std::ctype::char_type *__lo, const std::ctype::char_type *__hi) const;
        virtual const std::ctype::char_type *do_scan_not(std::ctype::mask __m, const std::ctype::char_type *__lo, const std::ctype::char_type *__hi) const;
        virtual std::ctype::char_type do_toupper(std::ctype::char_type __c) const;
        virtual const std::ctype::char_type *do_toupper(std::ctype::char_type *__lo, const std::ctype::char_type *__hi) const;
        virtual std::ctype::char_type do_tolower(std::ctype::char_type __c) const;
        virtual const std::ctype::char_type *do_tolower(std::ctype::char_type *__lo, const std::ctype::char_type *__hi) const;
        virtual std::ctype::char_type do_widen(char __c) const;
        virtual const char *do_widen(const char *__lo, const char *__hi, std::ctype::char_type *__dest) const;
        virtual char do_narrow(std::ctype::char_type, char __dfault) const;
        virtual const std::ctype::char_type *do_narrow(const std::ctype::char_type *__lo, const std::ctype::char_type *__hi, char __dfault, char *__to) const;
    };
    locale::id id;
    template<> class ctype<char> : public locale::facet, public std::ctype_base {
    public:
        typedef char char_type;
    protected:
        std::__c_locale _M_c_locale_ctype;
        bool _M_del;
        std::ctype_base::__to_type _M_toupper;
        std::ctype_base::__to_type _M_tolower;
        const std::ctype_base::mask *_M_table;
        mutable char _M_widen_ok;
        mutable char _M_widen[256];
        mutable char _M_narrow[256];
        mutable char _M_narrow_ok;
    public:
        static locale::id id;
        static const std::size_t table_size = 1 + static_cast<unsigned char>(-1);
        explicit ctype(const std::ctype_base::mask *__table = 0, bool __del = false, std::size_t __refs = 0);
        explicit ctype(std::__c_locale __cloc, const std::ctype_base::mask *__table = 0, bool __del = false, std::size_t __refs = 0);
        inline bool is(std::ctype_base::mask __m, char __c) const;
        inline const char *is(const char *__lo, const char *__hi, std::ctype_base::mask *__vec) const;
        inline const char *scan_is(std::ctype_base::mask __m, const char *__lo, const char *__hi) const;
        inline const char *scan_not(std::ctype_base::mask __m, const char *__lo, const char *__hi) const;
        std::ctype<char>::char_type toupper(std::ctype<char>::char_type __c) const         {
            return this->do_toupper(__c);
        }
        const std::ctype<char>::char_type *toupper(std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi) const         {
            return this->do_toupper(__lo, __hi);
        }
        std::ctype<char>::char_type tolower(std::ctype<char>::char_type __c) const         {
            return this->do_tolower(__c);
        }
        const std::ctype<char>::char_type *tolower(std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi) const         {
            return this->do_tolower(__lo, __hi);
        }
        std::ctype<char>::char_type widen(char __c) const         {
            if (this->_M_widen_ok)
                return this->_M_widen[static_cast<unsigned char>(__c)];
            this->_M_widen_init();
            return this->do_widen(__c);
        }
        const char *widen(const char *__lo, const char *__hi, std::ctype<char>::char_type *__to) const         {
            if (this->_M_widen_ok == 1) {
                if (__builtin_expect(__hi != __lo, true))
                    __builtin_memcpy(__to, __lo, __hi - __lo);
                return __hi;
            }
            if (!this->_M_widen_ok)
                this->_M_widen_init();
            return this->do_widen(__lo, __hi, __to);
        }
        char narrow(std::ctype<char>::char_type __c, char __dfault) const         {
            if (this->_M_narrow[static_cast<unsigned char>(__c)])
                return this->_M_narrow[static_cast<unsigned char>(__c)];
            const char __t = this->do_narrow(__c, __dfault);
            if (__t != __dfault)
                this->_M_narrow[static_cast<unsigned char>(__c)] = __t;
            return __t;
        }
        const std::ctype<char>::char_type *narrow(const std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi, char __dfault, char *__to) const         {
            if (__builtin_expect(this->_M_narrow_ok == 1, true)) {
                if (__builtin_expect(__hi != __lo, true))
                    __builtin_memcpy(__to, __lo, __hi - __lo);
                return __hi;
            }
            if (!this->_M_narrow_ok)
                this->_M_narrow_init();
            return this->do_narrow(__lo, __hi, __dfault, __to);
        }
        const std::ctype_base::mask *table() const throw()         {
            return this->_M_table;
        }
        static const std::ctype_base::mask *classic_table() throw();
    protected:
        virtual ~ctype<char>() noexcept;
        virtual std::ctype<char>::char_type do_toupper(std::ctype<char>::char_type __c) const;
        virtual const std::ctype<char>::char_type *do_toupper(std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi) const;
        virtual std::ctype<char>::char_type do_tolower(std::ctype<char>::char_type __c) const;
        virtual const std::ctype<char>::char_type *do_tolower(std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi) const;
        virtual std::ctype<char>::char_type do_widen(char __c) const         {
            return __c;
        }
        virtual const char *do_widen(const char *__lo, const char *__hi, std::ctype<char>::char_type *__to) const         {
            if (__builtin_expect(__hi != __lo, true))
                __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
        }
        virtual char do_narrow(std::ctype<char>::char_type __c, char __dfault __attribute__((unused))) const         {
            return __c;
        }
        virtual const std::ctype<char>::char_type *do_narrow(const std::ctype<char>::char_type *__lo, const std::ctype<char>::char_type *__hi, char __dfault __attribute__((unused)), char *__to) const         {
            if (__builtin_expect(__hi != __lo, true))
                __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
        }
    private:
        void _M_narrow_init() const;
        void _M_widen_init() const;
    };
    template<> class ctype<wchar_t> : public __ctype_abstract_base<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef wctype_t __wmask_type;
    protected:
        std::__c_locale _M_c_locale_ctype;
        bool _M_narrow_ok;
        char _M_narrow[128];
        wint_t _M_widen[256];
        std::ctype_base::mask _M_bit[16];
        std::ctype<wchar_t>::__wmask_type _M_wmask[16];
    public:
        static locale::id id;
        explicit ctype(std::size_t __refs = 0);
        explicit ctype(std::__c_locale __cloc, std::size_t __refs = 0);
    protected:
        std::ctype<wchar_t>::__wmask_type _M_convert_to_wmask(const std::ctype_base::mask __m) const throw();
        virtual ~ctype<wchar_t>() noexcept;
        virtual bool do_is(std::ctype_base::mask __m, std::ctype<wchar_t>::char_type __c) const;
        virtual const std::ctype<wchar_t>::char_type *do_is(const std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi, std::ctype_base::mask *__vec) const;
        virtual const std::ctype<wchar_t>::char_type *do_scan_is(std::ctype_base::mask __m, const std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi) const;
        virtual const std::ctype<wchar_t>::char_type *do_scan_not(std::ctype_base::mask __m, const std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi) const;
        virtual std::ctype<wchar_t>::char_type do_toupper(std::ctype<wchar_t>::char_type __c) const;
        virtual const std::ctype<wchar_t>::char_type *do_toupper(std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi) const;
        virtual std::ctype<wchar_t>::char_type do_tolower(std::ctype<wchar_t>::char_type __c) const;
        virtual const std::ctype<wchar_t>::char_type *do_tolower(std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi) const;
        virtual std::ctype<wchar_t>::char_type do_widen(char __c) const;
        virtual const char *do_widen(const char *__lo, const char *__hi, std::ctype<wchar_t>::char_type *__to) const;
        virtual char do_narrow(std::ctype<wchar_t>::char_type __c, char __dfault) const;
        virtual const std::ctype<wchar_t>::char_type *do_narrow(const std::ctype<wchar_t>::char_type *__lo, const std::ctype<wchar_t>::char_type *__hi, char __dfault, char *__to) const;
        void _M_initialize_ctype() throw();
    };
    template <typename _CharT> class ctype_byname : public ctype<_CharT> {
    public:
        typedef typename ctype<_CharT>::mask mask;
        explicit ctype_byname<_CharT>(const char *__s, std::size_t __refs = 0);
        explicit ctype_byname<_CharT>(const std::string &__s, std::size_t __refs = 0) : ctype_byname<_CharT>(__s.c_str(), __refs)         {
        }
    protected:
        virtual ~ctype_byname<_CharT>()         {
        }
    };
    template<> class ctype_byname<char> : public ctype<char> {
    public:
        explicit ctype_byname(const char *__s, std::size_t __refs = 0);
        explicit ctype_byname(const std::string &__s, std::size_t __refs = 0);
    protected:
        virtual ~ctype_byname<char>() noexcept;
    };
    template<> class ctype_byname<wchar_t> : public ctype<wchar_t> {
    public:
        explicit ctype_byname(const char *__s, std::size_t __refs = 0);
        explicit ctype_byname(const std::string &__s, std::size_t __refs = 0);
    protected:
        virtual ~ctype_byname<wchar_t>() noexcept;
    };
}
namespace std {
    bool ctype<char>::is(std::ctype_base::mask __m, char __c) const     {
        return this->_M_table[static_cast<unsigned char>(__c)] & __m;
    }
    const char *ctype<char>::is(const char *__low, const char *__high, std::ctype_base::mask *__vec) const     {
        while (__low < __high)
            *__vec++ = this->_M_table[static_cast<unsigned char>(*__low++)];
        return __high;
    }
    const char *ctype<char>::scan_is(std::ctype_base::mask __m, const char *__low, const char *__high) const     {
        while (__low < __high && !(this->_M_table[static_cast<unsigned char>(*__low)] & __m))
            ++__low;
        return __low;
    }
    const char *ctype<char>::scan_not(std::ctype_base::mask __m, const char *__low, const char *__high) const     {
        while (__low < __high && (this->_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
            ++__low;
        return __low;
    }
}
namespace std {
    class __num_base {
    public:
        enum  {
            _S_ominus,
            _S_oplus,
            _S_ox,
            _S_oX,
            _S_odigits,
            _S_odigits_end = _S_odigits + 16,
            _S_oudigits = _S_odigits_end,
            _S_oudigits_end = _S_oudigits + 16,
            _S_oe = _S_odigits + 14,
            _S_oE = _S_oudigits + 14,
            _S_oend = _S_oudigits_end
        };
        static const char *_S_atoms_out;
        static const char *_S_atoms_in;
        enum  {
            _S_iminus,
            _S_iplus,
            _S_ix,
            _S_iX,
            _S_izero,
            _S_ie = _S_izero + 14,
            _S_iE = _S_izero + 20,
            _S_iend = 26
        };
        static void _S_format_float(const std::ios_base &__io, char *__fptr, char __mod) throw();
    };
    template <typename _CharT> struct __numpunct_cache : public locale::facet {
        const char *_M_grouping;
        std::size_t _M_grouping_size;
        bool _M_use_grouping;
        const _CharT *_M_truename;
        std::size_t _M_truename_size;
        const _CharT *_M_falsename;
        std::size_t _M_falsename_size;
        _CharT _M_decimal_point;
        _CharT _M_thousands_sep;
        _CharT _M_atoms_out[36];
        _CharT _M_atoms_in[26];
        bool _M_allocated;
        __numpunct_cache<_CharT>(std::size_t __refs = 0) : std::locale::facet(__refs), _M_grouping(0), _M_grouping_size(0), _M_use_grouping(false), _M_truename(0), _M_truename_size(0), _M_falsename(0), _M_falsename_size(0), _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()), _M_allocated(false)         {
        }
        ~__numpunct_cache<_CharT>();
        void _M_cache(const std::locale &__loc);
    private:
        __numpunct_cache<_CharT> &operator=(const __numpunct_cache<_CharT> &);
        explicit __numpunct_cache<_CharT>(const __numpunct_cache<_CharT> &);
    };
    template <typename _CharT> __numpunct_cache<_CharT>::~__numpunct_cache<_CharT>()     {
        if (this->_M_allocated) {
            delete [] this->_M_grouping;
            delete [] this->_M_truename;
            delete [] this->_M_falsename;
        }
    }
    inline namespace __cxx11 {
        template <typename _CharT> class numpunct : public locale::facet {
        public:
            typedef _CharT char_type;
            typedef basic_string<_CharT> string_type;
            typedef __numpunct_cache<_CharT> __cache_type;
        protected:
            std::__cxx11::numpunct::__cache_type *_M_data;
        public:
            static locale::id id;
            explicit numpunct<_CharT>(std::size_t __refs = 0) : std::locale::facet(__refs), _M_data(0)             {
                this->_M_initialize_numpunct();
            }
            explicit numpunct<_CharT>(std::__cxx11::numpunct::__cache_type *__cache, std::size_t __refs = 0) : std::locale::facet(__refs), _M_data(__cache)             {
                this->_M_initialize_numpunct();
            }
            explicit numpunct<_CharT>(std::__c_locale __cloc, std::size_t __refs = 0) : std::locale::facet(__refs), _M_data(0)             {
                this->_M_initialize_numpunct(__cloc);
            }
            std::__cxx11::numpunct::char_type decimal_point() const             {
                return this->do_decimal_point();
            }
            std::__cxx11::numpunct::char_type thousands_sep() const             {
                return this->do_thousands_sep();
            }
            std::string grouping() const             {
                return this->do_grouping();
            }
            std::__cxx11::numpunct::string_type truename() const             {
                return this->do_truename();
            }
            std::__cxx11::numpunct::string_type falsename() const             {
                return this->do_falsename();
            }
        protected:
            virtual ~numpunct<_CharT>();
            virtual std::__cxx11::numpunct::char_type do_decimal_point() const             {
                return this->_M_data->_M_decimal_point;
            }
            virtual std::__cxx11::numpunct::char_type do_thousands_sep() const             {
                return this->_M_data->_M_thousands_sep;
            }
            virtual std::string do_grouping() const             {
                return this->_M_data->_M_grouping;
            }
            virtual std::__cxx11::numpunct::string_type do_truename() const             {
                return this->_M_data->_M_truename;
            }
            virtual std::__cxx11::numpunct::string_type do_falsename() const             {
                return this->_M_data->_M_falsename;
            }
            void _M_initialize_numpunct(std::__c_locale __cloc = 0);
        };
        locale::id id;
        template <> numpunct<char>::~numpunct<char>() noexcept;
        template <> void numpunct<char>::_M_initialize_numpunct(std::__c_locale __cloc);
        template <> numpunct<wchar_t>::~numpunct<wchar_t>() noexcept;
        template <> void numpunct<wchar_t>::_M_initialize_numpunct(std::__c_locale __cloc);
        template <typename _CharT> class numpunct_byname : public numpunct<_CharT> {
        public:
            typedef _CharT char_type;
            typedef basic_string<_CharT> string_type;
            explicit numpunct_byname<_CharT>(const char *__s, std::size_t __refs = 0) : numpunct<_CharT>(__refs)             {
                if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0) {
                    std::__c_locale __tmp;
                    this->_S_create_c_locale(__tmp, __s);
                    this->_M_initialize_numpunct(__tmp);
                    this->_S_destroy_c_locale(__tmp);
                }
            }
            explicit numpunct_byname<_CharT>(const std::string &__s, std::size_t __refs = 0) : numpunct_byname<_CharT>(__s.c_str(), __refs)             {
            }
        protected:
            virtual ~numpunct_byname<_CharT>()             {
            }
        };
    }
    template <typename _CharT, typename _InIter = istreambuf_iterator<_CharT>> class num_get : public locale::facet {
    public:
        typedef _CharT char_type;
        typedef _InIter iter_type;
        static locale::id id;
        explicit num_get<_CharT, _InIter>(std::size_t __refs = 0) : std::locale::facet(__refs)         {
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
        std::num_get::iter_type get(std::num_get::iter_type __in, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const         {
            return this->do_get(__in, __end, __io, __err, __v);
        }
    protected:
        virtual ~num_get<_CharT, _InIter>()         {
        }
        std::num_get::iter_type _M_extract_float(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, std::string &) const __attribute__((abi_tag("cxx11")));
        template <typename _ValueT> std::num_get::iter_type _M_extract_int(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, _ValueT &) const __attribute__((abi_tag("cxx11")));
        template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, std::size_t __len, _CharT2 __c) const         {
            int __ret = -1;
            if (__len <= 10) {
                if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
                    __ret = __c - _CharT2('0');
            } else {
                if (__c >= _CharT2('0') && __c <= _CharT2('9'))
                    __ret = __c - _CharT2('0');
                else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
                    __ret = 10 + (__c - _CharT2('a'));
                else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
                    __ret = 10 + (__c - _CharT2('A'));
            }
            return __ret;
        }
        template <typename _CharT2> typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, std::size_t __len, _CharT2 __c) const         {
            int __ret = -1;
            const std::num_get::char_type *__q = char_traits<_CharT2>::find(__zero, __len, __c);
            if (__q) {
                __ret = __q - __zero;
                if (__ret > 15)
                    __ret -= 6;
            }
            return __ret;
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, bool &) const;
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const         {
            return _M_extract_int(__beg, __end, __io, __err, __v);
        }
        virtual std::num_get::iter_type do_get(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, float &) const;
        virtual std::num_get::iter_type do_get(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, double &) const;
        virtual std::num_get::iter_type do_get(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, long double &) const;
        virtual std::num_get::iter_type do_get(std::num_get::iter_type, std::num_get::iter_type, std::ios_base &, ios_base::iostate &, void *&) const;
    };
    locale::id id;
    template <typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT>> class num_put : public locale::facet {
    public:
        typedef _CharT char_type;
        typedef _OutIter iter_type;
        static locale::id id;
        explicit num_put<_CharT, _OutIter>(std::size_t __refs = 0) : std::locale::facet(__refs)         {
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, bool __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, unsigned long __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long long __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, unsigned long long __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, double __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long double __v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
        std::num_put::iter_type put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, const void *__v) const         {
            return this->do_put(__s, __io, __fill, __v);
        }
    protected:
        template <typename _ValueT> std::num_put::iter_type _M_insert_float(std::num_put::iter_type, std::ios_base &__io, std::num_put::char_type __fill, char __mod, _ValueT __v) const;
        void _M_group_float(const char *__grouping, std::size_t __grouping_size, std::num_put::char_type __sep, const std::num_put::char_type *__p, std::num_put::char_type *__new, std::num_put::char_type *__cs, int &__len) const;
        template <typename _ValueT> std::num_put::iter_type _M_insert_int(std::num_put::iter_type, std::ios_base &__io, std::num_put::char_type __fill, _ValueT __v) const;
        void _M_group_int(const char *__grouping, std::size_t __grouping_size, std::num_put::char_type __sep, std::ios_base &__io, std::num_put::char_type *__new, std::num_put::char_type *__cs, int &__len) const;
        void _M_pad(std::num_put::char_type __fill, std::streamsize __w, std::ios_base &__io, std::num_put::char_type *__new, const std::num_put::char_type *__cs, int &__len) const;
        virtual ~num_put<_CharT, _OutIter>()         {
        }
        virtual std::num_put::iter_type do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, bool __v) const;
        virtual std::num_put::iter_type do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long __v) const         {
            return _M_insert_int(__s, __io, __fill, __v);
        }
        virtual std::num_put::iter_type do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, unsigned long __v) const         {
            return _M_insert_int(__s, __io, __fill, __v);
        }
        virtual std::num_put::iter_type do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long long __v) const         {
            return _M_insert_int(__s, __io, __fill, __v);
        }
        virtual std::num_put::iter_type do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, unsigned long long __v) const         {
            return _M_insert_int(__s, __io, __fill, __v);
        }
        virtual std::num_put::iter_type do_put(std::num_put::iter_type, std::ios_base &, std::num_put::char_type, double) const;
        virtual std::num_put::iter_type do_put(std::num_put::iter_type, std::ios_base &, std::num_put::char_type, long double) const;
        virtual std::num_put::iter_type do_put(std::num_put::iter_type, std::ios_base &, std::num_put::char_type, const void *) const;
    };
    locale::id id;
    template <typename _CharT> inline bool isspace(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);
    }
    template <typename _CharT> inline bool isprint(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);
    }
    template <typename _CharT> inline bool iscntrl(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);
    }
    template <typename _CharT> inline bool isupper(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);
    }
    template <typename _CharT> inline bool islower(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);
    }
    template <typename _CharT> inline bool isalpha(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);
    }
    template <typename _CharT> inline bool isdigit(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);
    }
    template <typename _CharT> inline bool ispunct(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);
    }
    template <typename _CharT> inline bool isxdigit(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);
    }
    template <typename _CharT> inline bool isalnum(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);
    }
    template <typename _CharT> inline bool isgraph(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);
    }
    template <typename _CharT> inline bool isblank(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).is(ctype_base::blank, __c);
    }
    template <typename _CharT> inline _CharT toupper(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).toupper(__c);
    }
    template <typename _CharT> inline _CharT tolower(_CharT __c, const std::locale &__loc)     {
        return use_facet<ctype<_CharT> >(__loc).tolower(__c);
    }
}
namespace std {
    template <typename _Facet> struct __use_cache {
        const _Facet *operator()(const std::locale &__loc) const;
    };
    template <typename _CharT> struct __use_cache<__numpunct_cache<_CharT>> {
        const __numpunct_cache<_CharT> *operator()(const std::locale &__loc) const         {
            const std::size_t __i = numpunct<_CharT>::id._M_id();
            const locale::facet **__caches = __loc._M_impl->_M_caches;
            if (!__caches[__i]) {
                __numpunct_cache<_CharT> *__tmp = 0;
                try {
                    __tmp = new __numpunct_cache<_CharT>;
                    __tmp->_M_cache(__loc);
                } catch (...) {
                    delete __tmp;
                    throw;
                }
                __loc._M_impl->_M_install_cache(__tmp, __i);
            }
            return static_cast<const __numpunct_cache<_CharT> *>(__caches[__i]);
        }
    };
    template <typename _CharT> void __numpunct_cache<_CharT>::_M_cache(const std::locale &__loc)     {
        const numpunct<_CharT> &__np = use_facet<numpunct<_CharT> >(__loc);
        char *__grouping = 0;
        _CharT *__truename = 0;
        _CharT *__falsename = 0;
        try {
            const std::string &__g = __np.grouping();
            this->_M_grouping_size = __g.size();
            __grouping = new char [this->_M_grouping_size];
            __g.copy(__grouping, this->_M_grouping_size);
            this->_M_use_grouping = (this->_M_grouping_size && static_cast<signed char>(__grouping[0]) > 0 && (__grouping[0] != __gnu_cxx::__numeric_traits<char>::__max));
            const basic_string<_CharT> &__tn = __np.truename();
            this->_M_truename_size = __tn.size();
            __truename = new _CharT [this->_M_truename_size];
            __tn.copy(__truename, this->_M_truename_size);
            const basic_string<_CharT> &__fn = __np.falsename();
            this->_M_falsename_size = __fn.size();
            __falsename = new _CharT [this->_M_falsename_size];
            __fn.copy(__falsename, this->_M_falsename_size);
            this->_M_decimal_point = __np.decimal_point();
            this->_M_thousands_sep = __np.thousands_sep();
            const ctype<_CharT> &__ct = use_facet<ctype<_CharT> >(__loc);
            __ct.widen(__num_base::_S_atoms_out, __num_base::_S_atoms_out + __num_base::_S_oend, this->_M_atoms_out);
            __ct.widen(__num_base::_S_atoms_in, __num_base::_S_atoms_in + __num_base::_S_iend, this->_M_atoms_in);
            this->_M_grouping = __grouping;
            this->_M_truename = __truename;
            this->_M_falsename = __falsename;
            this->_M_allocated = true;
        } catch (...) {
            delete [] __grouping;
            delete [] __truename;
            delete [] __falsename;
            throw;
        }
    }
    bool __verify_grouping(const char *__grouping, std::size_t __grouping_size, const std::string &__grouping_tmp) throw() __attribute__((pure));
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::_M_extract_float(_InIter __beg, _InIter __end, std::ios_base &__io, ios_base::iostate &__err, std::string &__xtrc) const __attribute__((abi_tag("cxx11")))     {
        typedef char_traits<_CharT> __traits_type;
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const std::locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const _CharT *__lit = __lc->_M_atoms_in;
        std::num_get::char_type __c = std::num_get::char_type();
        bool __testeof = __beg == __end;
        if (!__testeof) {
            __c = *__beg;
            const bool __plus = __c == __lit[__num_base::_S_iplus];
            if ((__plus || __c == __lit[__num_base::_S_iminus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) && !(__c == __lc->_M_decimal_point)) {
                __xtrc += __plus ? '+' : '-';
                if (++__beg != __end)
                    __c = *__beg;
                else
                    __testeof = true;
            }
        }
        bool __found_mantissa = false;
        int __sep_pos = 0;
        while (!__testeof)
            {
                if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) || __c == __lc->_M_decimal_point)
                    break;
                else if (__c == __lit[__num_base::_S_izero]) {
                    if (!__found_mantissa) {
                        __xtrc += '0';
                        __found_mantissa = true;
                    }
                    ++__sep_pos;
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                } else
                    break;
            }
        bool __found_dec = false;
        bool __found_sci = false;
        std::string __found_grouping;
        if (__lc->_M_use_grouping)
            __found_grouping.reserve(32);
        const std::num_get::char_type *__lit_zero = __lit + __num_base::_S_izero;
        if (!__lc->_M_allocated)
            while (!__testeof)
                {
                    const int __digit = _M_find(__lit_zero, 10, __c);
                    if (__digit != -1) {
                        __xtrc += '0' + __digit;
                        __found_mantissa = true;
                    } else if (__c == __lc->_M_decimal_point && !__found_dec && !__found_sci) {
                        __xtrc += '.';
                        __found_dec = true;
                    } else if ((__c == __lit[__num_base::_S_ie] || __c == __lit[__num_base::_S_iE]) && !__found_sci && __found_mantissa) {
                        __xtrc += 'e';
                        __found_sci = true;
                        if (++__beg != __end) {
                            __c = *__beg;
                            const bool __plus = __c == __lit[__num_base::_S_iplus];
                            if (__plus || __c == __lit[__num_base::_S_iminus])
                                __xtrc += __plus ? '+' : '-';
                            else
                                continue;
                        } else {
                            __testeof = true;
                            break;
                        }
                    } else
                        break;
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        else
            while (!__testeof)
                {
                    if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) {
                        if (!__found_dec && !__found_sci) {
                            if (__sep_pos) {
                                __found_grouping += static_cast<char>(__sep_pos);
                                __sep_pos = 0;
                            } else {
                                __xtrc.clear();
                                break;
                            }
                        } else
                            break;
                    } else if (__c == __lc->_M_decimal_point) {
                        if (!__found_dec && !__found_sci) {
                            if (__found_grouping.size())
                                __found_grouping += static_cast<char>(__sep_pos);
                            __xtrc += '.';
                            __found_dec = true;
                        } else
                            break;
                    } else {
                        const std::num_get::char_type *__q = __traits_type::find(__lit_zero, 10, __c);
                        if (__q) {
                            __xtrc += '0' + (__q - __lit_zero);
                            __found_mantissa = true;
                            ++__sep_pos;
                        } else if ((__c == __lit[__num_base::_S_ie] || __c == __lit[__num_base::_S_iE]) && !__found_sci && __found_mantissa) {
                            if (__found_grouping.size() && !__found_dec)
                                __found_grouping += static_cast<char>(__sep_pos);
                            __xtrc += 'e';
                            __found_sci = true;
                            if (++__beg != __end) {
                                __c = *__beg;
                                const bool __plus = __c == __lit[__num_base::_S_iplus];
                                if ((__plus || __c == __lit[__num_base::_S_iminus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) && !(__c == __lc->_M_decimal_point))
                                    __xtrc += __plus ? '+' : '-';
                                else
                                    continue;
                            } else {
                                __testeof = true;
                                break;
                            }
                        } else
                            break;
                    }
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        if (__found_grouping.size()) {
            if (!__found_dec && !__found_sci)
                __found_grouping += static_cast<char>(__sep_pos);
            if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size, __found_grouping))
                __err = ios_base::failbit;
        }
        return __beg;
    }
    template <typename _CharT, typename _InIter> template <typename _ValueT> _InIter num_get<_CharT, _InIter>::_M_extract_int(_InIter __beg, _InIter __end, std::ios_base &__io, ios_base::iostate &__err, _ValueT &__v) const __attribute__((abi_tag("cxx11")))     {
        typedef char_traits<_CharT> __traits_type;
        using __gnu_cxx::__add_unsigned;
        typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const std::locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const _CharT *__lit = __lc->_M_atoms_in;
        std::num_get::char_type __c = std::num_get::char_type();
        const ios_base::fmtflags __basefield = __io.flags() & ios_base::basefield;
        const bool __oct = __basefield == ios_base::oct;
        int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);
        bool __testeof = __beg == __end;
        bool __negative = false;
        if (!__testeof) {
            __c = *__beg;
            __negative = __c == __lit[__num_base::_S_iminus];
            if ((__negative || __c == __lit[__num_base::_S_iplus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) && !(__c == __lc->_M_decimal_point)) {
                if (++__beg != __end)
                    __c = *__beg;
                else
                    __testeof = true;
            }
        }
        bool __found_zero = false;
        int __sep_pos = 0;
        while (!__testeof)
            {
                if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) || __c == __lc->_M_decimal_point)
                    break;
                else if (__c == __lit[__num_base::_S_izero] && (!__found_zero || __base == 10)) {
                    __found_zero = true;
                    ++__sep_pos;
                    if (__basefield == 0)
                        __base = 8;
                    if (__base == 8)
                        __sep_pos = 0;
                } else if (__found_zero && (__c == __lit[__num_base::_S_ix] || __c == __lit[__num_base::_S_iX])) {
                    if (__basefield == 0)
                        __base = 16;
                    if (__base == 16) {
                        __found_zero = false;
                        __sep_pos = 0;
                    } else
                        break;
                } else
                    break;
                if (++__beg != __end) {
                    __c = *__beg;
                    if (!__found_zero)
                        break;
                } else
                    __testeof = true;
            }
        const std::size_t __len = (__base == 16 ? __num_base::_S_iend - __num_base::_S_izero : __base);
        typedef __gnu_cxx::__numeric_traits<_ValueT> __num_traits;
        std::string __found_grouping;
        if (__lc->_M_use_grouping)
            __found_grouping.reserve(32);
        bool __testfail = false;
        bool __testoverflow = false;
        const __unsigned_type __max = (__negative && __num_traits::__is_signed) ? - static_cast<__unsigned_type>(__num_traits::__min) : __num_traits::__max;
        const __unsigned_type __smax = __max / __base;
        __unsigned_type __result = 0;
        int __digit = 0;
        const std::num_get::char_type *__lit_zero = __lit + __num_base::_S_izero;
        if (!__lc->_M_allocated)
            while (!__testeof)
                {
                    __digit = _M_find(__lit_zero, __len, __c);
                    if (__digit == -1)
                        break;
                    if (__result > __smax)
                        __testoverflow = true;
                    else {
                        __result *= __base;
                        __testoverflow |= __result > __max - __digit;
                        __result += __digit;
                        ++__sep_pos;
                    }
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        else
            while (!__testeof)
                {
                    if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) {
                        if (__sep_pos) {
                            __found_grouping += static_cast<char>(__sep_pos);
                            __sep_pos = 0;
                        } else {
                            __testfail = true;
                            break;
                        }
                    } else if (__c == __lc->_M_decimal_point)
                        break;
                    else {
                        const std::num_get::char_type *__q = __traits_type::find(__lit_zero, __len, __c);
                        if (!__q)
                            break;
                        __digit = __q - __lit_zero;
                        if (__digit > 15)
                            __digit -= 6;
                        if (__result > __smax)
                            __testoverflow = true;
                        else {
                            __result *= __base;
                            __testoverflow |= __result > __max - __digit;
                            __result += __digit;
                            ++__sep_pos;
                        }
                    }
                    if (++__beg != __end)
                        __c = *__beg;
                    else
                        __testeof = true;
                }
        if (__found_grouping.size()) {
            __found_grouping += static_cast<char>(__sep_pos);
            if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size, __found_grouping))
                __err = ios_base::failbit;
        }
        if ((!__sep_pos && !__found_zero && !__found_grouping.size()) || __testfail) {
            __v = 0;
            __err = ios_base::failbit;
        } else if (__testoverflow) {
            if (__negative && __num_traits::__is_signed)
                __v = __num_traits::__min;
            else
                __v = __num_traits::__max;
            __err = ios_base::failbit;
        } else
            __v = __negative ? - __result : __result;
        if (__testeof)
            __err |= ios_base::eofbit;
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const     {
        if (!(__io.flags() & ios_base::boolalpha)) {
            long __l = -1;
            __beg = _M_extract_int(__beg, __end, __io, __err, __l);
            if (__l == 0 || __l == 1)
                __v = bool(__l);
            else {
                __v = true;
                __err = ios_base::failbit;
                if (__beg == __end)
                    __err |= ios_base::eofbit;
            }
        } else {
            typedef __numpunct_cache<_CharT> __cache_type;
            __use_cache<__cache_type> __uc;
            const std::locale &__loc = __io._M_getloc();
            const __cache_type *__lc = __uc(__loc);
            bool __testf = true;
            bool __testt = true;
            bool __donef = __lc->_M_falsename_size == 0;
            bool __donet = __lc->_M_truename_size == 0;
            bool __testeof = false;
            std::size_t __n = 0;
            while (!__donef || !__donet)
                {
                    if (__beg == __end) {
                        __testeof = true;
                        break;
                    }
                    const std::num_get::char_type __c = *__beg;
                    if (!__donef)
                        __testf = __c == __lc->_M_falsename[__n];
                    if (!__testf && __donet)
                        break;
                    if (!__donet)
                        __testt = __c == __lc->_M_truename[__n];
                    if (!__testt && __donef)
                        break;
                    if (!__testt && !__testf)
                        break;
                    ++__n;
                    ++__beg;
                    __donef = !__testf || __n >= __lc->_M_falsename_size;
                    __donet = !__testt || __n >= __lc->_M_truename_size;
                }
            if (__testf && __n == __lc->_M_falsename_size && __n) {
                __v = false;
                if (__testt && __n == __lc->_M_truename_size)
                    __err = ios_base::failbit;
                else
                    __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
            } else if (__testt && __n == __lc->_M_truename_size && __n) {
                __v = true;
                __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
            } else {
                __v = false;
                __err = ios_base::failbit;
                if (__testeof)
                    __err |= ios_base::eofbit;
            }
        }
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const     {
        std::string __xtrc;
        __xtrc.reserve(32);
        __beg = this->_M_extract_float(__beg, __end, __io, __err, __xtrc);
        std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
        if (__beg == __end)
            __err |= ios_base::eofbit;
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const     {
        std::string __xtrc;
        __xtrc.reserve(32);
        __beg = this->_M_extract_float(__beg, __end, __io, __err, __xtrc);
        std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
        if (__beg == __end)
            __err |= ios_base::eofbit;
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const     {
        std::string __xtrc;
        __xtrc.reserve(32);
        __beg = this->_M_extract_float(__beg, __end, __io, __err, __xtrc);
        std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
        if (__beg == __end)
            __err |= ios_base::eofbit;
        return __beg;
    }
    template <typename _CharT, typename _InIter> _InIter num_get<_CharT, _InIter>::do_get(std::num_get::iter_type __beg, std::num_get::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const     {
        typedef ios_base::fmtflags fmtflags;
        const fmtflags __fmt = __io.flags();
        __io.flags((__fmt & ~ ios_base::basefield) | ios_base::hex);
        typedef __gnu_cxx::__conditional_type<(sizeof(void *) <= sizeof(unsigned long)), unsigned long, unsigned long long>::__type _UIntPtrType;
        _UIntPtrType __ul;
        __beg = _M_extract_int(__beg, __end, __io, __err, __ul);
        __io.flags(__fmt);
        __v = reinterpret_cast<void *>(__ul);
        return __beg;
    }
    template <typename _CharT, typename _OutIter> void num_put<_CharT, _OutIter>::_M_pad(_CharT __fill, std::streamsize __w, std::ios_base &__io, _CharT *__new, const _CharT *__cs, int &__len) const     {
        __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new, __cs, __w, __len);
        __len = static_cast<int>(__w);
    }
    template <typename _CharT, typename _ValueT> int __int_to_char(_CharT *__bufend, _ValueT __v, const _CharT *__lit, ios_base::fmtflags __flags, bool __dec)     {
        _CharT *__buf = __bufend;
        if (__builtin_expect(__dec, true)) {
            do {
                *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
                __v /= 10;
            } while (__v != 0);
        } else if ((__flags & ios_base::basefield) == ios_base::oct) {
            do {
                *--__buf = __lit[(__v & 7) + __num_base::_S_odigits];
                __v >>= 3;
            } while (__v != 0);
        } else {
            const bool __uppercase = __flags & ios_base::uppercase;
            const int __case_offset = __uppercase ? __num_base::_S_oudigits : __num_base::_S_odigits;
            do {
                *--__buf = __lit[(__v & 15) + __case_offset];
                __v >>= 4;
            } while (__v != 0);
        }
        return __bufend - __buf;
    }
    template <typename _CharT, typename _OutIter> void num_put<_CharT, _OutIter>::_M_group_int(const char *__grouping, std::size_t __grouping_size, _CharT __sep, std::ios_base &, _CharT *__new, _CharT *__cs, int &__len) const     {
        _CharT *__p = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __len);
        __len = __p - __new;
    }
    template <typename _CharT, typename _OutIter> template <typename _ValueT> _OutIter num_put<_CharT, _OutIter>::_M_insert_int(_OutIter __s, std::ios_base &__io, _CharT __fill, _ValueT __v) const     {
        using __gnu_cxx::__add_unsigned;
        typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const std::locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const _CharT *__lit = __lc->_M_atoms_out;
        const ios_base::fmtflags __flags = __io.flags();
        const int __ilen = 5 * sizeof(_ValueT);
        _CharT *__cs = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __ilen));
        const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
        const bool __dec = (__basefield != ios_base::oct && __basefield != ios_base::hex);
        const __unsigned_type __u = ((__v > 0 || !__dec) ? __unsigned_type(__v) : - __unsigned_type(__v));
        int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
        __cs += __ilen - __len;
        if (__lc->_M_use_grouping) {
            _CharT *__cs2 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * (__len + 1) * 2));
            this->_M_group_int(__lc->_M_grouping, __lc->_M_grouping_size, __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
            __cs = __cs2 + 2;
        }
        if (__builtin_expect(__dec, true)) {
            if (__v >= 0) {
                if (bool(__flags & ios_base::showpos) && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
                    *--__cs = __lit[__num_base::_S_oplus] , ++__len;
            } else
                *--__cs = __lit[__num_base::_S_ominus] , ++__len;
        } else if (bool(__flags & ios_base::showbase) && __v) {
            if (__basefield == ios_base::oct)
                *--__cs = __lit[__num_base::_S_odigits] , ++__len;
            else {
                const bool __uppercase = __flags & ios_base::uppercase;
                *--__cs = __lit[__num_base::_S_ox + __uppercase];
                *--__cs = __lit[__num_base::_S_odigits];
                __len += 2;
            }
        }
        const std::streamsize __w = __io.width();
        if (__w > static_cast<std::streamsize>(__len)) {
            _CharT *__cs3 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __w));
            this->_M_pad(__fill, __w, __io, __cs3, __cs, __len);
            __cs = __cs3;
        }
        __io.width(0);
        return std::__write(__s, __cs, __len);
    }
    template <typename _CharT, typename _OutIter> void num_put<_CharT, _OutIter>::_M_group_float(const char *__grouping, std::size_t __grouping_size, _CharT __sep, const _CharT *__p, _CharT *__new, _CharT *__cs, int &__len) const     {
        const int __declen = __p ? __p - __cs : __len;
        _CharT *__p2 = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __declen);
        int __newlen = __p2 - __new;
        if (__p) {
            char_traits<_CharT>::copy(__p2, __p, __len - __declen);
            __newlen += __len - __declen;
        }
        __len = __newlen;
    }
    template <typename _CharT, typename _OutIter> template <typename _ValueT> _OutIter num_put<_CharT, _OutIter>::_M_insert_float(_OutIter __s, std::ios_base &__io, _CharT __fill, char __mod, _ValueT __v) const     {
        typedef __numpunct_cache<_CharT> __cache_type;
        __use_cache<__cache_type> __uc;
        const std::locale &__loc = __io._M_getloc();
        const __cache_type *__lc = __uc(__loc);
        const std::streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();
        const int __max_digits = __gnu_cxx::__numeric_traits<_ValueT>::__digits10;
        int __len;
        char __fbuf[16];
        __num_base::_S_format_float(__io, __fbuf, __mod);
        const bool __use_prec = (__io.flags() & ios_base::floatfield) != ios_base::floatfield;
        int __cs_size = __max_digits * 3;
        char *__cs = static_cast<char *>(__builtin_alloca(__cs_size));
        if (__use_prec)
            __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v);
        else
            __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __v);
        if (__len >= __cs_size) {
            __cs_size = __len + 1;
            __cs = static_cast<char *>(__builtin_alloca(__cs_size));
            if (__use_prec)
                __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v);
            else
                __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __v);
        }
        const ctype<_CharT> &__ctype = use_facet<ctype<_CharT> >(__loc);
        _CharT *__ws = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __len));
        __ctype.widen(__cs, __cs + __len, __ws);
        _CharT *__wp = 0;
        const char *__p = char_traits<char>::find(__cs, __len, '.');
        if (__p) {
            __wp = __ws + (__p - __cs);
            *__wp = __lc->_M_decimal_point;
        }
        if (__lc->_M_use_grouping && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9' && __cs[1] >= '0' && __cs[2] >= '0'))) {
            _CharT *__ws2 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __len * 2));
            std::streamsize __off = 0;
            if (__cs[0] == '-' || __cs[0] == '+') {
                __off = 1;
                __ws2[0] = __ws[0];
                __len -= 1;
            }
            this->_M_group_float(__lc->_M_grouping, __lc->_M_grouping_size, __lc->_M_thousands_sep, __wp, __ws2 + __off, __ws + __off, __len);
            __len += __off;
            __ws = __ws2;
        }
        const std::streamsize __w = __io.width();
        if (__w > static_cast<std::streamsize>(__len)) {
            _CharT *__ws3 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __w));
            this->_M_pad(__fill, __w, __io, __ws3, __ws, __len);
            __ws = __ws3;
        }
        __io.width(0);
        return std::__write(__s, __ws, __len);
    }
    template <typename _CharT, typename _OutIter> _OutIter num_put<_CharT, _OutIter>::do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, bool __v) const     {
        const ios_base::fmtflags __flags = __io.flags();
        if ((__flags & ios_base::boolalpha) == 0) {
            const long __l = __v;
            __s = _M_insert_int(__s, __io, __fill, __l);
        } else {
            typedef __numpunct_cache<_CharT> __cache_type;
            __use_cache<__cache_type> __uc;
            const std::locale &__loc = __io._M_getloc();
            const __cache_type *__lc = __uc(__loc);
            const _CharT *__name = __v ? __lc->_M_truename : __lc->_M_falsename;
            int __len = __v ? __lc->_M_truename_size : __lc->_M_falsename_size;
            const std::streamsize __w = __io.width();
            if (__w > static_cast<std::streamsize>(__len)) {
                const std::streamsize __plen = __w - __len;
                _CharT *__ps = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __plen));
                char_traits<_CharT>::assign(__ps, __plen, __fill);
                __io.width(0);
                if ((__flags & ios_base::adjustfield) == ios_base::left) {
                    __s = std::__write(__s, __name, __len);
                    __s = std::__write(__s, __ps, __plen);
                } else {
                    __s = std::__write(__s, __ps, __plen);
                    __s = std::__write(__s, __name, __len);
                }
                return __s;
            }
            __io.width(0);
            __s = std::__write(__s, __name, __len);
        }
        return __s;
    }
    template <typename _CharT, typename _OutIter> _OutIter num_put<_CharT, _OutIter>::do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, double __v) const     {
        return _M_insert_float(__s, __io, __fill, char(), __v);
    }
    template <typename _CharT, typename _OutIter> _OutIter num_put<_CharT, _OutIter>::do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, long double __v) const     {
        return _M_insert_float(__s, __io, __fill, 'L', __v);
    }
    template <typename _CharT, typename _OutIter> _OutIter num_put<_CharT, _OutIter>::do_put(std::num_put::iter_type __s, std::ios_base &__io, std::num_put::char_type __fill, const void *__v) const     {
        const ios_base::fmtflags __flags = __io.flags();
        const ios_base::fmtflags __fmt = ~ (ios_base::basefield | ios_base::uppercase);
        __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));
        typedef __gnu_cxx::__conditional_type<(sizeof(const void *) <= sizeof(unsigned long)), unsigned long, unsigned long long>::__type _UIntPtrType;
        __s = _M_insert_int(__s, __io, __fill, reinterpret_cast<_UIntPtrType>(__v));
        __io.flags(__flags);
        return __s;
    }
    template <typename _CharT, typename _Traits> void __pad<_CharT, _Traits>::_S_pad(std::ios_base &__io, _CharT __fill, _CharT *__news, const _CharT *__olds, std::streamsize __newlen, std::streamsize __oldlen)     {
        const std::size_t __plen = static_cast<std::size_t>(__newlen - __oldlen);
        const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;
        if (__adjust == ios_base::left) {
            _Traits::copy(__news, __olds, __oldlen);
            _Traits::assign(__news + __oldlen, __plen, __fill);
            return;
        }
        std::size_t __mod = 0;
        if (__adjust == ios_base::internal) {
            const std::locale &__loc = __io._M_getloc();
            const ctype<_CharT> &__ctype = use_facet<ctype<_CharT> >(__loc);
            if (__ctype.widen('-') == __olds[0] || __ctype.widen('+') == __olds[0]) {
                __news[0] = __olds[0];
                __mod = 1;
                ++__news;
            } else if (__ctype.widen('0') == __olds[0] && __oldlen > 1 && (__ctype.widen('x') == __olds[1] || __ctype.widen('X') == __olds[1])) {
                __news[0] = __olds[0];
                __news[1] = __olds[1];
                __mod = 2;
                __news += 2;
            }
        }
        _Traits::assign(__news, __plen, __fill);
        _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }
    template <typename _CharT> _CharT *__add_grouping(_CharT *__s, _CharT __sep, const char *__gbeg, std::size_t __gsize, const _CharT *__first, const _CharT *__last)     {
        std::size_t __idx = 0;
        std::size_t __ctr = 0;
        while (__last - __first > __gbeg[__idx] && static_cast<signed char>(__gbeg[__idx]) > 0 && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
            {
                __last -= __gbeg[__idx];
                __idx < __gsize - 1 ? ++__idx : ++__ctr;
            }
        while (__first != __last)
            *__s++ = *__first++;
        while (__ctr--)
            {
                *__s++ = __sep;
                for (char __i = __gbeg[__idx]; __i > 0; --__i)
                    *__s++ = *__first++;
            }
        while (__idx--)
            {
                *__s++ = __sep;
                for (char __i = __gbeg[__idx]; __i > 0; --__i)
                    *__s++ = *__first++;
            }
        return __s;
    }
    template<> class numpunct<char> : public locale::facet {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
        typedef __numpunct_cache<char> __cache_type;
    protected:
        std::__cxx11::numpunct<char>::__cache_type *_M_data;
    public:
        static locale::id id;
        explicit numpunct(std::size_t __refs);
        explicit numpunct(std::__cxx11::numpunct<char>::__cache_type *__cache, std::size_t __refs);
        explicit numpunct(std::__c_locale __cloc, std::size_t __refs);
        std::__cxx11::numpunct<char>::char_type decimal_point() const;
        std::__cxx11::numpunct<char>::char_type thousands_sep() const;
        std::string grouping() const;
        std::__cxx11::numpunct<char>::string_type truename() const;
        std::__cxx11::numpunct<char>::string_type falsename() const;
    protected:
        virtual ~numpunct<char>() noexcept;
        virtual std::__cxx11::numpunct<char>::char_type do_decimal_point() const;
        virtual std::__cxx11::numpunct<char>::char_type do_thousands_sep() const;
        virtual std::string do_grouping() const;
        virtual std::__cxx11::numpunct<char>::string_type do_truename() const;
        virtual std::__cxx11::numpunct<char>::string_type do_falsename() const;
        void _M_initialize_numpunct(std::__c_locale __cloc);
    };
    template<> class numpunct_byname<char> : public numpunct<char> {
    public:
        typedef char char_type;
        typedef basic_string<char> string_type;
        explicit numpunct_byname(const char *__s, std::size_t __refs);
        explicit numpunct_byname(const std::string &__s, std::size_t __refs);
    protected:
        virtual ~numpunct_byname<char>() noexcept;
    };
    template<> class num_get<char> : public locale::facet {
    public:
        typedef char char_type;
        typedef std::istreambuf_iterator<char, std::char_traits<char> > iter_type;
        static locale::id id;
        explicit num_get(std::size_t __refs);
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __in, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const;
    protected:
        virtual ~num_get<char>() noexcept;
        std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type _M_extract_float(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type, std::ios_base &, ios_base::iostate &, std::string &) const __attribute__((abi_tag("cxx11")));
        template <typename _ValueT> std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type _M_extract_int(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type, std::ios_base &, ios_base::iostate &, _ValueT &) const __attribute__((abi_tag("cxx11")));
        template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, std::size_t __len, _CharT2 __c) const;
        template <typename _CharT2> typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, std::size_t __len, _CharT2 __c) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type, std::ios_base &, ios_base::iostate &, bool &) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __beg, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __beg, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __beg, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __beg, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __beg, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __beg, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type, std::ios_base &, ios_base::iostate &, float &) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type, std::ios_base &, ios_base::iostate &, double &) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type, std::ios_base &, ios_base::iostate &, long double &) const;
        virtual std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type do_get(std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type, std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::iter_type, std::ios_base &, ios_base::iostate &, void *&) const;
    };
    template<> class num_put<char> : public locale::facet {
    public:
        typedef char char_type;
        typedef std::ostreambuf_iterator<char, std::char_traits<char> > iter_type;
        static locale::id id;
        explicit num_put(std::size_t __refs);
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type __fill, bool __v) const;
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type __fill, long __v) const;
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type __fill, unsigned long __v) const;
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type __fill, long long __v) const;
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type __fill, unsigned long long __v) const;
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type __fill, double __v) const;
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type __fill, long double __v) const;
        std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type __fill, const void *__v) const;
    protected:
        template <typename _ValueT> std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type _M_insert_float(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type __fill, char __mod, _ValueT __v) const;
        void _M_group_float(const char *__grouping, std::size_t __grouping_size, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type __sep, const std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type *__p, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type *__new, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type *__cs, int &__len) const;
        template <typename _ValueT> std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type _M_insert_int(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type __fill, _ValueT __v) const;
        void _M_group_int(const char *__grouping, std::size_t __grouping_size, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type __sep, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type *__new, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type *__cs, int &__len) const;
        void _M_pad(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type __fill, std::streamsize __w, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type *__new, const std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type *__cs, int &__len) const;
        virtual ~num_put<char>() noexcept;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type __fill, bool __v) const;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type __fill, long __v) const;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type __fill, unsigned long __v) const;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type __fill, long long __v) const;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type __s, std::ios_base &__io, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type __fill, unsigned long long __v) const;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type, std::ios_base &, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type, double) const;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type, std::ios_base &, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type, long double) const;
        virtual std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type do_put(std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::iter_type, std::ios_base &, std::num_put<char, std::ostreambuf_iterator<char, std::char_traits<char> > >::char_type, const void *) const;
    };
    template<> class ctype_byname<char>;
    template<> class numpunct<wchar_t> : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
        typedef __numpunct_cache<wchar_t> __cache_type;
    protected:
        std::__cxx11::numpunct<wchar_t>::__cache_type *_M_data;
    public:
        static locale::id id;
        explicit numpunct(std::size_t __refs);
        explicit numpunct(std::__cxx11::numpunct<wchar_t>::__cache_type *__cache, std::size_t __refs);
        explicit numpunct(std::__c_locale __cloc, std::size_t __refs);
        std::__cxx11::numpunct<wchar_t>::char_type decimal_point() const;
        std::__cxx11::numpunct<wchar_t>::char_type thousands_sep() const;
        std::string grouping() const;
        std::__cxx11::numpunct<wchar_t>::string_type truename() const;
        std::__cxx11::numpunct<wchar_t>::string_type falsename() const;
    protected:
        virtual ~numpunct<wchar_t>() noexcept;
        virtual std::__cxx11::numpunct<wchar_t>::char_type do_decimal_point() const;
        virtual std::__cxx11::numpunct<wchar_t>::char_type do_thousands_sep() const;
        virtual std::string do_grouping() const;
        virtual std::__cxx11::numpunct<wchar_t>::string_type do_truename() const;
        virtual std::__cxx11::numpunct<wchar_t>::string_type do_falsename() const;
        void _M_initialize_numpunct(std::__c_locale __cloc);
    };
    template<> class numpunct_byname<wchar_t> : public numpunct<wchar_t> {
    public:
        typedef wchar_t char_type;
        typedef basic_string<wchar_t> string_type;
        explicit numpunct_byname(const char *__s, std::size_t __refs);
        explicit numpunct_byname(const std::string &__s, std::size_t __refs);
    protected:
        virtual ~numpunct_byname<wchar_t>() noexcept;
    };
    template<> class num_get<wchar_t> : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > iter_type;
        static locale::id id;
        explicit num_get(std::size_t __refs);
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, bool &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, float &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, double &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long double &__v) const;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __in, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, void *&__v) const;
    protected:
        virtual ~num_get<wchar_t>() noexcept;
        std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type _M_extract_float(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type, std::ios_base &, ios_base::iostate &, std::string &) const __attribute__((abi_tag("cxx11")));
        template <typename _ValueT> std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type _M_extract_int(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type, std::ios_base &, ios_base::iostate &, _ValueT &) const __attribute__((abi_tag("cxx11")));
        template <typename _CharT2> typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, std::size_t __len, _CharT2 __c) const;
        template <typename _CharT2> typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, std::size_t __len, _CharT2 __c) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type, std::ios_base &, ios_base::iostate &, bool &) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __beg, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long &__v) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __beg, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned short &__v) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __beg, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned int &__v) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __beg, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long &__v) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __beg, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, long long &__v) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __beg, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __end, std::ios_base &__io, ios_base::iostate &__err, unsigned long long &__v) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type, std::ios_base &, ios_base::iostate &, float &) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type, std::ios_base &, ios_base::iostate &, double &) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type, std::ios_base &, ios_base::iostate &, long double &) const;
        virtual std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type do_get(std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type, std::num_get<wchar_t, std::istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type, std::ios_base &, ios_base::iostate &, void *&) const;
    };
    template<> class num_put<wchar_t> : public locale::facet {
    public:
        typedef wchar_t char_type;
        typedef std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > iter_type;
        static locale::id id;
        explicit num_put(std::size_t __refs);
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type __fill, bool __v) const;
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type __fill, long __v) const;
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type __fill, unsigned long __v) const;
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type __fill, long long __v) const;
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type __fill, unsigned long long __v) const;
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type __fill, double __v) const;
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type __fill, long double __v) const;
        std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type __fill, const void *__v) const;
    protected:
        template <typename _ValueT> std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type _M_insert_float(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type __fill, char __mod, _ValueT __v) const;
        void _M_group_float(const char *__grouping, std::size_t __grouping_size, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type __sep, const std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type *__p, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type *__new, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type *__cs, int &__len) const;
        template <typename _ValueT> std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type _M_insert_int(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type __fill, _ValueT __v) const;
        void _M_group_int(const char *__grouping, std::size_t __grouping_size, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type __sep, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type *__new, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type *__cs, int &__len) const;
        void _M_pad(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type __fill, std::streamsize __w, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type *__new, const std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type *__cs, int &__len) const;
        virtual ~num_put<wchar_t>() noexcept;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type __fill, bool __v) const;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type __fill, long __v) const;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type __fill, unsigned long __v) const;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type __fill, long long __v) const;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type __s, std::ios_base &__io, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type __fill, unsigned long long __v) const;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type, std::ios_base &, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type, double) const;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type, std::ios_base &, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type, long double) const;
        virtual std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type do_put(std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::iter_type, std::ios_base &, std::num_put<wchar_t, std::ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > >::char_type, const void *) const;
    };
    template<> class ctype_byname<wchar_t>;
}
namespace std {
    template <typename _Facet> inline const _Facet &__check_facet(const _Facet *__f)     {
        if (!__f)
            __throw_bad_cast();
        return *__f;
    }
    template<> inline const std::ctype<char> &__check_facet<std::ctype<char>>(const std::ctype<char> *__f)     {
        if (!__f)
            __throw_bad_cast();
        return *__f;
    }
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ios : public std::ios_base {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef ctype<_CharT> __ctype_type;
        typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> > __num_put_type;
        typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> > __num_get_type;
    protected:
        basic_ostream<_CharT, _Traits> *_M_tie;
        mutable std::basic_ios::char_type _M_fill;
        mutable bool _M_fill_init;
        basic_streambuf<_CharT, _Traits> *_M_streambuf;
        const std::basic_ios::__ctype_type *_M_ctype;
        const std::basic_ios::__num_put_type *_M_num_put;
        const std::basic_ios::__num_get_type *_M_num_get;
    public:
        explicit operator bool() const         {
            return !this->fail();
        }
        bool operator!() const         {
            return this->fail();
        }
        std::ios_base::iostate rdstate() const         {
            return this->_M_streambuf_state;
        }
        void clear(std::ios_base::iostate __state = goodbit);
        void setstate(std::ios_base::iostate __state)         {
            this->clear(this->rdstate() | __state);
        }
        void _M_setstate(std::ios_base::iostate __state)         {
            this->_M_streambuf_state |= __state;
            if (this->exceptions() & __state)
                throw;
        }
        bool good() const         {
            return this->rdstate() == 0;
        }
        bool eof() const         {
            return (this->rdstate() & eofbit) != 0;
        }
        bool fail() const         {
            return (this->rdstate() & (badbit | failbit)) != 0;
        }
        bool bad() const         {
            return (this->rdstate() & badbit) != 0;
        }
        std::ios_base::iostate exceptions() const         {
            return this->_M_exception;
        }
        void exceptions(std::ios_base::iostate __except)         {
            this->_M_exception = __except;
            this->clear(this->_M_streambuf_state);
        }
        explicit basic_ios<_CharT, _Traits>(basic_streambuf<_CharT, _Traits> *__sb) : std::ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)         {
            this->init(__sb);
        }
        virtual ~basic_ios<_CharT, _Traits>()         {
        }
        basic_ostream<_CharT, _Traits> *tie() const         {
            return this->_M_tie;
        }
        basic_ostream<_CharT, _Traits> *tie(basic_ostream<_CharT, _Traits> *__tiestr)         {
            basic_ostream<_CharT, _Traits> *__old = this->_M_tie;
            this->_M_tie = __tiestr;
            return __old;
        }
        basic_streambuf<_CharT, _Traits> *rdbuf() const         {
            return this->_M_streambuf;
        }
        basic_streambuf<_CharT, _Traits> *rdbuf(basic_streambuf<_CharT, _Traits> *__sb);
        basic_ios<_CharT, _Traits> &copyfmt(const basic_ios<_CharT, _Traits> &__rhs);
        std::basic_ios::char_type fill() const         {
            if (!this->_M_fill_init) {
                this->_M_fill = this->widen(' ');
                this->_M_fill_init = true;
            }
            return this->_M_fill;
        }
        std::basic_ios::char_type fill(std::basic_ios::char_type __ch)         {
            std::basic_ios::char_type __old = this->fill();
            this->_M_fill = __ch;
            return __old;
        }
        std::locale imbue(const std::locale &__loc);
        char narrow(std::basic_ios::char_type __c, char __dfault) const         {
            return __check_facet(this->_M_ctype).narrow(__c, __dfault);
        }
        std::basic_ios::char_type widen(char __c) const         {
            return __check_facet(this->_M_ctype).widen(__c);
        }
    protected:
        basic_ios<_CharT, _Traits>() : std::ios_base(), _M_tie(0), _M_fill(std::basic_ios::char_type()), _M_fill_init(false), _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)         {
        }
        void init(basic_streambuf<_CharT, _Traits> *__sb);
        basic_ios<_CharT, _Traits>(const basic_ios<_CharT, _Traits> &) = delete
        basic_ios<_CharT, _Traits> &operator=(const basic_ios<_CharT, _Traits> &) = delete
        void move(basic_ios<_CharT, _Traits> &__rhs)         {
            this->ios_base::_M_move(__rhs);
            this->_M_cache_locale(this->_M_ios_locale);
            this->tie(__rhs.tie(nullptr));
            this->_M_fill = __rhs._M_fill;
            this->_M_fill_init = __rhs._M_fill_init;
            this->_M_streambuf = nullptr;
        }
        void move(basic_ios<_CharT, _Traits> &&__rhs)         {
            this->move(__rhs);
        }
        void swap(basic_ios<_CharT, _Traits> &__rhs) noexcept         {
            this->ios_base::_M_swap(__rhs);
            this->_M_cache_locale(this->_M_ios_locale);
            __rhs._M_cache_locale(__rhs._M_ios_locale);
            std::swap(this->_M_tie, __rhs._M_tie);
            std::swap(this->_M_fill, __rhs._M_fill);
            std::swap(this->_M_fill_init, __rhs._M_fill_init);
        }
        void set_rdbuf(basic_streambuf<_CharT, _Traits> *__sb)         {
            this->_M_streambuf = __sb;
        }
        void _M_cache_locale(const std::locale &__loc);
    };
}
namespace std {
    template <typename _CharT, typename _Traits> void basic_ios<_CharT, _Traits>::clear(std::ios_base::iostate __state = goodbit)     {
        if (this->rdbuf())
            this->_M_streambuf_state = __state;
        else
            this->_M_streambuf_state = __state | badbit;
        if (this->exceptions() & this->rdstate())
            __throw_ios_failure(("basic_ios::clear"));
    }
    template <typename _CharT, typename _Traits> basic_streambuf<_CharT, _Traits> *basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits> *__sb)     {
        basic_streambuf<_CharT, _Traits> *__old = this->_M_streambuf;
        this->_M_streambuf = __sb;
        this->clear();
        return __old;
    }
    template <typename _CharT, typename _Traits> basic_ios<_CharT, _Traits> &basic_ios<_CharT, _Traits>::copyfmt(const basic_ios<_CharT, _Traits> &__rhs)     {
        if (this != & __rhs) {
            std::ios_base::_Words *__words = (__rhs._M_word_size <= _S_local_word_size) ? this->_M_local_word : new std::ios_base::_Words [__rhs._M_word_size];
            std::ios_base::_Callback_list *__cb = __rhs._M_callbacks;
            if (__cb)
                __cb->_M_add_reference();
            this->_M_call_callbacks(erase_event);
            if (this->_M_word != this->_M_local_word) {
                delete [] this->_M_word;
                this->_M_word = 0;
            }
            this->_M_dispose_callbacks();
            this->_M_callbacks = __cb;
            for (int __i = 0; __i < __rhs._M_word_size; ++__i)
                __words[__i] = __rhs._M_word[__i];
            this->_M_word = __words;
            this->_M_word_size = __rhs._M_word_size;
            this->flags(__rhs.flags());
            this->width(__rhs.width());
            this->precision(__rhs.precision());
            this->tie(__rhs.tie());
            this->fill(__rhs.fill());
            this->_M_ios_locale = __rhs.getloc();
            this->_M_cache_locale(this->_M_ios_locale);
            this->_M_call_callbacks(copyfmt_event);
            this->exceptions(__rhs.exceptions());
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> std::locale basic_ios<_CharT, _Traits>::imbue(const std::locale &__loc)     {
        std::locale __old(this->getloc());
        this->ios_base::imbue(__loc);
        this->_M_cache_locale(__loc);
        if (this->rdbuf() != 0)
            this->rdbuf()->pubimbue(__loc);
        return __old;
    }
    template <typename _CharT, typename _Traits> void basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits> *__sb)     {
        this->ios_base::_M_init();
        this->_M_cache_locale(this->_M_ios_locale);
        this->_M_fill = _CharT();
        this->_M_fill_init = false;
        this->_M_tie = 0;
        this->_M_exception = goodbit;
        this->_M_streambuf = __sb;
        this->_M_streambuf_state = __sb ? goodbit : badbit;
    }
    template <typename _CharT, typename _Traits> void basic_ios<_CharT, _Traits>::_M_cache_locale(const std::locale &__loc)     {
        if (__builtin_expect(has_facet<std::basic_ios::__ctype_type>(__loc), true))
            this->_M_ctype = std::__addressof(use_facet<std::basic_ios::__ctype_type>(__loc));
        else
            this->_M_ctype = 0;
        if (__builtin_expect(has_facet<std::basic_ios::__num_put_type>(__loc), true))
            this->_M_num_put = std::__addressof(use_facet<std::basic_ios::__num_put_type>(__loc));
        else
            this->_M_num_put = 0;
        if (__builtin_expect(has_facet<std::basic_ios::__num_get_type>(__loc), true))
            this->_M_num_get = std::__addressof(use_facet<std::basic_ios::__num_get_type>(__loc));
        else
            this->_M_num_get = 0;
    }
    template<> class basic_ios<char> : public std::ios_base {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef ctype<char> __ctype_type;
        typedef num_put<char, ostreambuf_iterator<char, std::char_traits<char> > > __num_put_type;
        typedef num_get<char, istreambuf_iterator<char, std::char_traits<char> > > __num_get_type;
    protected:
        basic_ostream<char, std::char_traits<char> > *_M_tie;
        mutable std::basic_ios<char, std::char_traits<char> >::char_type _M_fill;
        mutable bool _M_fill_init;
        basic_streambuf<char, std::char_traits<char> > *_M_streambuf;
        const std::basic_ios<char, std::char_traits<char> >::__ctype_type *_M_ctype;
        const std::basic_ios<char, std::char_traits<char> >::__num_put_type *_M_num_put;
        const std::basic_ios<char, std::char_traits<char> >::__num_get_type *_M_num_get;
    public:
        explicit operator bool() const;
        bool operator!() const;
        std::ios_base::iostate rdstate() const         {
            return this->_M_streambuf_state;
        }
        void clear(std::ios_base::iostate __state);
        void setstate(std::ios_base::iostate __state)         {
            this->clear(this->rdstate() | __state);
        }
        void _M_setstate(std::ios_base::iostate __state);
        bool good() const;
        bool eof() const;
        bool fail() const;
        bool bad() const;
        std::ios_base::iostate exceptions() const;
        void exceptions(std::ios_base::iostate __except);
        explicit basic_ios(basic_streambuf<char, std::char_traits<char> > *__sb);
        virtual ~basic_ios<char>() throw();
        basic_ostream<char, std::char_traits<char> > *tie() const;
        basic_ostream<char, std::char_traits<char> > *tie(basic_ostream<char, std::char_traits<char> > *__tiestr);
        basic_streambuf<char, std::char_traits<char> > *rdbuf() const;
        basic_streambuf<char, std::char_traits<char> > *rdbuf(basic_streambuf<char, std::char_traits<char> > *__sb);
        std::basic_ios<char> &copyfmt(const std::basic_ios<char> &__rhs);
        std::basic_ios<char, std::char_traits<char> >::char_type fill() const;
        std::basic_ios<char, std::char_traits<char> >::char_type fill(std::basic_ios<char, std::char_traits<char> >::char_type __ch);
        std::locale imbue(const std::locale &__loc);
        char narrow(std::basic_ios<char, std::char_traits<char> >::char_type __c, char __dfault) const;
        std::basic_ios<char, std::char_traits<char> >::char_type widen(char __c) const         {
            return __check_facet(this->_M_ctype).widen(__c);
        }
    protected:
        basic_ios();
        void init(basic_streambuf<char, std::char_traits<char> > *__sb);
        basic_ios(const std::basic_ios<char> &) = delete
        std::basic_ios<char> &operator=(const std::basic_ios<char> &) = delete
        void move(std::basic_ios<char> &__rhs);
        void move(std::basic_ios<char> &&__rhs);
        void swap(std::basic_ios<char> &__rhs) noexcept;
        void set_rdbuf(basic_streambuf<char, std::char_traits<char> > *__sb);
        void _M_cache_locale(const std::locale &__loc);
    };
    template<> class basic_ios<wchar_t> : public std::ios_base {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef ctype<wchar_t> __ctype_type;
        typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > > __num_put_type;
        typedef num_get<wchar_t, istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > > __num_get_type;
    protected:
        basic_ostream<wchar_t, std::char_traits<wchar_t> > *_M_tie;
        mutable std::basic_ios<wchar_t, std::char_traits<wchar_t> >::char_type _M_fill;
        mutable bool _M_fill_init;
        basic_streambuf<wchar_t, std::char_traits<wchar_t> > *_M_streambuf;
        const std::basic_ios<wchar_t, std::char_traits<wchar_t> >::__ctype_type *_M_ctype;
        const std::basic_ios<wchar_t, std::char_traits<wchar_t> >::__num_put_type *_M_num_put;
        const std::basic_ios<wchar_t, std::char_traits<wchar_t> >::__num_get_type *_M_num_get;
    public:
        explicit operator bool() const;
        bool operator!() const;
        std::ios_base::iostate rdstate() const;
        void clear(std::ios_base::iostate __state);
        void setstate(std::ios_base::iostate __state);
        void _M_setstate(std::ios_base::iostate __state);
        bool good() const;
        bool eof() const;
        bool fail() const;
        bool bad() const;
        std::ios_base::iostate exceptions() const;
        void exceptions(std::ios_base::iostate __except);
        explicit basic_ios(basic_streambuf<wchar_t, std::char_traits<wchar_t> > *__sb);
        virtual ~basic_ios<wchar_t>() throw();
        basic_ostream<wchar_t, std::char_traits<wchar_t> > *tie() const;
        basic_ostream<wchar_t, std::char_traits<wchar_t> > *tie(basic_ostream<wchar_t, std::char_traits<wchar_t> > *__tiestr);
        basic_streambuf<wchar_t, std::char_traits<wchar_t> > *rdbuf() const;
        basic_streambuf<wchar_t, std::char_traits<wchar_t> > *rdbuf(basic_streambuf<wchar_t, std::char_traits<wchar_t> > *__sb);
        std::basic_ios<wchar_t> &copyfmt(const std::basic_ios<wchar_t> &__rhs);
        std::basic_ios<wchar_t, std::char_traits<wchar_t> >::char_type fill() const;
        std::basic_ios<wchar_t, std::char_traits<wchar_t> >::char_type fill(std::basic_ios<wchar_t, std::char_traits<wchar_t> >::char_type __ch);
        std::locale imbue(const std::locale &__loc);
        char narrow(std::basic_ios<wchar_t, std::char_traits<wchar_t> >::char_type __c, char __dfault) const;
        std::basic_ios<wchar_t, std::char_traits<wchar_t> >::char_type widen(char __c) const;
    protected:
        basic_ios();
        void init(basic_streambuf<wchar_t, std::char_traits<wchar_t> > *__sb);
        basic_ios(const std::basic_ios<wchar_t> &) = delete
        std::basic_ios<wchar_t> &operator=(const std::basic_ios<wchar_t> &) = delete
        void move(std::basic_ios<wchar_t> &__rhs);
        void move(std::basic_ios<wchar_t> &&__rhs);
        void swap(std::basic_ios<wchar_t> &__rhs) noexcept;
        void set_rdbuf(basic_streambuf<wchar_t, std::char_traits<wchar_t> > *__sb);
        void _M_cache_locale(const std::locale &__loc);
    };
}
namespace std {
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_ostream : virtual public basic_ios<_CharT, _Traits> {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef basic_ios<_CharT, _Traits> __ios_type;
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> > __num_put_type;
        typedef ctype<_CharT> __ctype_type;
        explicit basic_ostream<_CharT, _Traits>(std::basic_ostream::__streambuf_type *__sb)         {
            this->init(__sb);
        }
        virtual ~basic_ostream<_CharT, _Traits>()         {
        }
        class sentry;
        friend  class sentry;
        std::basic_ostream::__ostream_type &operator<<(std::basic_ostream::__ostream_type &(*__pf)(std::basic_ostream::__ostream_type &))         {
            return __pf(*this);
        }
        std::basic_ostream::__ostream_type &operator<<(std::basic_ostream::__ios_type &(*__pf)(std::basic_ostream::__ios_type &))         {
            __pf(*this);
            return *this;
        }
        std::basic_ostream::__ostream_type &operator<<(std::ios_base &(*__pf)(std::ios_base &))         {
            __pf(*this);
            return *this;
        }
        std::basic_ostream::__ostream_type &operator<<(long __n)         {
            return _M_insert(__n);
        }
        std::basic_ostream::__ostream_type &operator<<(unsigned long __n)         {
            return _M_insert(__n);
        }
        std::basic_ostream::__ostream_type &operator<<(bool __n)         {
            return _M_insert(__n);
        }
        std::basic_ostream::__ostream_type &operator<<(short __n);
        std::basic_ostream::__ostream_type &operator<<(unsigned short __n)         {
            return _M_insert(static_cast<unsigned long>(__n));
        }
        std::basic_ostream::__ostream_type &operator<<(int __n);
        std::basic_ostream::__ostream_type &operator<<(unsigned int __n)         {
            return _M_insert(static_cast<unsigned long>(__n));
        }
        std::basic_ostream::__ostream_type &operator<<(long long __n)         {
            return _M_insert(__n);
        }
        std::basic_ostream::__ostream_type &operator<<(unsigned long long __n)         {
            return _M_insert(__n);
        }
        std::basic_ostream::__ostream_type &operator<<(double __f)         {
            return _M_insert(__f);
        }
        std::basic_ostream::__ostream_type &operator<<(float __f)         {
            return _M_insert(static_cast<double>(__f));
        }
        std::basic_ostream::__ostream_type &operator<<(long double __f)         {
            return _M_insert(__f);
        }
        std::basic_ostream::__ostream_type &operator<<(const void *__p)         {
            return _M_insert(__p);
        }
        std::basic_ostream::__ostream_type &operator<<(std::basic_ostream::__streambuf_type *__sb);
        std::basic_ostream::__ostream_type &put(std::basic_ostream::char_type __c);
        void _M_write(const std::basic_ostream::char_type *__s, std::streamsize __n)         {
            const std::streamsize __put = this->rdbuf()->sputn(__s, __n);
            if (__put != __n)
                this->setstate(ios_base::badbit);
        }
        std::basic_ostream::__ostream_type &write(const std::basic_ostream::char_type *__s, std::streamsize __n);
        std::basic_ostream::__ostream_type &flush();
        std::basic_ostream::pos_type tellp();
        std::basic_ostream::__ostream_type &seekp(std::basic_ostream::pos_type);
        std::basic_ostream::__ostream_type &seekp(std::basic_ostream::off_type, ios_base::seekdir);
    protected:
        basic_ostream<_CharT, _Traits>()         {
            this->init(0);
        }
        basic_ostream<_CharT, _Traits>(basic_iostream<_CharT, _Traits> &)         {
        }
        basic_ostream<_CharT, _Traits>(const basic_ostream<_CharT, _Traits> &) = delete
        basic_ostream<_CharT, _Traits>(basic_ostream<_CharT, _Traits> &&__rhs) : std::basic_ostream::__ios_type()         {
            __ios_type::move(__rhs);
        }
        basic_ostream<_CharT, _Traits> &operator=(const basic_ostream<_CharT, _Traits> &) = delete
        basic_ostream<_CharT, _Traits> &operator=(basic_ostream<_CharT, _Traits> &&__rhs)         {
            this->swap(__rhs);
            return *this;
        }
        void swap(basic_ostream<_CharT, _Traits> &__rhs)         {
            __ios_type::swap(__rhs);
        }
        template <typename _ValueT> std::basic_ostream::__ostream_type &_M_insert(_ValueT __v);
    };
    class sentry {
        bool _M_ok;
        basic_ostream<_CharT, _Traits> &_M_os;
    public:
        explicit sentry(basic_ostream<_CharT, _Traits> &__os);
        ~sentry()         {
            if (bool(this->_M_os.flags() & ios_base::unitbuf) && !uncaught_exception()) {
                if (this->_M_os.rdbuf() && this->_M_os.rdbuf()->pubsync() == -1)
                    this->_M_os.setstate(ios_base::badbit);
            }
        }
        explicit operator bool() const         {
            return this->_M_ok;
        }
    };
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, _CharT __c)     {
        return __ostream_insert(__out, & __c, 1);
    }
    template<> inline basic_ostream<char, std::char_traits<char> > &operator<<<char, std::char_traits<char>>(basic_ostream<char, std::char_traits<char> > &__out, char __c)    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, char __c)     {
        return (__out << __out.widen(__c));
    }
    template<> inline basic_ostream<char, std::char_traits<char> > &operator<<<char, std::char_traits<char>>(basic_ostream<char, std::char_traits<char> > &__out, char __c)    template <class _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, char __c)     {
        return __ostream_insert(__out, &__c, 1);
    }
    template <class _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, signed char __c)     {
        return (__out << static_cast<char>(__c));
    }
    template <class _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, unsigned char __c)     {
        return (__out << static_cast<char>(__c));
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, const _CharT *__s)     {
        if (!__s)
            __out.setstate(ios_base::badbit);
        else
            __ostream_insert(__out, __s, static_cast<std::streamsize>(_Traits::length(__s)));
        return __out;
    }
    template<> inline basic_ostream<char, std::char_traits<char> > &operator<<<char, std::char_traits<char>>(basic_ostream<char, std::char_traits<char> > &__out, const char *__s)    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, const char *__s);
    template <class _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, const char *__s)     {
        if (!__s)
            __out.setstate(ios_base::badbit);
        else
            __ostream_insert(__out, __s, static_cast<std::streamsize>(_Traits::length(__s)));
        return __out;
    }
    template <class _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, const signed char *__s)     {
        return (__out << reinterpret_cast<const char *>(__s));
    }
    template <class _Traits> inline basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__out, const unsigned char *__s)     {
        return (__out << reinterpret_cast<const char *>(__s));
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &endl(basic_ostream<_CharT, _Traits> &__os)     {
        return flush(__os.put(__os.widen('\n')));
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &ends(basic_ostream<_CharT, _Traits> &__os)     {
        return __os.put(_CharT());
    }
    template <typename _CharT, typename _Traits> inline basic_ostream<_CharT, _Traits> &flush(basic_ostream<_CharT, _Traits> &__os)     {
        return __os.flush();
    }
    template <typename _Ch, typename _Up> basic_ostream<_Ch, _Up> &__is_convertible_to_basic_ostream_test(basic_ostream<_Ch, _Up> *);
    template<> basic_ostream<char, std::char_traits<char> > &__is_convertible_to_basic_ostream_test<char, std::char_traits<char>>(basic_ostream<char, std::char_traits<char> > *);
    template <typename _Tp, typename = void> struct __is_convertible_to_basic_ostream_impl {
        using __ostream_type = void;
    };
template<> struct __is_convertible_to_basic_ostream_impl<std::basic_ostream<char> &, void> {
        using __ostream_type = __do_is_convertible_to_basic_ostream_impl<std::basic_ostream<char> &>;
    };
    template <typename _Tp> using __do_is_convertible_to_basic_ostream_impl = decltype(__is_convertible_to_basic_ostream_test(declval<typename remove_reference<_Tp>::type *>()));
    template <typename _Tp> struct __is_convertible_to_basic_ostream_impl<_Tp, __void_t<__do_is_convertible_to_basic_ostream_impl<_Tp> >> {
        using __ostream_type = __do_is_convertible_to_basic_ostream_impl<_Tp>;
    };
    template <typename _Tp> struct __is_convertible_to_basic_ostream : __is_convertible_to_basic_ostream_impl<_Tp> {
    public:
        using type = __not_<is_void<typename __is_convertible_to_basic_ostream_impl<_Tp>::__ostream_type> >;
        static constexpr bool value = type::value;
    };
template<> struct __is_convertible_to_basic_ostream<std::basic_ostream<char> &> : __is_convertible_to_basic_ostream_impl<std::basic_ostream<char> &> {
    public:
        using type = __not_<is_void<typename __is_convertible_to_basic_ostream_impl<basic_ostream<char> &>::__ostream_type> >;
        static constexpr bool value = type::value;
    };
    template <typename _Ostream, typename _Tp, typename = void> struct __is_insertable : std::false_type {
    };
    template <typename _Ostream, typename _Tp> struct __is_insertable<_Ostream, _Tp, __void_t<decltype(declval<_Ostream &>() << declval<const _Tp &>())>> : std::true_type {
    };
    template <typename _Ostream> using __rvalue_ostream_type = typename __is_convertible_to_basic_ostream<_Ostream>::__ostream_type;
    template <typename _Ostream, typename _Tp> inline typename enable_if<__and_<__not_<is_lvalue_reference<_Ostream> >, __is_convertible_to_basic_ostream<_Ostream>, __is_insertable<__rvalue_ostream_type<_Ostream>, const _Tp &> >::value, __rvalue_ostream_type<_Ostream> >::type operator<<(_Ostream &&__os, const _Tp &__x)     {
        __rvalue_ostream_type<_Ostream> __ret_os = __os;
        __ret_os << __x;
        return __ret_os;
    }
}
namespace std {
    template <typename _CharT, typename _Traits> explicit basic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits> &__os) : _M_ok(false), _M_os(__os)     {
        if (__os.tie() && __os.good())
            __os.tie()->flush();
        if (__os.good())
            this->_M_ok = true;
        else
            __os.setstate(ios_base::failbit);
    }
    template <typename _CharT, typename _Traits> template <typename _ValueT> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::_M_insert(_ValueT __v)     {
        std::basic_ostream::sentry __cerb(*this);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_ostream::__num_put_type &__np = __check_facet(this->_M_num_put);
                if (__np.put(*this, *this, this->fill(), __v).failed())
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(short __n)     {
        const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
        if (__fmt == ios_base::oct || __fmt == ios_base::hex)
            return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
        else
            return _M_insert(static_cast<long>(__n));
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(int __n)     {
        const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
        if (__fmt == ios_base::oct || __fmt == ios_base::hex)
            return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
        else
            return _M_insert(static_cast<long>(__n));
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::operator<<(std::basic_ostream::__streambuf_type *__sbin)     {
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_ostream::sentry __cerb(*this);
        if (__cerb && __sbin) {
            try {
                if (!__copy_streambufs(__sbin, this->rdbuf()))
                    __err |= ios_base::failbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::failbit);
            }
        } else if (!__sbin)
            __err |= ios_base::badbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::put(std::basic_ostream::char_type __c)     {
        std::basic_ostream::sentry __cerb(*this);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_ostream::int_type __put = this->rdbuf()->sputc(__c);
                if (traits_type::eq_int_type(__put, traits_type::eof()))
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::write(const _CharT *__s, std::streamsize __n)     {
        std::basic_ostream::sentry __cerb(*this);
        if (__cerb) {
            try {
                this->_M_write(__s, __n);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::flush()     {
        ios_base::iostate __err = ios_base::goodbit;
        try {
            if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
                __err |= ios_base::badbit;
        } catch (__cxxabiv1::__forced_unwind &) {
            this->_M_setstate(ios_base::badbit);
            throw;
        } catch (...) {
            this->_M_setstate(ios_base::badbit);
        }
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> typename basic_ostream<_CharT, _Traits>::pos_type basic_ostream<_CharT, _Traits>::tellp()     {
        std::basic_ostream::pos_type __ret = std::basic_ostream::pos_type(-1);
        try {
            if (!this->fail())
                __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
        } catch (__cxxabiv1::__forced_unwind &) {
            this->_M_setstate(ios_base::badbit);
            throw;
        } catch (...) {
            this->_M_setstate(ios_base::badbit);
        }
        return __ret;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::seekp(std::basic_ostream::pos_type __pos)     {
        ios_base::iostate __err = ios_base::goodbit;
        try {
            if (!this->fail()) {
                const std::basic_ostream::pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::out);
                if (__p == std::basic_ostream::pos_type(std::basic_ostream::off_type(-1)))
                    __err |= ios_base::failbit;
            }
        } catch (__cxxabiv1::__forced_unwind &) {
            this->_M_setstate(ios_base::badbit);
            throw;
        } catch (...) {
            this->_M_setstate(ios_base::badbit);
        }
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::seekp(std::basic_ostream::off_type __off, ios_base::seekdir __dir)     {
        ios_base::iostate __err = ios_base::goodbit;
        try {
            if (!this->fail()) {
                const std::basic_ostream::pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ios_base::out);
                if (__p == std::basic_ostream::pos_type(std::basic_ostream::off_type(-1)))
                    __err |= ios_base::failbit;
            }
        } catch (__cxxabiv1::__forced_unwind &) {
            this->_M_setstate(ios_base::badbit);
            throw;
        } catch (...) {
            this->_M_setstate(ios_base::badbit);
        }
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__out, const char *__s)     {
        if (!__s)
            __out.setstate(ios_base::badbit);
        else {
            const std::size_t __clen = char_traits<char>::length(__s);
            try {
                struct __ptr_guard {
                    _CharT *__p;
                    __ptr_guard(_CharT *__ip) : __p(__ip)                     {
                    }
                    ~__ptr_guard()                     {
                        delete [] this->__p;
                    }
                    _CharT *__get()                     {
                        return this->__p;
                    }
                } __pg(new _CharT [__clen]);
                _CharT *__ws = __pg.__get();
                for (std::size_t __i = 0; __i < __clen; ++__i)
                    __ws[__i] = __out.widen(__s[__i]);
                __ostream_insert(__out, __ws, __clen);
            } catch (__cxxabiv1::__forced_unwind &) {
                __out._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __out._M_setstate(ios_base::badbit);
            }
        }
        return __out;
    }
    template<> basic_ostream<char, std::char_traits<char> > &operator<<<char, std::char_traits<char>>(basic_ostream<char, std::char_traits<char> > &__out, const char *__s)    template<> class basic_ostream<char> : virtual public basic_ios<char, std::char_traits<char> > {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_streambuf<char, std::char_traits<char> > __streambuf_type;
        typedef basic_ios<char, std::char_traits<char> > __ios_type;
        typedef basic_ostream<char, std::char_traits<char> > __ostream_type;
        typedef num_put<char, ostreambuf_iterator<char, std::char_traits<char> > > __num_put_type;
        typedef ctype<char> __ctype_type;
        explicit basic_ostream(std::basic_ostream<char, std::char_traits<char> >::__streambuf_type *__sb);
        virtual ~basic_ostream<char>() throw();
        class sentry {
            bool _M_ok;
            basic_ostream<char, std::char_traits<char> > &_M_os;
        public:
            explicit sentry(basic_ostream<char, std::char_traits<char> > &__os);
            ~sentry();
            explicit operator bool() const;
        };
        friend  class sentry;
        std::basic_ostream<char, std::char_traits<char> >::__ostream_type &operator<<(std::basic_ostream<char, std::char_traits<char> >::__ostream_type &(*__pf)(std::basic_ostream<char, std::char_traits<char> >::__ostream_type &))         {
            return __pf(*this);
        }
        std::basic_ostream<char, std::char_traits<char> >::__ostream_type &operator<<(std::basic_ostream<char, std::char_traits<char> >::__ios_type &(*__pf)(std::basic_ostream<char, std::char_traits<char> >::__ios_type &));
        std::basic_ostream<char, std::char_traits<char> >::__ostream_type &operator<<(std::ios_base &(*__pf)(std::ios_base &));
        std::basic_ostream<char, std::char_traits<char> >::__ostream_type &operator<<(long __n);
        std::basic_ostream<char, std::char_traits<char> >::__ostream_type &operator<<(unsigned long __n);
        std::basic_ostream<char, std::char_traits<char> >::__ostream_type &operator<<(bool __n);
        std::basic_ostream<char, std::char_traits<char> >::__ostream_type &operator<<(short __n);
        std::basic_ostream<char, std::char_traits<char> >::__ostream_type &operator<<(unsigned short __n);
        std::basic_ostream<char, std::char_traits<char> >::__ostream_type &operator<<(int __n);
        std::basic_ostream<char, std::char_traits<char> >::__ostream_type &operator<<(unsigned int __n);
        std::basic_ostream<char, std::char_traits<char> >::__ostream_type &operator<<(long long __n);
        std::basic_ostream<char, std::char_traits<char> >::__ostream_type &operator<<(unsigned long long __n);
        std::basic_ostream<char, std::char_traits<char> >::__ostream_type &operator<<(double __f);
        std::basic_ostream<char, std::char_traits<char> >::__ostream_type &operator<<(float __f);
        std::basic_ostream<char, std::char_traits<char> >::__ostream_type &operator<<(long double __f);
        std::basic_ostream<char, std::char_traits<char> >::__ostream_type &operator<<(const void *__p);
        std::basic_ostream<char, std::char_traits<char> >::__ostream_type &operator<<(std::basic_ostream<char, std::char_traits<char> >::__streambuf_type *__sb);
        std::basic_ostream<char, std::char_traits<char> >::__ostream_type &put(std::basic_ostream<char, std::char_traits<char> >::char_type __c);
        void _M_write(const std::basic_ostream<char, std::char_traits<char> >::char_type *__s, std::streamsize __n);
        std::basic_ostream<char, std::char_traits<char> >::__ostream_type &write(const std::basic_ostream<char, std::char_traits<char> >::char_type *__s, std::streamsize __n);
        std::basic_ostream<char, std::char_traits<char> >::__ostream_type &flush();
        std::basic_ostream<char, std::char_traits<char> >::pos_type tellp();
        std::basic_ostream<char, std::char_traits<char> >::__ostream_type &seekp(std::basic_ostream<char, std::char_traits<char> >::pos_type);
        std::basic_ostream<char, std::char_traits<char> >::__ostream_type &seekp(std::basic_ostream<char, std::char_traits<char> >::off_type, ios_base::seekdir);
    protected:
        basic_ostream();
        basic_ostream(basic_iostream<char, std::char_traits<char> > &);
        basic_ostream(const std::basic_ostream<char> &) = delete
        basic_ostream(std::basic_ostream<char> &&__rhs);
        std::basic_ostream<char> &operator=(const std::basic_ostream<char> &) = delete
        std::basic_ostream<char> &operator=(std::basic_ostream<char> &&__rhs);
        void swap(std::basic_ostream<char> &__rhs);
        template <typename _ValueT> std::basic_ostream<char, std::char_traits<char> >::__ostream_type &_M_insert(_ValueT __v);
    };
    template<> class basic_ostream<wchar_t> : virtual public basic_ios<wchar_t, std::char_traits<wchar_t> > {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_streambuf<wchar_t, std::char_traits<wchar_t> > __streambuf_type;
        typedef basic_ios<wchar_t, std::char_traits<wchar_t> > __ios_type;
        typedef basic_ostream<wchar_t, std::char_traits<wchar_t> > __ostream_type;
        typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, std::char_traits<wchar_t> > > __num_put_type;
        typedef ctype<wchar_t> __ctype_type;
        explicit basic_ostream(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__streambuf_type *__sb);
        virtual ~basic_ostream<wchar_t>() throw();
        class sentry {
            bool _M_ok;
            basic_ostream<wchar_t, std::char_traits<wchar_t> > &_M_os;
        public:
            explicit sentry(basic_ostream<wchar_t, std::char_traits<wchar_t> > &__os);
            ~sentry();
            explicit operator bool() const;
        };
        friend  class sentry;
        std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &operator<<(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &(*__pf)(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &));
        std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &operator<<(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ios_type &(*__pf)(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ios_type &));
        std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &operator<<(std::ios_base &(*__pf)(std::ios_base &));
        std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &operator<<(long __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &operator<<(unsigned long __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &operator<<(bool __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &operator<<(short __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &operator<<(unsigned short __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &operator<<(int __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &operator<<(unsigned int __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &operator<<(long long __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &operator<<(unsigned long long __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &operator<<(double __f);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &operator<<(float __f);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &operator<<(long double __f);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &operator<<(const void *__p);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &operator<<(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__streambuf_type *__sb);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &put(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::char_type __c);
        void _M_write(const std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::char_type *__s, std::streamsize __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &write(const std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::char_type *__s, std::streamsize __n);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &flush();
        std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::pos_type tellp();
        std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &seekp(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::pos_type);
        std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &seekp(std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::off_type, ios_base::seekdir);
    protected:
        basic_ostream();
        basic_ostream(basic_iostream<wchar_t, std::char_traits<wchar_t> > &);
        basic_ostream(const std::basic_ostream<wchar_t> &) = delete
        basic_ostream(std::basic_ostream<wchar_t> &&__rhs);
        std::basic_ostream<wchar_t> &operator=(const std::basic_ostream<wchar_t> &) = delete
        std::basic_ostream<wchar_t> &operator=(std::basic_ostream<wchar_t> &&__rhs);
        void swap(std::basic_ostream<wchar_t> &__rhs);
        template <typename _ValueT> std::basic_ostream<wchar_t, std::char_traits<wchar_t> >::__ostream_type &_M_insert(_ValueT __v);
    };
}
namespace std {
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_istream : virtual public basic_ios<_CharT, _Traits> {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef basic_ios<_CharT, _Traits> __ios_type;
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> > __num_get_type;
        typedef ctype<_CharT> __ctype_type;
    protected:
        std::streamsize _M_gcount;
    public:
        explicit basic_istream<_CharT, _Traits>(std::basic_istream::__streambuf_type *__sb) : _M_gcount(std::streamsize(0))         {
            this->init(__sb);
        }
        virtual ~basic_istream<_CharT, _Traits>()         {
            this->_M_gcount = std::streamsize(0);
        }
        class sentry;
        friend  class sentry;
        std::basic_istream::__istream_type &operator>>(std::basic_istream::__istream_type &(*__pf)(std::basic_istream::__istream_type &))         {
            return __pf(*this);
        }
        std::basic_istream::__istream_type &operator>>(std::basic_istream::__ios_type &(*__pf)(std::basic_istream::__ios_type &))         {
            __pf(*this);
            return *this;
        }
        std::basic_istream::__istream_type &operator>>(std::ios_base &(*__pf)(std::ios_base &))         {
            __pf(*this);
            return *this;
        }
        std::basic_istream::__istream_type &operator>>(bool &__n)         {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(short &__n);
        std::basic_istream::__istream_type &operator>>(unsigned short &__n)         {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(int &__n);
        std::basic_istream::__istream_type &operator>>(unsigned int &__n)         {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(long &__n)         {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(unsigned long &__n)         {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(long long &__n)         {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(unsigned long long &__n)         {
            return _M_extract(__n);
        }
        std::basic_istream::__istream_type &operator>>(float &__f)         {
            return _M_extract(__f);
        }
        std::basic_istream::__istream_type &operator>>(double &__f)         {
            return _M_extract(__f);
        }
        std::basic_istream::__istream_type &operator>>(long double &__f)         {
            return _M_extract(__f);
        }
        std::basic_istream::__istream_type &operator>>(void *&__p)         {
            return _M_extract(__p);
        }
        std::basic_istream::__istream_type &operator>>(std::basic_istream::__streambuf_type *__sb);
        std::streamsize gcount() const         {
            return this->_M_gcount;
        }
        std::basic_istream::int_type get();
        std::basic_istream::__istream_type &get(std::basic_istream::char_type &__c);
        std::basic_istream::__istream_type &get(std::basic_istream::char_type *__s, std::streamsize __n, std::basic_istream::char_type __delim);
        std::basic_istream::__istream_type &get(std::basic_istream::char_type *__s, std::streamsize __n)         {
            return this->get(__s, __n, this->widen('\n'));
        }
        std::basic_istream::__istream_type &get(std::basic_istream::__streambuf_type &__sb, std::basic_istream::char_type __delim);
        std::basic_istream::__istream_type &get(std::basic_istream::__streambuf_type &__sb)         {
            return this->get(__sb, this->widen('\n'));
        }
        std::basic_istream::__istream_type &getline(std::basic_istream::char_type *__s, std::streamsize __n, std::basic_istream::char_type __delim);
        std::basic_istream::__istream_type &getline(std::basic_istream::char_type *__s, std::streamsize __n)         {
            return this->getline(__s, __n, this->widen('\n'));
        }
        std::basic_istream::__istream_type &ignore(std::streamsize __n, std::basic_istream::int_type __delim);
        std::basic_istream::__istream_type &ignore(std::streamsize __n);
        std::basic_istream::__istream_type &ignore();
        std::basic_istream::int_type peek();
        std::basic_istream::__istream_type &read(std::basic_istream::char_type *__s, std::streamsize __n);
        std::streamsize readsome(std::basic_istream::char_type *__s, std::streamsize __n);
        std::basic_istream::__istream_type &putback(std::basic_istream::char_type __c);
        std::basic_istream::__istream_type &unget();
        int sync();
        std::basic_istream::pos_type tellg();
        std::basic_istream::__istream_type &seekg(std::basic_istream::pos_type);
        std::basic_istream::__istream_type &seekg(std::basic_istream::off_type, ios_base::seekdir);
    protected:
        basic_istream<_CharT, _Traits>() : _M_gcount(std::streamsize(0))         {
            this->init(0);
        }
        basic_istream<_CharT, _Traits>(const basic_istream<_CharT, _Traits> &) = delete
        basic_istream<_CharT, _Traits>(basic_istream<_CharT, _Traits> &&__rhs) : std::basic_istream::__ios_type(), _M_gcount(__rhs._M_gcount)         {
            __ios_type::move(__rhs);
            __rhs._M_gcount = 0;
        }
        basic_istream<_CharT, _Traits> &operator=(const basic_istream<_CharT, _Traits> &) = delete
        basic_istream<_CharT, _Traits> &operator=(basic_istream<_CharT, _Traits> &&__rhs)         {
            this->swap(__rhs);
            return *this;
        }
        void swap(basic_istream<_CharT, _Traits> &__rhs)         {
            __ios_type::swap(__rhs);
            std::swap(this->_M_gcount, __rhs._M_gcount);
        }
        template <typename _ValueT> std::basic_istream::__istream_type &_M_extract(_ValueT &__v);
    };
    template <> basic_istream<char> &basic_istream<char>::getline(std::basic_istream<char, std::char_traits<char> >::char_type *__s, std::streamsize __n, std::basic_istream<char, std::char_traits<char> >::char_type __delim);
    template <> basic_istream<char> &basic_istream<char>::ignore(std::streamsize __n);
    template <> basic_istream<char> &basic_istream<char>::ignore(std::streamsize __n, std::basic_istream<char, std::char_traits<char> >::int_type __delim);
    template <> basic_istream<wchar_t> &basic_istream<wchar_t>::getline(std::basic_istream<wchar_t, std::char_traits<wchar_t> >::char_type *__s, std::streamsize __n, std::basic_istream<wchar_t, std::char_traits<wchar_t> >::char_type __delim);
    template <> basic_istream<wchar_t> &basic_istream<wchar_t>::ignore(std::streamsize __n);
    template <> basic_istream<wchar_t> &basic_istream<wchar_t>::ignore(std::streamsize __n, std::basic_istream<wchar_t, std::char_traits<wchar_t> >::int_type __delim);
    class sentry {
        bool _M_ok;
    public:
        typedef _Traits traits_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef typename __istream_type::__ctype_type __ctype_type;
        typedef typename _Traits::int_type __int_type;
        explicit sentry(basic_istream<_CharT, _Traits> &__is, bool __noskipws = false);
        explicit operator bool() const         {
            return this->_M_ok;
        }
    };
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, _CharT &__c);
    template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, unsigned char &__c)     {
        return (__in >> reinterpret_cast<char &>(__c));
    }
    template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, signed char &__c)     {
        return (__in >> reinterpret_cast<char &>(__c));
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, _CharT *__s);
    template<> basic_istream<char> &operator>><char, std::char_traits<char>>(basic_istream<char> &__in, char *__s);
    template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, unsigned char *__s)     {
        return (__in >> reinterpret_cast<char *>(__s));
    }
    template <class _Traits> inline basic_istream<char, _Traits> &operator>>(basic_istream<char, _Traits> &__in, signed char *__s)     {
        return (__in >> reinterpret_cast<char *>(__s));
    }
    template <typename _CharT, typename _Traits = char_traits<_CharT>> class basic_iostream : public basic_istream<_CharT, _Traits>, public basic_ostream<_CharT, _Traits> {
    public:
        typedef _CharT char_type;
        typedef typename _Traits::int_type int_type;
        typedef typename _Traits::pos_type pos_type;
        typedef typename _Traits::off_type off_type;
        typedef _Traits traits_type;
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_ostream<_CharT, _Traits> __ostream_type;
        explicit basic_iostream<_CharT, _Traits>(basic_streambuf<_CharT, _Traits> *__sb) : std::basic_iostream::__istream_type(__sb), std::basic_iostream::__ostream_type(__sb)         {
        }
        virtual ~basic_iostream<_CharT, _Traits>()         {
        }
    protected:
        basic_iostream<_CharT, _Traits>() : std::basic_iostream::__istream_type(), std::basic_iostream::__ostream_type()         {
        }
        basic_iostream<_CharT, _Traits>(const basic_iostream<_CharT, _Traits> &) = delete
        basic_iostream<_CharT, _Traits>(basic_iostream<_CharT, _Traits> &&__rhs) : std::basic_iostream::__istream_type(std::move(__rhs)), std::basic_iostream::__ostream_type(*this)         {
        }
        basic_iostream<_CharT, _Traits> &operator=(const basic_iostream<_CharT, _Traits> &) = delete
        basic_iostream<_CharT, _Traits> &operator=(basic_iostream<_CharT, _Traits> &&__rhs)         {
            this->swap(__rhs);
            return *this;
        }
        void swap(basic_iostream<_CharT, _Traits> &__rhs)         {
            __istream_type::swap(__rhs);
        }
    };
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &ws(basic_istream<_CharT, _Traits> &__is);
    template <typename _Ch, typename _Up> basic_istream<_Ch, _Up> &__is_convertible_to_basic_istream_test(basic_istream<_Ch, _Up> *);
    template<> basic_istream<char, std::char_traits<char> > &__is_convertible_to_basic_istream_test<char, std::char_traits<char>>(basic_istream<char, std::char_traits<char> > *);
    template<> basic_istream<wchar_t, std::char_traits<wchar_t> > &__is_convertible_to_basic_istream_test<wchar_t, std::char_traits<wchar_t>>(basic_istream<wchar_t, std::char_traits<wchar_t> > *);
    template <typename _Tp, typename = void> struct __is_convertible_to_basic_istream_impl {
        using __istream_type = void;
    };
template<> struct __is_convertible_to_basic_istream_impl<std::basic_istream<char> &, void> {
        using __istream_type = __do_is_convertible_to_basic_istream_impl<std::basic_istream<char> &>;
    };
template<> struct __is_convertible_to_basic_istream_impl<std::basic_istream<wchar_t> &, void> {
        using __istream_type = __do_is_convertible_to_basic_istream_impl<std::basic_istream<wchar_t> &>;
    };
    template <typename _Tp> using __do_is_convertible_to_basic_istream_impl = decltype(__is_convertible_to_basic_istream_test(declval<typename remove_reference<_Tp>::type *>()));
    template <typename _Tp> struct __is_convertible_to_basic_istream_impl<_Tp, __void_t<__do_is_convertible_to_basic_istream_impl<_Tp> >> {
        using __istream_type = __do_is_convertible_to_basic_istream_impl<_Tp>;
    };
    template <typename _Tp> struct __is_convertible_to_basic_istream : __is_convertible_to_basic_istream_impl<_Tp> {
    public:
        using type = __not_<is_void<typename __is_convertible_to_basic_istream_impl<_Tp>::__istream_type> >;
        static constexpr bool value = type::value;
    };
template<> struct __is_convertible_to_basic_istream<std::basic_istream<char> &> : __is_convertible_to_basic_istream_impl<std::basic_istream<char> &> {
    public:
        using type = __not_<is_void<typename __is_convertible_to_basic_istream_impl<basic_istream<char> &>::__istream_type> >;
        static constexpr bool value = type::value;
    };
template<> struct __is_convertible_to_basic_istream<std::basic_istream<wchar_t> &> : __is_convertible_to_basic_istream_impl<std::basic_istream<wchar_t> &> {
    public:
        using type = __not_<is_void<typename __is_convertible_to_basic_istream_impl<basic_istream<wchar_t> &>::__istream_type> >;
        static constexpr bool value = type::value;
    };
    template <typename _Istream, typename _Tp, typename = void> struct __is_extractable : std::false_type {
    };
    template <typename _Istream, typename _Tp> struct __is_extractable<_Istream, _Tp, __void_t<decltype(declval<_Istream &>() >> declval<_Tp>())>> : std::true_type {
    };
    template <typename _Istream> using __rvalue_istream_type = typename __is_convertible_to_basic_istream<_Istream>::__istream_type;
    template <typename _Istream, typename _Tp> inline typename enable_if<__and_<__not_<is_lvalue_reference<_Istream> >, __is_convertible_to_basic_istream<_Istream>, __is_extractable<__rvalue_istream_type<_Istream>, _Tp &&> >::value, __rvalue_istream_type<_Istream> >::type operator>>(_Istream &&__is, _Tp &&__x)     {
        __rvalue_istream_type<_Istream> __ret_is = __is;
        __ret_is >> std::forward<_Tp>(__x);
        return __ret_is;
    }
}
namespace std {
    template <typename _CharT, typename _Traits> explicit basic_istream<_CharT, _Traits>::sentry::sentry(basic_istream<_CharT, _Traits> &__in, bool __noskip = false) : _M_ok(false)     {
        ios_base::iostate __err = ios_base::goodbit;
        if (__in.good())
            try {
                if (__in.tie())
                    __in.tie()->flush();
                if (!__noskip && bool(__in.flags() & ios_base::skipws)) {
                    const std::basic_istream::sentry::__int_type __eof = traits_type::eof();
                    std::basic_istream::sentry::__streambuf_type *__sb = __in.rdbuf();
                    std::basic_istream::sentry::__int_type __c = __sb->sgetc();
                    const std::basic_istream::sentry::__ctype_type &__ct = __check_facet(__in._M_ctype);
                    while (!traits_type::eq_int_type(__c, __eof) && __ct.is(ctype_base::space, traits_type::to_char_type(__c)))
                        __c = __sb->snextc();
                    if (traits_type::eq_int_type(__c, __eof))
                        __err |= ios_base::eofbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(ios_base::badbit);
            }
        if (__in.good() && __err == ios_base::goodbit)
            this->_M_ok = true;
        else {
            __err |= ios_base::failbit;
            __in.setstate(__err);
        }
    }
    template <typename _CharT, typename _Traits> template <typename _ValueT> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::_M_extract(_ValueT &__v)     {
        std::basic_istream::sentry __cerb(*this, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::__num_get_type &__ng = __check_facet(this->_M_num_get);
                __ng.get(*this, 0, *this, __err, __v);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(short &__n)     {
        std::basic_istream::sentry __cerb(*this, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                long __l;
                const std::basic_istream::__num_get_type &__ng = __check_facet(this->_M_num_get);
                __ng.get(*this, 0, *this, __err, __l);
                if (__l < __gnu_cxx::__numeric_traits<short>::__min) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<short>::__min;
                } else if (__l > __gnu_cxx::__numeric_traits<short>::__max) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<short>::__max;
                } else
                    __n = short(__l);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(int &__n)     {
        std::basic_istream::sentry __cerb(*this, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                long __l;
                const std::basic_istream::__num_get_type &__ng = __check_facet(this->_M_num_get);
                __ng.get(*this, 0, *this, __err, __l);
                if (__l < __gnu_cxx::__numeric_traits<int>::__min) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<int>::__min;
                } else if (__l > __gnu_cxx::__numeric_traits<int>::__max) {
                    __err |= ios_base::failbit;
                    __n = __gnu_cxx::__numeric_traits<int>::__max;
                } else
                    __n = int(__l);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::operator>>(std::basic_istream::__streambuf_type *__sbout)     {
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, false);
        if (__cerb && __sbout) {
            try {
                bool __ineof;
                if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
                    __err |= ios_base::failbit;
                if (__ineof)
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::failbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::failbit);
            }
        } else if (!__sbout)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> typename basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::get()     {
        const std::basic_istream::int_type __eof = traits_type::eof();
        std::basic_istream::int_type __c = __eof;
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                __c = this->rdbuf()->sbumpc();
                if (!traits_type::eq_int_type(__c, __eof))
                    this->_M_gcount = 1;
                else
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return __c;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(std::basic_istream::char_type &__c)     {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const std::basic_istream::int_type __cb = this->rdbuf()->sbumpc();
                if (!traits_type::eq_int_type(__cb, traits_type::eof())) {
                    this->_M_gcount = 1;
                    __c = traits_type::to_char_type(__cb);
                } else
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(std::basic_istream::char_type *__s, std::streamsize __n, std::basic_istream::char_type __delim)     {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const std::basic_istream::int_type __idelim = traits_type::to_int_type(__delim);
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                std::basic_istream::int_type __c = __sb->sgetc();
                while (this->_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim))
                    {
                        *__s++ = traits_type::to_char_type(__c);
                        ++this->_M_gcount;
                        __c = __sb->snextc();
                    }
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (__n > 0)
            *__s = std::basic_istream::char_type();
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(std::basic_istream::__streambuf_type &__sb, std::basic_istream::char_type __delim)     {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const std::basic_istream::int_type __idelim = traits_type::to_int_type(__delim);
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__this_sb = this->rdbuf();
                std::basic_istream::int_type __c = __this_sb->sgetc();
                std::basic_istream::char_type __c2 = traits_type::to_char_type(__c);
                while (!traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim) && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
                    {
                        ++this->_M_gcount;
                        __c = __this_sb->snextc();
                        __c2 = traits_type::to_char_type(__c);
                    }
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::getline(std::basic_istream::char_type *__s, std::streamsize __n, std::basic_istream::char_type __delim)     {
        this->_M_gcount = 0;
        ios_base::iostate __err = ios_base::goodbit;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                const std::basic_istream::int_type __idelim = traits_type::to_int_type(__delim);
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                std::basic_istream::int_type __c = __sb->sgetc();
                while (this->_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim))
                    {
                        *__s++ = traits_type::to_char_type(__c);
                        __c = __sb->snextc();
                        ++this->_M_gcount;
                    }
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
                else {
                    if (traits_type::eq_int_type(__c, __idelim)) {
                        __sb->sbumpc();
                        ++this->_M_gcount;
                    } else
                        __err |= ios_base::failbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        if (__n > 0)
            *__s = std::basic_istream::char_type();
        if (!this->_M_gcount)
            __err |= ios_base::failbit;
        if (__err)
            this->setstate(__err);
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::ignore()     {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
                    __err |= ios_base::eofbit;
                else
                    this->_M_gcount = 1;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::ignore(std::streamsize __n)     {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb && __n > 0) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                std::basic_istream::int_type __c = __sb->sgetc();
                bool __large_ignore = false;
                while (true)
                    {
                        while (this->_M_gcount < __n && !traits_type::eq_int_type(__c, __eof))
                            {
                                ++this->_M_gcount;
                                __c = __sb->snextc();
                            }
                        if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max && !traits_type::eq_int_type(__c, __eof)) {
                            this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__min;
                            __large_ignore = true;
                        } else
                            break;
                    }
                if (__large_ignore)
                    this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::ignore(std::streamsize __n, std::basic_istream::int_type __delim)     {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb && __n > 0) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                std::basic_istream::int_type __c = __sb->sgetc();
                bool __large_ignore = false;
                while (true)
                    {
                        while (this->_M_gcount < __n && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __delim))
                            {
                                ++this->_M_gcount;
                                __c = __sb->snextc();
                            }
                        if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max && !traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __delim)) {
                            this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__min;
                            __large_ignore = true;
                        } else
                            break;
                    }
                if (__large_ignore)
                    this->_M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;
                if (traits_type::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
                else if (traits_type::eq_int_type(__c, __delim)) {
                    if (this->_M_gcount < __gnu_cxx::__numeric_traits<streamsize>::__max)
                        ++this->_M_gcount;
                    __sb->sbumpc();
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> typename basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::peek()     {
        std::basic_istream::int_type __c = traits_type::eof();
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                __c = this->rdbuf()->sgetc();
                if (traits_type::eq_int_type(__c, traits_type::eof()))
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return __c;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::read(std::basic_istream::char_type *__s, std::streamsize __n)     {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                this->_M_gcount = this->rdbuf()->sgetn(__s, __n);
                if (this->_M_gcount != __n)
                    __err |= (ios_base::eofbit | ios_base::failbit);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> std::streamsize basic_istream<_CharT, _Traits>::readsome(std::basic_istream::char_type *__s, std::streamsize __n)     {
        this->_M_gcount = 0;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::streamsize __num = this->rdbuf()->in_avail();
                if (__num > 0)
                    this->_M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
                else if (__num == -1)
                    __err |= ios_base::eofbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return this->_M_gcount;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::putback(std::basic_istream::char_type __c)     {
        this->_M_gcount = 0;
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                if (!__sb || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::unget()     {
        this->_M_gcount = 0;
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const std::basic_istream::int_type __eof = traits_type::eof();
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                if (!__sb || traits_type::eq_int_type(__sb->sungetc(), __eof))
                    __err |= ios_base::badbit;
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> int basic_istream<_CharT, _Traits>::sync()     {
        int __ret = -1;
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                std::basic_istream::__streambuf_type *__sb = this->rdbuf();
                if (__sb) {
                    if (__sb->pubsync() == -1)
                        __err |= ios_base::badbit;
                    else
                        __ret = 0;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return __ret;
    }
    template <typename _CharT, typename _Traits> typename basic_istream<_CharT, _Traits>::pos_type basic_istream<_CharT, _Traits>::tellg()     {
        std::basic_istream::pos_type __ret = std::basic_istream::pos_type(-1);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            try {
                if (!this->fail())
                    __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
        }
        return __ret;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::seekg(std::basic_istream::pos_type __pos)     {
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                if (!this->fail()) {
                    const std::basic_istream::pos_type __p = this->rdbuf()->pubseekpos(__pos, ios_base::in);
                    if (__p == std::basic_istream::pos_type(std::basic_istream::off_type(-1)))
                        __err |= ios_base::failbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::seekg(std::basic_istream::off_type __off, ios_base::seekdir __dir)     {
        this->clear(this->rdstate() & ~ ios_base::eofbit);
        std::basic_istream::sentry __cerb(*this, true);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                if (!this->fail()) {
                    const std::basic_istream::pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ios_base::in);
                    if (__p == std::basic_istream::pos_type(std::basic_istream::off_type(-1)))
                        __err |= ios_base::failbit;
                }
            } catch (__cxxabiv1::__forced_unwind &) {
                this->_M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                this->_M_setstate(ios_base::badbit);
            }
            if (__err)
                this->setstate(__err);
        }
        return *this;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, _CharT &__c)     {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef typename __istream_type::int_type __int_type;
        typename __istream_type::sentry __cerb(__in, false);
        if (__cerb) {
            ios_base::iostate __err = ios_base::goodbit;
            try {
                const __int_type __cb = __in.rdbuf()->sbumpc();
                if (!_Traits::eq_int_type(__cb, _Traits::eof()))
                    __c = _Traits::to_char_type(__cb);
                else
                    __err |= (ios_base::eofbit | ios_base::failbit);
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(ios_base::badbit);
            }
            if (__err)
                __in.setstate(__err);
        }
        return __in;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__in, _CharT *__s)     {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef typename _Traits::int_type int_type;
        typedef _CharT char_type;
        typedef ctype<_CharT> __ctype_type;
        std::streamsize __extracted = 0;
        ios_base::iostate __err = ios_base::goodbit;
        typename __istream_type::sentry __cerb(__in, false);
        if (__cerb) {
            try {
                std::streamsize __num = __in.width();
                if (__num <= 0)
                    __num = __gnu_cxx::__numeric_traits<streamsize>::__max;
                const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
                const int_type __eof = _Traits::eof();
                __streambuf_type *__sb = __in.rdbuf();
                int_type __c = __sb->sgetc();
                while (__extracted < __num - 1 && !_Traits::eq_int_type(__c, __eof) && !__ct.is(ctype_base::space, _Traits::to_char_type(__c)))
                    {
                        *__s++ = _Traits::to_char_type(__c);
                        ++__extracted;
                        __c = __sb->snextc();
                    }
                if (_Traits::eq_int_type(__c, __eof))
                    __err |= ios_base::eofbit;
                *__s = char_type();
                __in.width(0);
            } catch (__cxxabiv1::__forced_unwind &) {
                __in._M_setstate(ios_base::badbit);
                throw;
            } catch (...) {
                __in._M_setstate(ios_base::badbit);
            }
        }
        if (!__extracted)
            __err |= ios_base::failbit;
        if (__err)
            __in.setstate(__err);
        return __in;
    }
    template <typename _CharT, typename _Traits> basic_istream<_CharT, _Traits> &ws(basic_istream<_CharT, _Traits> &__in)     {
        typedef basic_istream<_CharT, _Traits> __istream_type;
        typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
        typedef typename __istream_type::int_type __int_type;
        typedef ctype<_CharT> __ctype_type;
        const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
        const __int_type __eof = _Traits::eof();
        __streambuf_type *__sb = __in.rdbuf();
        __int_type __c = __sb->sgetc();
        while (!_Traits::eq_int_type(__c, __eof) && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
            __c = __sb->snextc();
        if (_Traits::eq_int_type(__c, __eof))
            __in.setstate(ios_base::eofbit);
        return __in;
    }
    template<> class basic_istream<char> : virtual public basic_ios<char, std::char_traits<char> > {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_streambuf<char, std::char_traits<char> > __streambuf_type;
        typedef basic_ios<char, std::char_traits<char> > __ios_type;
        typedef basic_istream<char, std::char_traits<char> > __istream_type;
        typedef num_get<char, istreambuf_iterator<char, std::char_traits<char> > > __num_get_type;
        typedef ctype<char> __ctype_type;
    protected:
        std::streamsize _M_gcount;
    public:
        explicit basic_istream(std::basic_istream<char, std::char_traits<char> >::__streambuf_type *__sb);
        virtual ~basic_istream<char>() throw();
        class sentry {
            bool _M_ok;
        public:
            typedef std::char_traits<char> traits_type;
            typedef basic_streambuf<char, std::char_traits<char> > __streambuf_type;
            typedef basic_istream<char, std::char_traits<char> > __istream_type;
            typedef typename __istream_type::__ctype_type __ctype_type;
            typedef typename char_traits<char>::int_type __int_type;
            explicit sentry(basic_istream<char, std::char_traits<char> > &__is, bool __noskipws);
            explicit operator bool() const;
        };
        friend  class sentry;
        std::basic_istream<char, std::char_traits<char> >::__istream_type &operator>>(std::basic_istream<char, std::char_traits<char> >::__istream_type &(*__pf)(std::basic_istream<char, std::char_traits<char> >::__istream_type &));
        std::basic_istream<char, std::char_traits<char> >::__istream_type &operator>>(std::basic_istream<char, std::char_traits<char> >::__ios_type &(*__pf)(std::basic_istream<char, std::char_traits<char> >::__ios_type &));
        std::basic_istream<char, std::char_traits<char> >::__istream_type &operator>>(std::ios_base &(*__pf)(std::ios_base &));
        std::basic_istream<char, std::char_traits<char> >::__istream_type &operator>>(bool &__n);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &operator>>(short &__n);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &operator>>(unsigned short &__n);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &operator>>(int &__n);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &operator>>(unsigned int &__n);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &operator>>(long &__n);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &operator>>(unsigned long &__n);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &operator>>(long long &__n);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &operator>>(unsigned long long &__n);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &operator>>(float &__f);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &operator>>(double &__f);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &operator>>(long double &__f);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &operator>>(void *&__p);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &operator>>(std::basic_istream<char, std::char_traits<char> >::__streambuf_type *__sb);
        std::streamsize gcount() const;
        std::basic_istream<char, std::char_traits<char> >::int_type get();
        std::basic_istream<char, std::char_traits<char> >::__istream_type &get(std::basic_istream<char, std::char_traits<char> >::char_type &__c);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &get(std::basic_istream<char, std::char_traits<char> >::char_type *__s, std::streamsize __n, std::basic_istream<char, std::char_traits<char> >::char_type __delim);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &get(std::basic_istream<char, std::char_traits<char> >::char_type *__s, std::streamsize __n);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &get(std::basic_istream<char, std::char_traits<char> >::__streambuf_type &__sb, std::basic_istream<char, std::char_traits<char> >::char_type __delim);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &get(std::basic_istream<char, std::char_traits<char> >::__streambuf_type &__sb);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &getline(std::basic_istream<char, std::char_traits<char> >::char_type *__s, std::streamsize __n, std::basic_istream<char, std::char_traits<char> >::char_type __delim);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &getline(std::basic_istream<char, std::char_traits<char> >::char_type *__s, std::streamsize __n);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &ignore(std::streamsize __n, std::basic_istream<char, std::char_traits<char> >::int_type __delim);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &ignore(std::streamsize __n);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &ignore();
        std::basic_istream<char, std::char_traits<char> >::int_type peek();
        std::basic_istream<char, std::char_traits<char> >::__istream_type &read(std::basic_istream<char, std::char_traits<char> >::char_type *__s, std::streamsize __n);
        std::streamsize readsome(std::basic_istream<char, std::char_traits<char> >::char_type *__s, std::streamsize __n);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &putback(std::basic_istream<char, std::char_traits<char> >::char_type __c);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &unget();
        int sync();
        std::basic_istream<char, std::char_traits<char> >::pos_type tellg();
        std::basic_istream<char, std::char_traits<char> >::__istream_type &seekg(std::basic_istream<char, std::char_traits<char> >::pos_type);
        std::basic_istream<char, std::char_traits<char> >::__istream_type &seekg(std::basic_istream<char, std::char_traits<char> >::off_type, ios_base::seekdir);
    protected:
        basic_istream();
        basic_istream(const std::basic_istream<char> &) = delete
        basic_istream(std::basic_istream<char> &&__rhs);
        std::basic_istream<char> &operator=(const std::basic_istream<char> &) = delete
        std::basic_istream<char> &operator=(std::basic_istream<char> &&__rhs);
        void swap(std::basic_istream<char> &__rhs);
        template <typename _ValueT> std::basic_istream<char, std::char_traits<char> >::__istream_type &_M_extract(_ValueT &__v);
    };
    template<> class basic_iostream<char> : public basic_istream<char, std::char_traits<char> >, public basic_ostream<char, std::char_traits<char> > {
    public:
        typedef char char_type;
        typedef typename char_traits<char>::int_type int_type;
        typedef typename char_traits<char>::pos_type pos_type;
        typedef typename char_traits<char>::off_type off_type;
        typedef std::char_traits<char> traits_type;
        typedef basic_istream<char, std::char_traits<char> > __istream_type;
        typedef basic_ostream<char, std::char_traits<char> > __ostream_type;
        explicit basic_iostream(basic_streambuf<char, std::char_traits<char> > *__sb);
        virtual ~basic_iostream<char>() throw();
    protected:
        basic_iostream();
        basic_iostream(const std::basic_iostream<char> &) = delete
        basic_iostream(std::basic_iostream<char> &&__rhs);
        std::basic_iostream<char> &operator=(const std::basic_iostream<char> &) = delete
        std::basic_iostream<char> &operator=(std::basic_iostream<char> &&__rhs);
        void swap(std::basic_iostream<char> &__rhs);
    };
    template<> class basic_istream<wchar_t> : virtual public basic_ios<wchar_t, std::char_traits<wchar_t> > {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_streambuf<wchar_t, std::char_traits<wchar_t> > __streambuf_type;
        typedef basic_ios<wchar_t, std::char_traits<wchar_t> > __ios_type;
        typedef basic_istream<wchar_t, std::char_traits<wchar_t> > __istream_type;
        typedef num_get<wchar_t, istreambuf_iterator<wchar_t, std::char_traits<wchar_t> > > __num_get_type;
        typedef ctype<wchar_t> __ctype_type;
    protected:
        std::streamsize _M_gcount;
    public:
        explicit basic_istream(std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__streambuf_type *__sb);
        virtual ~basic_istream<wchar_t>() throw();
        class sentry {
            bool _M_ok;
        public:
            typedef std::char_traits<wchar_t> traits_type;
            typedef basic_streambuf<wchar_t, std::char_traits<wchar_t> > __streambuf_type;
            typedef basic_istream<wchar_t, std::char_traits<wchar_t> > __istream_type;
            typedef typename __istream_type::__ctype_type __ctype_type;
            typedef typename char_traits<wchar_t>::int_type __int_type;
            explicit sentry(basic_istream<wchar_t, std::char_traits<wchar_t> > &__is, bool __noskipws);
            explicit operator bool() const;
        };
        friend  class sentry;
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &operator>>(std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &(*__pf)(std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &));
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &operator>>(std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__ios_type &(*__pf)(std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__ios_type &));
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &operator>>(std::ios_base &(*__pf)(std::ios_base &));
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &operator>>(bool &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &operator>>(short &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &operator>>(unsigned short &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &operator>>(int &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &operator>>(unsigned int &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &operator>>(long &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &operator>>(unsigned long &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &operator>>(long long &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &operator>>(unsigned long long &__n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &operator>>(float &__f);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &operator>>(double &__f);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &operator>>(long double &__f);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &operator>>(void *&__p);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &operator>>(std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__streambuf_type *__sb);
        std::streamsize gcount() const;
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::int_type get();
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &get(std::basic_istream<wchar_t, std::char_traits<wchar_t> >::char_type &__c);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &get(std::basic_istream<wchar_t, std::char_traits<wchar_t> >::char_type *__s, std::streamsize __n, std::basic_istream<wchar_t, std::char_traits<wchar_t> >::char_type __delim);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &get(std::basic_istream<wchar_t, std::char_traits<wchar_t> >::char_type *__s, std::streamsize __n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &get(std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__streambuf_type &__sb, std::basic_istream<wchar_t, std::char_traits<wchar_t> >::char_type __delim);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &get(std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__streambuf_type &__sb);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &getline(std::basic_istream<wchar_t, std::char_traits<wchar_t> >::char_type *__s, std::streamsize __n, std::basic_istream<wchar_t, std::char_traits<wchar_t> >::char_type __delim);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &getline(std::basic_istream<wchar_t, std::char_traits<wchar_t> >::char_type *__s, std::streamsize __n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &ignore(std::streamsize __n, std::basic_istream<wchar_t, std::char_traits<wchar_t> >::int_type __delim);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &ignore(std::streamsize __n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &ignore();
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::int_type peek();
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &read(std::basic_istream<wchar_t, std::char_traits<wchar_t> >::char_type *__s, std::streamsize __n);
        std::streamsize readsome(std::basic_istream<wchar_t, std::char_traits<wchar_t> >::char_type *__s, std::streamsize __n);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &putback(std::basic_istream<wchar_t, std::char_traits<wchar_t> >::char_type __c);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &unget();
        int sync();
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::pos_type tellg();
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &seekg(std::basic_istream<wchar_t, std::char_traits<wchar_t> >::pos_type);
        std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &seekg(std::basic_istream<wchar_t, std::char_traits<wchar_t> >::off_type, ios_base::seekdir);
    protected:
        basic_istream();
        basic_istream(const std::basic_istream<wchar_t> &) = delete
        basic_istream(std::basic_istream<wchar_t> &&__rhs);
        std::basic_istream<wchar_t> &operator=(const std::basic_istream<wchar_t> &) = delete
        std::basic_istream<wchar_t> &operator=(std::basic_istream<wchar_t> &&__rhs);
        void swap(std::basic_istream<wchar_t> &__rhs);
        template <typename _ValueT> std::basic_istream<wchar_t, std::char_traits<wchar_t> >::__istream_type &_M_extract(_ValueT &__v);
    };
    template<> class basic_iostream<wchar_t> : public basic_istream<wchar_t, std::char_traits<wchar_t> >, public basic_ostream<wchar_t, std::char_traits<wchar_t> > {
    public:
        typedef wchar_t char_type;
        typedef typename char_traits<wchar_t>::int_type int_type;
        typedef typename char_traits<wchar_t>::pos_type pos_type;
        typedef typename char_traits<wchar_t>::off_type off_type;
        typedef std::char_traits<wchar_t> traits_type;
        typedef basic_istream<wchar_t, std::char_traits<wchar_t> > __istream_type;
        typedef basic_ostream<wchar_t, std::char_traits<wchar_t> > __ostream_type;
        explicit basic_iostream(basic_streambuf<wchar_t, std::char_traits<wchar_t> > *__sb);
        virtual ~basic_iostream<wchar_t>() throw();
    protected:
        basic_iostream();
        basic_iostream(const std::basic_iostream<wchar_t> &) = delete
        basic_iostream(std::basic_iostream<wchar_t> &&__rhs);
        std::basic_iostream<wchar_t> &operator=(const std::basic_iostream<wchar_t> &) = delete
        std::basic_iostream<wchar_t> &operator=(std::basic_iostream<wchar_t> &&__rhs);
        void swap(std::basic_iostream<wchar_t> &__rhs);
    };
}
namespace std {
    extern std::istream cin;
    extern std::ostream cout;
    extern std::ostream cerr;
    extern std::ostream clog;
    extern std::wistream wcin;
    extern std::wostream wcout;
    extern std::wostream wcerr;
    extern std::wostream wclog;
    static ios_base::Init __ioinit;
}
template <class T> typename std::enable_if<std::is_floating_point<T>::value, T>::type foo1(T t) {
    std::cout << "foo1: float\n";
    return t;
}
template<> typename std::enable_if<std::is_floating_point<double>::value, double>::type foo1<double>(double t) {
    std::cout << "foo1: float\n";
    return t;
}
template<> typename std::enable_if<std::is_floating_point<float>::value, float>::type foo1<float>(float t) {
    std::cout << "foo1: float\n";
    return t;
}
template <class T> std::enable_if_t<std::is_integral<T>::value, T> foo1(T t) {
    std::cout << "foo1: int\n";
    return t;
}
template<> std::enable_if_t<std::is_integral<int>::value, int> foo1<int>(int t) {
    std::cout << "foo1: int\n";
    return t;
}
template <class T> T foo2(T t, typename std::enable_if<std::is_integral<T>::value>::type * = 0) {
    std::cout << " foo2 void " << t << " \n";
    return t;
}
template<> int foo2<int>(int t, typename std::enable_if<std::is_integral<int>::value>::type * = 0) {
    std::cout << " foo2 void " << t << " \n";
    return t;
}
template <class T> T foo2(T t, typename std::enable_if<std::is_integral<T>::value, T>::type *) {
    std::cout << " foo2 integral " << t << " \n";
    return t;
}
template<> int foo2<int>(int t, typename std::enable_if<std::is_integral<int>::value, int>::type *) {
    std::cout << " foo2 integral " << t << " \n";
    return t;
}
int foo2_check(int t, void * = 0) {
    std::cout << " foo2 check void " << t << " \n";
    return t;
}
template <class T, typename std::enable_if<std::is_integral<T>::value>::type * = nullptr> T foo3(T t) {
    std::cout << " foo3 \n";
    return t;
}
template<> int foo3<int, nullptr>(int t) {
    std::cout << " foo3 \n";
    return t;
}
template <class T, class Enable = void> class A
template<> class A<double, void> {
};
template <class T> class A<T, typename std::enable_if<std::is_floating_point<T>::value>::type> {
};
int main() {
    float fvar = 1.F;
    double dvar = 2.;
    int ivar = 5;
    foo1(1.2);
    foo1(10);
    foo1(fvar);
    foo1(dvar);
    foo1(ivar);
    std::cout << std::endl;
    foo2(7);
    int *pint = new int;
    foo2(7, pint);
    float *pflt = new float;
    foo2(7, pflt);
    foo2_check(5);
    foo2_check(8, pflt);
    std::cout << std::endl;
    foo3(34);
    void *vflt;
    A<double> a1;
}
