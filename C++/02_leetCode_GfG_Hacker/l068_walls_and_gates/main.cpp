
// babak poursartip
// Aug 28, 2022

#include <iostream>
#include <iterator>
#include <utility>
#include <vector>
#include <algorithm>
#include <queue>
#include <climits>

using namespace std;

class Solution {
public:
    
  using myp = pair<int,int>;
  void wallsAndGates(vector<vector<int>>& rooms) {
 
    if (rooms.empty()) return;
    int row = rooms.size();  
    int col = rooms[0].size();  

    // find all gates
    // vector<myp> gates;

    /*
    auto lm = [&](auto x){
      for_each(x.begin(), x.end(), [](auto y){if (y == 0) gates.push_back( make_pair(distance(x, rooms.begin()) ,distance(y,x.begin()) )  );  });
    };
    for_each(rooms.begin(), rooms.end(), lm);
    */
    
    int depth = 0;
    queue<pair<myp,int>> qq;
    for (int i = 0; i< row; i++)
      for (int j = 0; j< col; j++)
        if (rooms[i][j]==0) qq.push(make_pair(make_pair(i, j),depth));

    // print the gate locations
    // for_each(gates.begin(),gates.end(), [](auto x){ cout<< x.first << " " << x.second << endl;});
    
    // BFS from all gates
    // for (int i = 0; i<gates.size(); i++)
    {
      // vector<vector<bool>> visited(row);
      
      // for (int i = 0; i<row; i++)
        // visited[i].resize(col,false);
      
      // for (int i = 0; i<row; i++)
        // for (int j = 0; j<col; j++)
          // if (rooms[i][j] == 0 || rooms[i][j] == -1 ) 
            // visited[i][j] = true;
      
      // qq.push(make_pair(gates[i],depth));
      // cout << " working on: " << gates[i].first << " " << gates[i].second << endl;
      
      while(!qq.empty())
      {
        pair<myp,int> tmp = qq.front();
        qq.pop();
        int x  = tmp.first.first;
        int y = tmp.first.second;
        depth = tmp.second;
        // visited[x][y] = true;
        // cout<<" tested: " << x << " " << y << endl;
        if (rooms[x][y] > tmp.second) rooms[x][y] = tmp.second;
        // else continue;
        // cout << " ok 0 \n";
        // if ( x+1<row && !visited[x+1][y]) qq.push( make_pair(make_pair(x+1,y), depth+1) );
        // if ( x+1<row && rooms[x+1][y] > depth+1 ) qq.push( make_pair(make_pair(x+1,y), depth+1) );
        if ( x+1<row && rooms[x+1][y] ==INT_MAX ) qq.push( make_pair(make_pair(x+1,y), depth+1) );
        // cout << " ok 1 \n";
        // if ( x-1>=0 && !visited[x-1][y])   qq.push( make_pair(make_pair(x-1,y), depth+1) );
        // if ( x-1>=0 && rooms[x-1][y] > depth+1 )   qq.push( make_pair(make_pair(x-1,y), depth+1) );
        if ( x-1>=0 && rooms[x-1][y]==INT_MAX )   qq.push( make_pair(make_pair(x-1,y), depth+1) );
        // cout << " ok 2 \n";
        // if ( y-1>=0 && !visited[x][y-1])   qq.push( make_pair(make_pair(x,y-1), depth+1) );
        // if ( y-1>=0 && rooms[x][y-1] > depth+1 )   qq.push( make_pair(make_pair(x,y-1), depth+1) );
        if ( y-1>=0 && rooms[x][y-1]==INT_MAX )   qq.push( make_pair(make_pair(x,y-1), depth+1) );
        // cout << " ok 3 \n";
        // if ( y+1<col && !visited[x][y+1]) qq.push( make_pair(make_pair(x,y+1), depth+1) );
        // if ( y+1<col && rooms[x][y+1] > depth+1 ) qq.push( make_pair(make_pair(x,y+1), depth+1) );
        if ( y+1<col && rooms[x][y+1]==INT_MAX ) qq.push( make_pair(make_pair(x,y+1), depth+1) );
        // cout << " ok 4 \n";

/*
  auto lm0 = [](auto y){cout << (y==INT_MAX?-2:y) << " ";};
  auto lm = [&](auto x)
  {
    for_each(x.begin(),x.end(),lm0);
    cout << endl;
  };
  for_each(rooms.begin(), rooms.end(), lm);
  cout << endl;
*/

    }
    }
    }
};


int main(int argc, char* argv[])
{
  std::cout << " starts ... \n";

  /*
  vector<vector<int>> rooms{{2147483647,-1,0,2147483647},
                            {2147483647,2147483647,2147483647,-1},
                            {2147483647,-1,2147483647,-1},
                            {0,-1,2147483647,2147483647}};
  */
  //vector<vector<int>> rooms{{-1}};


  vector<vector<int>> rooms{{0,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647},{2147483647,0,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647},{2147483647,2147483647,0,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647},{2147483647,2147483647,2147483647,0,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647},{2147483647,2147483647,2147483647,2147483647,0,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647},{2147483647,2147483647,2147483647,2147483647,2147483647,0,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647},{2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,0,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647},{2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,0,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647},{2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,0,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647},{2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,0,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647},{2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,0,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647},{2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,0,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647},{2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,0,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647},{2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,0,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647},{2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,0,2147483647,2147483647,2147483647,2147483647,2147483647},{2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,0,2147483647,2147483647,2147483647,2147483647},{2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,0,2147483647,2147483647,2147483647},{2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,0,2147483647,2147483647},{2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,0,2147483647},{2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,2147483647,0}};

  auto lm0 = [](auto y){cout << (y==INT_MAX?-2:y) << " ";};
  auto lm = [&](auto x)
  {
    for_each(x.begin(),x.end(),lm0);
    cout << endl;
  };
  /*
  for_each(rooms.begin(), rooms.end(), lm);
  cout << endl;
  */

  
  Solution t;

  t.wallsAndGates(rooms);
  cout << " answer: "<< endl;
  //*
  for_each(rooms.begin(), rooms.end(), lm);
  cout << endl;
  //*/
  std::cout << " done \n";
  return 0;
}